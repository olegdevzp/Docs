# Comprehensive Angular Framework Questions for Middle-Level Developers

## Table of Contents

1. [Core Angular Concepts](#core-angular-concepts)
2. [Change Detection & Performance](#change-detection--performance)
3. [RxJS and Observables](#rxjs-and-observables)
4. [Signals (Angular 16+)](#signals-angular-16)
5. [Routing and Navigation](#routing-and-navigation)
6. [Forms and Validation](#forms-and-validation)
7. [Dependency Injection](#dependency-injection)
8. [Components and Templates](#components-and-templates)
9. [HTTP and APIs](#http-and-apis)
10. [State Management](#state-management)
11. [Testing](#testing)
12. [Advanced Topics](#advanced-topics)
13. [Architecture and Best Practices](#architecture-and-best-practices)
14. [TypeScript Integration](#typescript-integration)
15. [Build and Deployment](#build-and-deployment)
16. [Accessibility and CDK](#accessibility-and-cdk)
17. [Modern Angular Features](#modern-angular-features)
18. [Error Handling and Debugging](#error-handling-and-debugging)
19. [Security](#security)
20. [Migration and Upgrades](#migration-and-upgrades)

---

## Core Angular Concepts

1. [What is the difference between `@Component` and `@Directive`?](#1-what-is-the-difference-between-component-and-directive)
2. [Explain the Angular component lifecycle hooks and their execution order](#2-explain-the-angular-component-lifecycle-hooks-and-their-execution-order)
3. [What is dependency injection and how does it work in Angular?](#3-what-is-dependency-injection-and-how-does-it-work-in-angular)
4. [What are Angular services and how do you create them?](#4-what-are-angular-services-and-how-do-you-create-them)
5. [Explain the difference between `OnPush` and `Default` change detection strategies](#5-explain-the-difference-between-onpush-and-default-change-detection-strategies)
6. [What is the purpose of `NgZone` and when would you use it?](#6-what-is-the-purpose-of-ngzone-and-when-would-you-use-it)
7. [How do you handle lazy loading of modules in Angular?](#7-how-do-you-handle-lazy-loading-of-modules-in-angular)
8. [What are Angular pipes and how do you create custom pipes?](#8-what-are-angular-pipes-and-how-do-you-create-custom-pipes)
9. [Explain the difference between template-driven and reactive forms](#9-explain-the-difference-between-template-driven-and-reactive-forms)
10. [What is Angular CLI and what are its main commands?](#10-what-is-angular-cli-and-what-are-its-main-commands)
11. [What are Angular decorators and how do they work?](#11-what-are-angular-decorators-and-how-do-they-work)
12. [Explain the concept of Angular modules and their purpose](#12-explain-the-concept-of-angular-modules-and-their-purpose)
13. [What is the difference between constructor and ngOnInit?](#13-what-is-the-difference-between-constructor-and-ngoninit)
14. [How does Angular's hierarchical injector work?](#14-how-does-angulars-hierarchical-injector-work)
15. [What are providers and how do they work in Angular?](#15-what-are-providers-and-how-do-they-work-in-angular)

[Back to Top](#table-of-contents)

---

## Change Detection & Performance {#change-detection--performance}

16. [Explain Angular change detection and when to use `OnPush`](#16-explain-angular-change-detection-and-when-to-use-onpush)
17. [What is Zone.js and how does zone-less Angular work?](#17-what-is-zonejs-and-how-does-zone-less-angular-work)
18. [What are the performance implications of change detection?](#18-what-are-the-performance-implications-of-change-detection)
19. [How do you optimize Angular application performance?](#19-how-do-you-optimize-angular-application-performance)
20. [How do you implement virtual scrolling?](#20-how-do-you-implement-virtual-scrolling)
21. [What are the benefits of using trackBy functions in ngFor?](#21-what-are-the-benefits-of-using-trackby-functions-in-ngfor)
22. [How do you implement code splitting in Angular?](#22-how-do-you-implement-code-splitting-in-angular)
23. [What are lazy loading strategies and preloading?](#23-what-are-lazy-loading-strategies-and-preloading)
24. [What is tree shaking and how does it work?](#24-what-is-tree-shaking-and-how-does-it-work)
25. [How do you optimize bundle size?](#25-how-do-you-optimize-bundle-size)
26. [What are immutable patterns with `OnPush`?](#26-what-are-immutable-patterns-with-onpush)
27. [Explain `markForCheck` vs `detectChanges`](#27-explain-markforcheck-vs-detectchanges)
28. [How do you profile performance with Angular DevTools?](#28-how-do-you-profile-performance-with-angular-devtools)
29. [What are CD cycles and how to analyze them?](#29-what-are-cd-cycles-and-how-to-analyze-them)
30. [How do you implement efficient data structures for large datasets?](#30-how-do-you-implement-efficient-data-structures-for-large-datasets)

[Back to Top](#table-of-contents)

---

## RxJS and Observables

31. [What are Observables and how do they differ from Promises?](#31-what-are-observables-and-how-do-they-differ-from-promises)
32. [Compare `switchMap`, `mergeMap`, `concatMap`, and `exhaustMap` with real use cases](#32-compare-switchmap-mergemap-concatmap-and-exhaustmap-with-real-use-cases)
33. [How do you handle errors in RxJS streams?](#33-how-do-you-handle-errors-in-rxjs-streams)
34. [What is the purpose of the `async` pipe?](#34-what-is-the-purpose-of-the-async-pipe)
35. [How do you unsubscribe from Observables to prevent memory leaks?](#35-how-do-you-unsubscribe-from-observables-to-prevent-memory-leaks)
36. [What are Subjects and when would you use them?](#36-what-are-subjects-and-when-would-you-use-them)
37. [Explain hot vs cold Observables](#37-explain-hot-vs-cold-observables)
38. [How do you combine multiple Observables?](#38-how-do-you-combine-multiple-observables)
39. [How to multicast with `shareReplay` safely?](#39-how-to-multicast-with-sharereplay-safely)
40. [How do you prevent RxJS memory leaks in components/services?](#40-how-do-you-prevent-rxjs-memory-leaks-in-componentsservices)
41. [What are the different types of Subjects (BehaviorSubject, ReplaySubject)?](#41-what-are-the-different-types-of-subjects-behaviorsubject-replaysubject)
42. [How do you handle backpressure in RxJS?](#42-how-do-you-handle-backpressure-in-rxjs)
43. [What is the difference between `subscribe` and `tap`?](#43-what-is-the-difference-between-subscribe-and-tap)
44. [How do you test RxJS streams?](#44-how-do-you-test-rxjs-streams)
45. [What are marble diagrams and how to read them?](#45-what-are-marble-diagrams-and-how-to-read-them)

[Back to Top](#table-of-contents)

---

## Signals (Angular 16+)

46. [What are Angular Signals and how do they work?](#46-what-are-angular-signals-and-how-do-they-work)
47. [Signals vs Observables: when to use each?](#47-signals-vs-observables-when-to-use-each)
48. [How do you create computed signals?](#48-how-do-you-create-computed-signals)
49. [What is the difference between signals and observables?](#49-what-is-the-difference-between-signals-and-observables)
50. [How do you convert between signals and observables?](#50-how-do-you-convert-between-signals-and-observables)
51. [What are effect signals and when to use them?](#51-what-are-effect-signals-and-when-to-use-them)
52. [How do signals integrate with change detection?](#52-how-do-signals-integrate-with-change-detection)
53. [What are the benefits of using signals over observables?](#53-what-are-the-benefits-of-using-signals-over-observables)
54. [How do you handle async operations with signals?](#54-how-do-you-handle-async-operations-with-signals)
55. [What is signal-based state management?](#55-what-is-signal-based-state-management)

[Back to Top](#table-of-contents)

---

## Routing and Navigation

56. [How do you implement routing in Angular?](#56-how-do-you-implement-routing-in-angular)
57. [What are route guards and what types exist?](#57-what-are-route-guards-and-what-types-exist)
58. [How do you pass data between routes?](#58-how-do-you-pass-data-between-routes)
59. [What are route resolvers and how do you implement them?](#59-what-are-route-resolvers-and-how-do-you-implement-them)
60. [How do you handle route parameters and query parameters?](#60-how-do-you-handle-route-parameters-and-query-parameters)
61. [What is the difference between `router.navigate()` and `router.navigateByUrl()`?](#61-what-is-the-difference-between-routernavigate-and-routernavigatebyurl)
62. [How do you implement nested routing?](#62-how-do-you-implement-nested-routing)
63. [Routing with standalone APIs](#63-routing-with-standalone-apis)
64. [`CanMatch` vs `CanLoad` vs `CanActivate`](#64-canmatch-vs-canload-vs-canactivate)
65. [What are preloading strategies and how to implement custom preloader?](#65-what-are-preloading-strategies-and-how-to-implement-custom-preloader)
66. [How do you handle route resolvers?](#66-how-do-you-handle-route-resolvers)
67. [What are auxiliary routes?](#67-what-are-auxiliary-routes)
68. [How do you implement route animations?](#68-how-do-you-implement-route-animations)
69. [How do you handle router events?](#69-how-do-you-handle-router-events)
70. [What is the difference between absolute and relative navigation?](#70-what-is-the-difference-between-absolute-and-relative-navigation)
71. [How do you implement route animations and transitions?](#71-how-do-you-implement-route-animations-and-transitions)

[Back to Top](#table-of-contents)

---

## Forms and Validation

72. [How do you implement `ControlValueAccessor` for reusable form controls?](#72-how-do-you-implement-controlvalueaccessor-for-reusable-form-controls)
73. [What are sync vs async validators?](#73-what-are-sync-vs-async-validators)
74. [How do you create custom validators?](#74-how-do-you-create-custom-validators)
75. [How do you handle dynamic forms with `FormArray` and nested `FormGroup`s?](#75-how-do-you-handle-dynamic-forms-with-formarray-and-nested-formgroups)
76. [What is form validation and how to display errors?](#76-what-is-form-validation-and-how-to-display-errors)
77. [How do you implement conditional validation?](#77-how-do-you-implement-conditional-validation)
78. [What are form states (pristine, dirty, valid, invalid)?](#78-what-are-form-states-pristine-dirty-valid-invalid)
79. [How do you reset forms properly?](#79-how-do-you-reset-forms-properly)
80. [What is the difference between `setValue` and `patchValue`?](#80-what-is-the-difference-between-setvalue-and-patchvalue)
81. [How do you handle file uploads in forms?](#81-how-do-you-handle-file-uploads-in-forms)
82. [What are form builders and how to use them?](#82-what-are-form-builders-and-how-to-use-them)
83. [How do you implement cross-field validation?](#83-how-do-you-implement-cross-field-validation)
84. [What is debouncing in form validation?](#84-what-is-debouncing-in-form-validation)
85. [How do you handle form arrays dynamically?](#85-how-do-you-handle-form-arrays-dynamically)

[Back to Top](#table-of-contents)

---

## Dependency Injection

86. [What are DI tokens (`InjectionToken`) and multi providers?](#86-what-are-di-tokens-injectiontoken-and-multi-providers)
87. [Explain injector hierarchy in Angular](#87-explain-injector-hierarchy-in-angular)
88. [`providedIn: root` vs `any` vs `platform`](#88-providedin-root-vs-any-vs-platform)
89. [What is the difference between singleton and transient services?](#89-what-is-the-difference-between-singleton-and-transient-services)
90. [How do you inject dependencies in standalone components?](#90-how-do-you-inject-dependencies-in-standalone-components)
91. [What are optional dependencies?](#91-what-are-optional-dependencies)
92. [How do you create factory providers?](#92-how-do-you-create-factory-providers)
93. [What is forward reference and when to use it?](#93-what-is-forward-reference-and-when-to-use-it)
94. [How do you handle circular dependencies?](#94-how-do-you-handle-circular-dependencies)
95. [What are injection scopes?](#95-what-are-injection-scopes)

[Back to Top](#table-of-contents)

---

## Components and Templates

96. [What are standalone components vs NgModules?](#96-what-are-standalone-components-vs-ngmodules)
97. [How do you handle component communication?](#97-how-do-you-handle-component-communication)
98. [What is content projection (single/multi-slot)?](#98-what-is-content-projection-singlemulti-slot)
99. [Explain `ng-content select`](#99-explain-ng-content-select)
100. [What are view queries vs content queries?](#100-what-are-view-queries-vs-content-queries)
101. [Explain `@ViewChild` options](#101-explain-viewchild-options)
102. [What is the difference between `*ngIf` vs `[hidden]`?](#102-what-is-the-difference-between-ngif-vs-hidden)
103. [How do you use `ng-template`, `ng-container`?](#103-how-do-you-use-ng-template-ng-container)
104. [What are Angular 17 control flow features (`@if`, `@for`, `@defer`)?](#104-what-are-angular-17-control-flow-features-if-for-defer)
105. [How do you handle dynamic component loading?](#105-how-do-you-handle-dynamic-component-loading)
106. [What are component factories?](#106-what-are-component-factories)
107. [How do you pass data to dynamically created components?](#107-how-do-you-pass-data-to-dynamically-created-components)
108. [What is view encapsulation and its modes?](#108-what-is-view-encapsulation-and-its-modes)
109. [How do you use `:host` and `::ng-deep`?](#109-how-do-you-use-host-and-ng-deep)
110. [What are host bindings and host listeners?](#110-what-are-host-bindings-and-host-listeners)

[Back to Top](#table-of-contents)

---

## HTTP and APIs

111. [How do you make HTTP requests in Angular?](#111-how-do-you-make-http-requests-in-angular)
112. [What are HTTP interceptors and how do you use them?](#112-what-are-http-interceptors-and-how-do-you-use-them)
113. [How do you handle HTTP errors globally?](#113-how-do-you-handle-http-errors-globally)
114. [How do you implement caching for HTTP requests?](#114-how-do-you-implement-caching-for-http-requests)
115. [What is the difference between `HttpClient` and the old `Http` service?](#115-what-is-the-difference-between-httpclient-and-the-old-http-service)
116. [How do you handle authentication with HTTP interceptors?](#116-how-do-you-handle-authentication-with-http-interceptors)
117. [What are HTTP retry mechanisms and backoff strategies?](#117-what-are-http-retry-mechanisms-and-backoff-strategies)
118. [How do you cancel HTTP requests?](#118-how-do-you-cancel-http-requests)
119. [How do you handle file uploads and downloads?](#119-how-do-you-handle-file-uploads-and-downloads)
120. [What are HTTP headers and how to set them?](#120-what-are-http-headers-and-how-to-set-them)
121. [How do you mock HTTP requests for testing?](#121-how-do-you-mock-http-requests-for-testing)
122. [What is CORS and how to handle it?](#122-what-is-cors-and-how-to-handle-it)
123. [How do you implement request/response transformation?](#123-how-do-you-implement-requestresponse-transformation)
124. [What are HTTP progress events?](#124-what-are-http-progress-events)
125. [How do you handle concurrent HTTP requests?](#125-how-do-you-handle-concurrent-http-requests)

[Back to Top](#table-of-contents)

---

## State Management

126. [What are the different approaches to state management in Angular?](#126-what-are-the-different-approaches-to-state-management-in-angular)
127. [How does NgRx work and what are its core concepts?](#127-how-does-ngrx-work-and-what-are-its-core-concepts)
128. [What are effects in NgRx and when do you use them?](#128-what-are-effects-in-ngrx-and-when-do-you-use-them)
129. [How do you handle side effects in Angular applications?](#129-how-do-you-handle-side-effects-in-angular-applications)
130. [What is the difference between local component state and global state?](#130-what-is-the-difference-between-local-component-state-and-global-state)
131. [NgRx/ComponentStore vs service-with-RxJS vs Signals Store](#131-ngrxcomponentstore-vs-service-with-rxjs-vs-signals-store)
132. [What are reducers and how do they work?](#132-what-are-reducers-and-how-do-they-work)
133. [What are selectors in NgRx?](#133-what-are-selectors-in-ngrx)
134. [How do you handle async operations in NgRx?](#134-how-do-you-handle-async-operations-in-ngrx)
135. [What is the Entity pattern in NgRx?](#135-what-is-the-entity-pattern-in-ngrx)
136. [How do you implement optimistic updates?](#136-how-do-you-implement-optimistic-updates)
137. [What are NgRx best practices?](#137-what-are-ngrx-best-practices)
138. [How do you debug NgRx applications?](#138-how-do-you-debug-ngrx-applications)
139. [What is ComponentStore and when to use it?](#139-what-is-componentstore-and-when-to-use-it)
140. [How do you handle state persistence?](#140-how-do-you-handle-state-persistence)

[Back to Top](#table-of-contents)

---

## Testing

141. [What testing frameworks are commonly used with Angular?](#141-what-testing-frameworks-are-commonly-used-with-angular)
142. [How do you write unit tests for Angular components?](#142-how-do-you-write-unit-tests-for-angular-components)
143. [What is the difference between shallow and deep component testing?](#143-what-is-the-difference-between-shallow-and-deep-component-testing)
144. [How do you mock dependencies in Angular tests?](#144-how-do-you-mock-dependencies-in-angular-tests)
145. [How do you test HTTP requests in Angular?](#145-how-do-you-test-http-requests-in-angular)
146. [What are end-to-end tests and how do you implement them?](#146-what-are-end-to-end-tests-and-how-do-you-implement-them)
147. [Testing standalone components with `TestBed`](#147-testing-standalone-components-with-testbed)
148. [How to use `fakeAsync` and Http testing?](#148-how-to-use-fakeasync-and-http-testing)
149. [What are test doubles (mocks, stubs, spies)?](#149-what-are-test-doubles-mocks-stubs-spies)
150. [How do you test reactive forms?](#150-how-do-you-test-reactive-forms)
151. [How do you test async operations?](#151-how-do-you-test-async-operations)
152. [What is code coverage and how to measure it?](#152-what-is-code-coverage-and-how-to-measure-it)
153. [How do you test custom pipes?](#153-how-do-you-test-custom-pipes)
154. [How do you test services with dependencies?](#154-how-do-you-test-services-with-dependencies)
155. [What are integration tests vs unit tests?](#155-what-are-integration-tests-vs-unit-tests)

[Back to Top](#table-of-contents)

---

## Advanced Topics

156. [What are Angular Elements and when would you use them?](#156-what-are-angular-elements-and-when-would-you-use-them)
157. [How do you implement internationalization (i18n) in Angular?](#157-how-do-you-implement-internationalization-i18n-in-angular)
158. [What is Angular Universal and server-side rendering?](#158-what-is-angular-universal-and-server-side-rendering)
159. [How do you implement Progressive Web App features in Angular?](#159-how-do-you-implement-progressive-web-app-features-in-angular)
160. [What are Angular schematics and how do you create them?](#160-what-are-angular-schematics-and-how-do-you-create-them)
161. [How do you create custom Angular libraries?](#161-how-do-you-create-custom-angular-libraries)
162. [What is Ivy renderer and what are its benefits?](#162-what-is-ivy-renderer-and-what-are-its-benefits)
163. [What is `CUSTOM_ELEMENTS_SCHEMA`?](#163-what-is-custom_elements_schema)
164. [How do you use `$localize` and ICU expressions?](#164-how-do-you-use-localize-and-icu-expressions)
165. [What are runtime vs build-time i18n approaches?](#165-what-are-runtime-vs-build-time-i18n-approaches)
166. [How do you implement SSR and hydration?](#166-how-do-you-implement-ssr-and-hydration)
167. [What is `TransferState` in Angular Universal?](#167-what-is-transferstate-in-angular-universal)
168. [How do you implement PWA with Angular Service Worker?](#168-how-do-you-implement-pwa-with-angular-service-worker)
169. [What are caching strategies for PWAs?](#169-what-are-caching-strategies-for-pwas)
170. [How do you handle service worker updates?](#170-how-do-you-handle-service-worker-updates)

[Back to Top](#table-of-contents)

---

## Architecture and Best Practices

171. [How do you structure a large Angular application?](#171-how-do-you-structure-a-large-angular-application)
172. [What are Angular best practices for component communication?](#172-what-are-angular-best-practices-for-component-communication)
173. [How do you implement error handling in Angular applications?](#173-how-do-you-implement-error-handling-in-angular-applications)
174. [What is the difference between smart and dumb components?](#174-what-is-the-difference-between-smart-and-dumb-components)
175. [How do you implement authentication and authorization?](#175-how-do-you-implement-authentication-and-authorization)
176. [What are Angular style guides and why are they important?](#176-what-are-angular-style-guides-and-why-are-they-important)
177. [How do you handle environment-specific configurations?](#177-how-do-you-handle-environment-specific-configurations)
178. [What are micro-frontends and how to implement them?](#178-what-are-micro-frontends-and-how-to-implement-them)
179. [How do you implement feature modules?](#179-how-do-you-implement-feature-modules)
180. [What is the single responsibility principle in Angular?](#180-what-is-the-single-responsibility-principle-in-angular)
181. [How do you handle shared modules?](#181-how-do-you-handle-shared-modules)
182. [What are barrel exports?](#182-what-are-barrel-exports)
183. [How do you implement lazy loading strategies?](#183-how-do-you-implement-lazy-loading-strategies)
184. [What are the SOLID principles in Angular?](#184-what-are-the-solid-principles-in-angular)
185. [How do you handle code organization and folder structure?](#185-how-do-you-handle-code-organization-and-folder-structure)

[Back to Top](#table-of-contents)

---

## TypeScript Integration

186. [How does TypeScript enhance Angular development?](#186-how-does-typescript-enhance-angular-development)
187. [What are Angular decorators and how do they work?](#187-what-are-angular-decorators-and-how-do-they-work)
188. [How do you use TypeScript interfaces in Angular?](#188-how-do-you-use-typescript-interfaces-in-angular)
189. [What are generic types and how do you use them in Angular?](#189-what-are-generic-types-and-how-do-you-use-them-in-angular)
190. [How do you implement type-safe HTTP requests?](#190-how-do-you-implement-type-safe-http-requests)
191. [What are utility types in TypeScript?](#191-what-are-utility-types-in-typescript)
192. [How do you use enums in Angular?](#192-how-do-you-use-enums-in-angular)
193. [What is type assertion and type guards?](#193-what-is-type-assertion-and-type-guards)
194. [How do you handle optional properties?](#194-how-do-you-handle-optional-properties)
195. [What are mapped types and conditional types?](#195-what-are-mapped-types-and-conditional-types)

[Back to Top](#table-of-contents)

---

## Build and Deployment

196. [How do you configure Angular build process?](#196-how-do-you-configure-angular-build-process)
197. [What are build optimization techniques?](#197-what-are-build-optimization-techniques)
198. [How do you set up budgets and source maps?](#198-how-do-you-set-up-budgets-and-source-maps)
199. [What is strict TypeScript mode?](#199-what-is-strict-typescript-mode)
200. [How do you implement environment configurations?](#200-how-do-you-implement-environment-configurations)
201. [What are Angular build targets?](#201-what-are-angular-build-targets)
202. [How do you optimize for production builds?](#202-how-do-you-optimize-for-production-builds)
203. [What is differential loading?](#203-what-is-differential-loading)
204. [How do you implement build-time optimizations?](#204-how-do-you-implement-build-time-optimizations)
205. [What are build analyzers and how to use them?](#205-what-are-build-analyzers-and-how-to-use-them)

[Back to Top](#table-of-contents)

---

## Accessibility and CDK

206. [How do you implement accessibility in Angular?](#206-how-do-you-implement-accessibility-in-angular)
207. [What are CDK a11y utilities (`FocusMonitor`, `LiveAnnouncer`)?](#207-what-are-cdk-a11y-utilities-focusmonitor-liveannouncer)
208. [How do you use CDK Overlay/Portals?](#208-how-do-you-use-cdk-overlayportals)
209. [What are positioning and scroll strategies?](#209-what-are-positioning-and-scroll-strategies)
210. [How do you implement keyboard navigation?](#210-how-do-you-implement-keyboard-navigation)
211. [What are ARIA attributes and how to use them?](#211-what-are-aria-attributes-and-how-to-use-them)
212. [How do you handle focus management?](#212-how-do-you-handle-focus-management)
213. [What are screen reader considerations?](#213-what-are-screen-reader-considerations)
214. [How do you test accessibility?](#214-how-do-you-test-accessibility)
215. [What are CDK layout utilities?](#215-what-are-cdk-layout-utilities)

[Back to Top](#table-of-contents)

---

## Modern Angular Features

216. [What are directive input coercion and best practices?](#216-what-are-directive-input-coercion-and-best-practices)
217. [How do you use `takeUntilDestroyed` and `DestroyRef`?](#217-how-do-you-use-takeuntildestroyed-and-destroyref)
218. [What are pure vs impure pipes and their performance impact?](#218-what-are-pure-vs-impure-pipes-and-their-performance-impact)
219. [How does `AsyncPipe` work with OnPush?](#219-how-does-asyncpipe-work-with-onpush)
220. [What are the new control flow features in Angular 17?](#220-what-are-the-new-control-flow-features-in-angular-17)
221. [How do you use `@defer` for lazy loading?](#221-how-do-you-use-defer-for-lazy-loading)
222. [What are signal inputs and outputs?](#222-what-are-signal-inputs-and-outputs)
223. [How do you migrate from NgModules to standalone?](#223-how-do-you-migrate-from-ngmodules-to-standalone)
224. [What are the benefits of standalone APIs?](#224-what-are-the-benefits-of-standalone-apis)
225. [How do you handle migration strategies?](#225-how-do-you-handle-migration-strategies)

[Back to Top](#table-of-contents)

---

## Error Handling and Debugging

226. [How do you implement global error handling?](#226-how-do-you-implement-global-error-handling)
227. [What is `ErrorHandler` and router errors?](#227-what-is-errorhandler-and-router-errors)
228. [How do you handle async errors?](#228-how-do-you-handle-async-errors)
229. [What are debugging techniques in Angular?](#229-what-are-debugging-techniques-in-angular)
230. [How do you use browser dev tools with Angular?](#230-how-do-you-use-browser-dev-tools-with-angular)
231. [What are common Angular errors and solutions?](#231-what-are-common-angular-errors-and-solutions)
232. [How do you implement logging strategies?](#232-how-do-you-implement-logging-strategies)
233. [What are error boundaries in Angular?](#233-what-are-error-boundaries-in-angular)
234. [How do you handle network errors?](#234-how-do-you-handle-network-errors)
235. [What are debugging tools and extensions?](#235-what-are-debugging-tools-and-extensions)

[Back to Top](#table-of-contents)

---

## Security

236. [What are Angular security best practices?](#236-what-are-angular-security-best-practices)
237. [How do you prevent XSS attacks?](#237-how-do-you-prevent-xss-attacks)
238. [What is Content Security Policy (CSP)?](#238-what-is-content-security-policy-csp)
239. [How do you handle authentication tokens securely?](#239-how-do-you-handle-authentication-tokens-securely)
240. [What are CSRF attacks and prevention?](#240-what-are-csrf-attacks-and-prevention)
241. [How do you sanitize user input?](#241-how-do-you-sanitize-user-input)
242. [What are trusted types?](#242-what-are-trusted-types)
243. [How do you implement secure HTTP communication?](#243-how-do-you-implement-secure-http-communication)
244. [What are security headers?](#244-what-are-security-headers)
245. [How do you handle sensitive data?](#245-how-do-you-handle-sensitive-data)

[Back to Top](#table-of-contents)

---

## Migration and Upgrades

246. [How do you upgrade Angular versions?](#246-how-do-you-upgrade-angular-versions)
247. [What are breaking changes to watch for?](#247-what-are-breaking-changes-to-watch-for)
248. [How do you migrate from AngularJS to Angular?](#248-how-do-you-migrate-from-angularjs-to-angular)
249. [What are migration tools and strategies?](#249-what-are-migration-tools-and-strategies)
250. [How do you handle deprecated APIs?](#250-how-do-you-handle-deprecated-apis)
251. [What is ng update and how to use it?](#251-what-is-ng-update-and-how-to-use-it)
252. [How do you handle third-party library updates?](#252-how-do-you-handle-third-party-library-updates)
253. [What are migration schematics?](#253-what-are-migration-schematics)
254. [How do you test after migrations?](#254-how-do-you-test-after-migrations)
255. [What are rollback strategies?](#255-what-are-rollback-strategies)

[Back to Top](#table-of-contents)

---

## Question Details

### 1. What is the difference between `@Component` and `@Directive`?

**Answer:**
`@Component` and `@Directive` are both decorators in Angular, but they serve different purposes:

**@Component:**
- Creates a component with its own template, styles, and logic
- Has a template (HTML) that defines the view
- Can have encapsulated styles
- Represents a complete UI element
- Extends the `@Directive` functionality
- Example: `<app-user-card>` with its own template and styling

**@Directive:**
- Modifies the behavior or appearance of existing DOM elements
- No template of its own
- Three types: Component directives, Structural directives (`*ngIf`, `*ngFor`), and Attribute directives (`ngClass`, `ngStyle`)
- Adds functionality to existing elements
- Example: `<div myHighlight>` where `myHighlight` changes the element's behavior

```typescript
// Component
@Component({
  selector: 'app-user',
  template: '<h1>{{name}}</h1>',
  styleUrls: ['./user.component.css']
})
export class UserComponent { }

// Directive
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective { }
```

[Back to Core Angular Concepts](#core-angular-concepts)

### 2. Explain the Angular component lifecycle hooks and their execution order

**Answer:**
Angular component lifecycle hooks are methods that allow you to tap into key moments in a component's lifecycle. Here's the execution order:

**1. ngOnChanges()** - Called when input properties change
**2. ngOnInit()** - Called once after the first ngOnChanges (component initialization)
**3. ngDoCheck()** - Called during every change detection run
**4. ngAfterContentInit()** - Called once after content projection is initialized
**5. ngAfterContentChecked()** - Called after every check of projected content
**6. ngAfterViewInit()** - Called once after the component's view is initialized
**7. ngAfterViewChecked()** - Called after every check of the component's view
**8. ngOnDestroy()** - Called just before the component is destroyed

```typescript
export class MyComponent implements OnInit, OnDestroy, OnChanges {
  @Input() data: string;

  ngOnChanges(changes: SimpleChanges) {
    console.log('1. ngOnChanges - Input changed');
  }

  ngOnInit() {
    console.log('2. ngOnInit - Component initialized');
  }

  ngOnDestroy() {
    console.log('8. ngOnDestroy - Component destroyed');
    // Cleanup subscriptions, timers, etc.
  }
}
```

**Common Use Cases:**
- `ngOnInit`: API calls, component setup
- `ngOnDestroy`: Cleanup subscriptions, prevent memory leaks
- `ngOnChanges`: React to input property changes
- `ngAfterViewInit`: Access DOM elements, initialize third-party libraries

[Back to Core Angular Concepts](#core-angular-concepts)

### 3. What is dependency injection and how does it work in Angular?

**Answer:**
Dependency Injection (DI) is a design pattern where objects receive their dependencies from external sources rather than creating them internally. Angular has a built-in DI system that manages the creation and sharing of service instances.

**How it works:**
1. **Services are registered** with Angular's injector using providers
2. **Components/services declare dependencies** in their constructor
3. **Angular's injector resolves dependencies** and provides instances
4. **Hierarchical injector system** determines which instance to provide

**Key Benefits:**
- **Loose coupling** - Components don't need to know how to create dependencies
- **Testability** - Easy to mock dependencies for testing
- **Reusability** - Services can be shared across components
- **Maintainability** - Changes to dependencies don't affect consumers

```typescript
// Service
@Injectable({
  providedIn: 'root' // Registers with root injector
})
export class UserService {
  getUsers() {
    return this.http.get('/api/users');
  }
}

// Component using DI
@Component({
  selector: 'app-users',
  template: '...'
})
export class UsersComponent {
  constructor(private userService: UserService) {} // DI in action
  
  loadUsers() {
    this.userService.getUsers().subscribe(users => {
      // Handle users
    });
  }
}
```

**Injector Hierarchy:**
- **Platform Injector** (top level)
- **Application Injector** (app-wide singletons)
- **Module Injectors** (lazy-loaded modules)
- **Component Injectors** (component-specific instances)

[Back to Core Angular Concepts](#core-angular-concepts)

### 4. What are Angular services and how do you create them?

**Answer:**
Angular services are singleton objects that provide specific functionality across your application. They're used for data sharing, business logic, API calls, and other reusable functionality.

**Key Characteristics:**
- **Singleton pattern** - One instance shared across the app (by default)
- **Injectable** - Can be injected into components and other services
- **Reusable** - Logic can be shared across multiple components
- **Testable** - Easy to unit test in isolation

**Creating a Service:**

1. **Using Angular CLI:**
```bash
ng generate service user
# or
ng g s user
```

2. **Manual Creation:**
```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Injectable({
  providedIn: 'root' // Makes it available app-wide
})
export class UserService {
  private apiUrl = '/api/users';

  constructor(private http: HttpClient) {}

  getUsers() {
    return this.http.get(this.apiUrl);
  }

  createUser(user: any) {
    return this.http.post(this.apiUrl, user);
  }
}
```

**Provider Options:**
- `providedIn: 'root'` - App-wide singleton
- `providedIn: 'any'` - New instance per lazy module
- Module providers array for module-specific services

[Back to Core Angular Concepts](#core-angular-concepts)

### 5. Explain the difference between `OnPush` and `Default` change detection strategies

**Answer:**
Change detection strategies determine when Angular checks for changes in component data and updates the DOM.

**Default Strategy:**
- Checks the component on **every change detection cycle**
- Triggered by events, HTTP requests, timers, promises
- Checks all bindings in the component tree
- **Performance impact** on large applications
- Used by default for all components

**OnPush Strategy:**
- Checks the component only when:
  - **Input properties change** (reference change, not mutation)
  - **Event is triggered** from the component or its children
  - **Observable emits** (via async pipe)
  - **Manually triggered** with `markForCheck()`
- **Better performance** - fewer checks
- Requires **immutable data patterns**

```typescript
// OnPush Component
@Component({
  selector: 'app-user-list',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div *ngFor="let user of users; trackBy: trackByFn">
      {{ user.name }}
    </div>
  `
})
export class UserListComponent {
  @Input() users: User[]; // Must change reference to trigger update
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  // Manual trigger when needed
  refresh() {
    this.cdr.markForCheck();
  }
  
  trackByFn(index: number, user: User) {
    return user.id; // Improves performance
  }
}
```

**Best Practices with OnPush:**
- Use immutable data (spread operator, Object.assign)
- Implement trackBy functions for *ngFor
- Use async pipe for observables
- Avoid object mutations

[Back to Core Angular Concepts](#core-angular-concepts)

### 6. What is the purpose of `NgZone` and when would you use it?

**Answer:**
NgZone is Angular's wrapper around Zone.js that helps Angular know when to run change detection. It patches asynchronous operations to automatically trigger change detection.

**Purpose:**
- **Automatic change detection** after async operations
- **Patches browser APIs** (setTimeout, Promise, addEventListener)
- **Notifies Angular** when async operations complete
- **Manages execution context** for Angular operations

**Common Use Cases:**

**1. Running code outside Angular zone (performance optimization):**
```typescript
export class ChartComponent {
  constructor(private ngZone: NgZone) {}
  
  initChart() {
    // Heavy animation that doesn't need change detection
    this.ngZone.runOutsideAngular(() => {
      setInterval(() => {
        // Update chart animation
        this.animateChart();
      }, 16); // 60fps
    });
  }
}
```

**2. Running code inside Angular zone:**
```typescript
thirdPartyCallback() {
  // Third-party library callback
  this.ngZone.run(() => {
    // This will trigger change detection
    this.updateData();
  });
}
```

**3. Detecting when Angular is stable:**
```typescript
ngOnInit() {
  this.ngZone.onStable.subscribe(() => {
    console.log('Angular is stable - all async operations complete');
  });
}
```

**Zone-less Angular (Modern Approach):**
With Angular 14+, you can opt out of Zone.js and use signals or manual change detection for better performance.

[Back to Core Angular Concepts](#core-angular-concepts)

### 7. How do you handle lazy loading of modules in Angular?

**Answer:**
Lazy loading allows you to load feature modules only when needed, reducing initial bundle size and improving application startup time.

**Implementation Steps:**

**1. Create Feature Module:**
```typescript
// feature.module.ts
@NgModule({
  declarations: [FeatureComponent],
  imports: [CommonModule, FeatureRoutingModule]
})
export class FeatureModule {}
```

**2. Setup Feature Routing:**
```typescript
// feature-routing.module.ts
const routes: Routes = [
  { path: '', component: FeatureComponent }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class FeatureRoutingModule {}
```

**3. Configure Lazy Route in App Routing:**
```typescript
// app-routing.module.ts
const routes: Routes = [
  {
    path: 'feature',
    loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)
  },
  // Standalone component (Angular 14+)
  {
    path: 'standalone',
    loadComponent: () => import('./standalone/standalone.component').then(c => c.StandaloneComponent)
  }
];
```

**Benefits:**
- **Smaller initial bundle** - Only core functionality loads first
- **Faster startup time** - Reduced JavaScript to parse
- **Better user experience** - Progressive loading
- **Automatic code splitting** - Webpack creates separate bundles

**Best Practices:**
- Use preloading strategies for commonly accessed routes
- Implement loading indicators for lazy routes
- Consider route guards for lazy modules
- Monitor bundle sizes with Angular CLI budgets

[Back to Core Angular Concepts](#core-angular-concepts)

### 8. What are Angular pipes and how do you create custom pipes?

**Answer:**
Pipes transform data in templates without changing the original data. They're pure functions that take input and return formatted output.

**Built-in Pipes:**
```html
<!-- Common pipes -->
{{ name | uppercase }}
{{ price | currency:'USD':'symbol':'1.2-2' }}
{{ birthday | date:'shortDate' }}
{{ data | json }}
{{ items | slice:0:5 }}
```

**Creating Custom Pipes:**

**1. Using Angular CLI:**
```bash
ng generate pipe custom-pipe
```

**2. Manual Implementation:**
```typescript
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'truncate',
  pure: true // Default - recalculates only when input changes
})
export class TruncatePipe implements PipeTransform {
  transform(value: string, limit: number = 50, trail: string = '...'): string {
    if (!value) return '';
    return value.length > limit ? value.substring(0, limit) + trail : value;
  }
}
```

**Usage:**
```html
<p>{{ longText | truncate:100:'...' }}</p>
```

**Pure vs Impure Pipes:**
- **Pure (default):** Only recalculates when input reference changes
- **Impure:** Recalculates on every change detection cycle

```typescript
@Pipe({
  name: 'impureFilter',
  pure: false // Runs on every CD cycle - use sparingly
})
export class ImpureFilterPipe implements PipeTransform {
  transform(items: any[], filter: any): any[] {
    return items.filter(item => /* filter logic */);
  }
}
```

**Best Practices:**
- Keep pipes pure for performance
- Use memoization for expensive calculations
- Avoid side effects in pipe transform methods
- Consider using computed properties for complex transformations

[Back to Core Angular Concepts](#core-angular-concepts)

### 9. Explain the difference between template-driven and reactive forms

**Answer:**
Angular provides two approaches for handling forms, each with distinct characteristics and use cases.

**Template-Driven Forms:**
- **Template-centric** - Form structure defined in template
- **Two-way data binding** - Uses `[(ngModel)]`
- **Implicit form model** - Angular creates FormControl instances
- **Asynchronous** - Form model is created after view initialization
- **Easier for simple forms** - Less boilerplate code

```html
<!-- Template-driven form -->
<form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)">
  <input 
    name="email" 
    [(ngModel)]="user.email" 
    #email="ngModel"
    required 
    email>
  
  <div *ngIf="email.invalid && email.touched">
    Email is required and must be valid
  </div>
  
  <button [disabled]="userForm.invalid">Submit</button>
</form>
```

**Reactive Forms:**
- **Component-centric** - Form structure defined in component
- **Explicit form model** - You create FormControl instances
- **Synchronous** - Form model available immediately
- **More control** - Programmatic access to form state
- **Better for complex forms** - Dynamic forms, complex validation

```typescript
// Reactive form
export class UserComponent {
  userForm = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, Validators.minLength(8)]]
  });
  
  constructor(private fb: FormBuilder) {}
  
  onSubmit() {
    if (this.userForm.valid) {
      console.log(this.userForm.value);
    }
  }
}
```

```html
<form [formGroup]="userForm" (ngSubmit)="onSubmit()">
  <input formControlName="email">
  <div *ngIf="userForm.get('email')?.invalid && userForm.get('email')?.touched">
    Email errors
  </div>
  <button [disabled]="userForm.invalid">Submit</button>
</form>
```

**When to Use:**
- **Template-driven:** Simple forms, rapid prototyping, less complex validation
- **Reactive:** Complex forms, dynamic forms, custom validators, unit testing

[Back to Core Angular Concepts](#core-angular-concepts)

### 10. What is Angular CLI and what are its main commands?

**Answer:**
Angular CLI is a command-line interface tool that helps create, build, test, and deploy Angular applications. It provides scaffolding, build optimization, and development server capabilities.

**Installation:**
```bash
npm install -g @angular/cli
```

**Main Commands:**

**Project Management:**
```bash
# Create new application
ng new my-app

# Serve development server
ng serve
# ng serve --port 4200 --open

# Build for production
ng build
# ng build --prod --aot

# Run tests
ng test        # Unit tests
ng e2e         # End-to-end tests

# Lint code
ng lint
```

**Code Generation:**
```bash
# Generate component
ng generate component user-list
ng g c user-list

# Generate service
ng generate service user
ng g s user

# Generate module
ng generate module feature --routing
ng g m feature --routing

# Generate directive
ng generate directive highlight
ng g d highlight

# Generate pipe
ng generate pipe custom
ng g p custom

# Generate guard
ng generate guard auth
ng g g auth
```

**Advanced Commands:**
```bash
# Add dependencies
ng add @angular/material
ng add @ngrx/store

# Update dependencies
ng update
ng update @angular/core @angular/cli

# Analyze bundle
ng build --stats-json
npx webpack-bundle-analyzer dist/stats.json

# Extract i18n messages
ng extract-i18n
```

**Configuration:**
- `angular.json` - Workspace configuration
- `ng config` - View/modify CLI configuration
- Schematics customization for code generation
- Build configurations for different environments

[Back to Core Angular Concepts](#core-angular-concepts)

### 11. What are Angular decorators and how do they work?

**Answer:**
Decorators are TypeScript features that add metadata to classes, methods, properties, and parameters. Angular uses decorators extensively to configure components, services, and other elements.

**How Decorators Work:**
- **Metadata attachment** - Add configuration to classes/properties
- **Compile-time processing** - Angular compiler reads metadata
- **Runtime behavior** - Influence how Angular treats decorated elements
- **Function-based** - Decorators are functions that return functions

**Main Angular Decorators:**

**Class Decorators:**
```typescript
// @Component - Defines a component
@Component({
  selector: 'app-user',
  template: '<h1>{{title}}</h1>',
  styleUrls: ['./user.component.css']
})
export class UserComponent {}

// @Injectable - Makes class available for DI
@Injectable({
  providedIn: 'root'
})
export class UserService {}

// @NgModule - Defines a module
@NgModule({
  declarations: [UserComponent],
  imports: [CommonModule],
  exports: [UserComponent]
})
export class UserModule {}

// @Pipe - Defines a pipe
@Pipe({ name: 'custom' })
export class CustomPipe implements PipeTransform {}

// @Directive - Defines a directive
@Directive({ selector: '[appHighlight]' })
export class HighlightDirective {}
```

**Property Decorators:**
```typescript
export class UserComponent {
  // @Input - Receives data from parent
  @Input() user: User;
  
  // @Output - Emits events to parent
  @Output() userSelected = new EventEmitter<User>();
  
  // @ViewChild - Access child component/element
  @ViewChild('userForm') form: ElementRef;
  
  // @HostBinding - Bind to host element property
  @HostBinding('class.active') isActive = false;
  
  // @HostListener - Listen to host element events
  @HostListener('click', ['$event'])
  onClick(event: Event) {}
}
```

**Parameter Decorators:**
```typescript
export class UserService {
  constructor(
    @Inject(API_URL) private apiUrl: string,
    @Optional() private logger: Logger,
    @Self() private userStore: UserStore
  ) {}
}
```

**Custom Decorators:**
```typescript
// Simple property decorator
function Log(target: any, propertyKey: string) {
  console.log(`Property ${propertyKey} decorated`);
}

export class MyClass {
  @Log
  myProperty: string;
}
```

[Back to Core Angular Concepts](#core-angular-concepts)

### 12. Explain the concept of Angular modules and their purpose

**Answer:**
Angular modules (NgModules) are containers that group related components, directives, pipes, and services. They provide compilation context and help organize application functionality.

**Purpose of NgModules:**
- **Organization** - Group related functionality together
- **Encapsulation** - Create boundaries between features
- **Lazy loading** - Enable code splitting and on-demand loading
- **Dependency management** - Control what's available where
- **Compilation context** - Define what Angular compiler should process

**Module Structure:**
```typescript
@NgModule({
  declarations: [    // Components, directives, pipes owned by this module
    UserComponent,
    UserListComponent,
    HighlightDirective,
    TruncatePipe
  ],
  imports: [        // Other modules this module needs
    CommonModule,
    FormsModule,
    HttpClientModule,
    UserRoutingModule
  ],
  exports: [        // Make available to other modules
    UserComponent,
    HighlightDirective
  ],
  providers: [      // Services available to this module
    UserService,
    { provide: API_URL, useValue: 'https://api.example.com' }
  ],
  bootstrap: [      // Root component (only in AppModule)
    AppComponent
  ]
})
export class UserModule {}
```

**Types of Modules:**
- **Root Module (AppModule)** - Bootstraps the application
- **Feature Modules** - Organize related functionality
- **Shared Modules** - Common components/pipes/directives
- **Core Module** - Singleton services, single-use components
- **Lazy-loaded Modules** - Loaded on demand

**Best Practices:**
- Keep modules focused and cohesive
- Use shared modules for common functionality
- Implement lazy loading for large features
- Avoid importing the same module in multiple places
- Consider standalone components (Angular 14+) as an alternative

[Back to Core Angular Concepts](#core-angular-concepts)

### 13. What is the difference between constructor and ngOnInit?

**Answer:**
Both constructor and ngOnInit are used for component initialization, but they serve different purposes and execute at different times.

**Constructor:**
- **TypeScript/JavaScript feature** - Not Angular-specific
- **Dependency injection** - Where services are injected
- **Class initialization** - Set up class properties
- **Executes first** - Before Angular initializes the component
- **No access to inputs** - @Input properties not yet available
- **Synchronous** - Should complete quickly

**ngOnInit:**
- **Angular lifecycle hook** - Part of OnInit interface
- **Component initialization** - After Angular sets up the component
- **Input properties available** - @Input values are set
- **DOM access** - Component's view is initialized
- **Async operations** - API calls, subscriptions

**Example:**
```typescript
export class UserComponent implements OnInit {
  @Input() userId: string;
  user: User;
  
  constructor(
    private userService: UserService,  // DI happens here
    private router: Router
  ) {
    // Class initialization
    console.log('Constructor called');
    console.log(this.userId); // undefined - inputs not set yet
    
    // Set default values
    this.user = null;
  }
  
  ngOnInit() {
    console.log('ngOnInit called');
    console.log(this.userId); // Available - inputs are set
    
    // API calls and subscriptions
    if (this.userId) {
      this.userService.getUser(this.userId).subscribe(user => {
        this.user = user;
      });
    }
    
    // Set up component state based on inputs
    this.initializeComponent();
  }
  
  private initializeComponent() {
    // Component-specific initialization logic
  }
}
```

**Execution Order:**
1. Constructor
2. ngOnChanges (if inputs change)
3. ngOnInit
4. Other lifecycle hooks...

**Best Practices:**
- Use constructor for dependency injection and basic setup
- Use ngOnInit for component initialization and API calls
- Keep constructor lightweight and synchronous
- Put async operations in ngOnInit

[Back to Core Angular Concepts](#core-angular-concepts)

### 14. How does Angular's hierarchical injector work?

**Answer:**
Angular's hierarchical injector system creates a tree of injectors that mirrors the component tree, enabling different scopes for dependency injection.

**Injector Hierarchy (Top to Bottom):**
1. **Platform Injector** - Shared across multiple Angular apps
2. **Application Injector (Root)** - App-wide singletons
3. **Module Injectors** - Lazy-loaded modules
4. **Element Injectors** - Component and directive level

**How Resolution Works:**
- **Bottom-up search** - Starts from requesting component
- **First match wins** - Uses first provider found going up
- **Inheritance** - Child injectors inherit from parents
- **Shadowing** - Child providers override parent providers

```typescript
// Root level service
@Injectable({ providedIn: 'root' })
export class GlobalService {}

// Component level service
@Component({
  selector: 'app-user',
  providers: [UserService] // Creates new instance for this component tree
})
export class UserComponent {
  constructor(
    private globalService: GlobalService, // From root injector
    private userService: UserService      // From component injector
  ) {}
}
```

**Provider Scopes:**

**Root Injector:**
```typescript
// Singleton across entire app
@Injectable({ providedIn: 'root' })
export class AppService {}

// Or in AppModule providers
@NgModule({
  providers: [AppService]
})
export class AppModule {}
```

**Component Injector:**
```typescript
@Component({
  providers: [
    UserService,
    { provide: API_URL, useValue: 'https://api.users.com' }
  ]
})
export class UserComponent {
  // Gets UserService instance specific to this component tree
}
```

**Module Injector:**
```typescript
@NgModule({
  providers: [FeatureService] // Available to all components in this module
})
export class FeatureModule {}
```

**Benefits:**
- **Isolation** - Different parts can have different service instances
- **Flexibility** - Override services at different levels
- **Performance** - Services created only when needed
- **Testing** - Easy to mock services at component level

**Resolution Example:**
```
Component A (UserService provided here)
├── Component B (requests UserService) → Gets from A
├── Component C 
    ├── Component D (UserService provided here)
    └── Component E (requests UserService) → Gets from D
```

[Back to Core Angular Concepts](#core-angular-concepts)

### 15. What are providers and how do they work in Angular?

**Answer:**
Providers tell Angular how to create and provide instances of dependencies. They define the relationship between a token (what you ask for) and the actual implementation (what you get).

**Provider Types:**

**1. Class Provider (Default):**
```typescript
// Shorthand
providers: [UserService]

// Explicit form
providers: [{ provide: UserService, useClass: UserService }]

// Use different implementation
providers: [{ provide: UserService, useClass: MockUserService }]
```

**2. Value Provider:**
```typescript
// Provide a constant value
providers: [
  { provide: API_URL, useValue: 'https://api.example.com' },
  { provide: 'config', useValue: { timeout: 5000 } }
]
```

**3. Factory Provider:**
```typescript
// Create instance using factory function
function userServiceFactory(http: HttpClient, config: AppConfig) {
  return new UserService(http, config.apiUrl);
}

providers: [{
  provide: UserService,
  useFactory: userServiceFactory,
  deps: [HttpClient, AppConfig]
}]
```

**4. Existing Provider (Alias):**
```typescript
// Create alias for existing service
providers: [
  UserService,
  { provide: 'UserServiceAlias', useExisting: UserService }
]
```

**Injection Tokens:**
```typescript
// For non-class dependencies
import { InjectionToken } from '@angular/core';

export const API_URL = new InjectionToken<string>('api.url');
export const APP_CONFIG = new InjectionToken<AppConfig>('app.config');

// Usage
providers: [
  { provide: API_URL, useValue: 'https://api.example.com' },
  { provide: APP_CONFIG, useValue: { timeout: 5000 } }
]

// Injection
constructor(@Inject(API_URL) private apiUrl: string) {}
```

**Multi Providers:**
```typescript
// Collect multiple values into array
export const FEATURE_PLUGINS = new InjectionToken<FeaturePlugin[]>('feature.plugins');

providers: [
  { provide: FEATURE_PLUGINS, useClass: PluginA, multi: true },
  { provide: FEATURE_PLUGINS, useClass: PluginB, multi: true },
  { provide: FEATURE_PLUGINS, useClass: PluginC, multi: true }
]

// Injects array of all plugins
constructor(@Inject(FEATURE_PLUGINS) private plugins: FeaturePlugin[]) {}
```

**Provider Scope:**
- **Root**: `@Injectable({ providedIn: 'root' })`
- **Module**: Listed in module's providers array
- **Component**: Listed in component's providers array

**Best Practices:**
- Use `providedIn: 'root'` for singletons
- Use injection tokens for non-class dependencies
- Use factory providers for complex initialization
- Prefer tree-shakable providers over module providers

[Back to Core Angular Concepts](#core-angular-concepts)

### 16. Explain Angular change detection and when to use `OnPush`

**Answer:**
Angular change detection is the mechanism that synchronizes the application state with the UI by checking for changes in component data and updating the DOM accordingly.

**How Change Detection Works:**
1. **Zone.js patches** async operations (events, timers, promises)
2. **Change detection cycle** runs after async operations
3. **Tree traversal** - Checks all components from root to leaves
4. **Binding checks** - Compares current values with previous values
5. **DOM updates** - Updates only changed elements

**Default Change Detection:**
- Runs on **every async operation**
- Checks **all components** in the tree
- **Performance impact** grows with application size
- Simple but potentially inefficient

**OnPush Change Detection Strategy:**
Only triggers change detection when:
- **Input properties change** (reference change, not mutation)
- **Event is emitted** from component or child components
- **Observable emits** via async pipe
- **Manually triggered** with `markForCheck()`

```typescript
@Component({
  selector: 'app-user-list',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div *ngFor="let user of users; trackBy: trackByFn">
      <app-user-card 
        [user]="user" 
        (userClick)="onUserClick($event)">
      </app-user-card>
    </div>
  `
})
export class UserListComponent {
  @Input() users: User[]; // Must be new reference to trigger update
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  trackByFn(index: number, user: User) {
    return user.id; // Stable identity for performance
  }
  
  onUserClick(user: User) {
    // Event from child triggers change detection
    this.processUser(user);
  }
  
  // Manual trigger when needed
  refreshData() {
    this.loadUsers().subscribe(users => {
      this.users = [...users]; // New reference
      this.cdr.markForCheck(); // Manual trigger
    });
  }
}
```

**When to Use OnPush:**
- **Performance-critical** components
- **Large lists** or complex component trees
- Components with **stable inputs**
- When you can ensure **immutable data patterns**

**Best Practices with OnPush:**
- Use immutable data structures
- Always create new references for arrays/objects
- Implement trackBy functions for *ngFor
- Use async pipe for observables
- Be careful with object mutations

[Back to Change Detection & Performance](#change-detection--performance)

### 17. What is Zone.js and how does zone-less Angular work?

**Answer:**
Zone.js is a library that patches asynchronous operations to provide execution context and automatic change detection triggering in Angular applications.

**What Zone.js Does:**
- **Monkey patches** browser APIs (setTimeout, Promise, addEventListener, etc.)
- **Tracks async operations** and their completion
- **Provides execution context** for async callbacks
- **Automatically triggers** Angular change detection
- **Error handling** across async boundaries

**How Zone.js Works:**
```typescript
// Zone.js patches this:
setTimeout(() => {
  this.data = 'updated'; // Zone detects this and triggers CD
}, 1000);

// Into something like this (conceptually):
setTimeout(Zone.current.wrap(() => {
  this.data = 'updated';
  // Zone triggers Angular change detection here
}), 1000);
```

**Zone-less Angular (Modern Approach):**
Starting with Angular 14, you can opt out of Zone.js for better performance and control.

**Enabling Zone-less:**
```typescript
// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideExperimentalZonelessChangeDetection } from '@angular/core';

bootstrapApplication(AppComponent, {
  providers: [
    provideExperimentalZonelessChangeDetection() // Angular 18+
    // or provideZoneChangeDetection({ eventCoalescing: true }) for zone-based
  ]
});
```

**Zone-less Change Detection Strategies:**

**1. Signals (Recommended):**
```typescript
@Component({
  template: `<div>{{ count() }}</div>`
})
export class CounterComponent {
  count = signal(0);
  
  increment() {
    this.count.update(c => c + 1); // Automatically triggers CD
  }
}
```

**2. Manual Triggering:**
```typescript
export class ManualComponent {
  data: string;
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  updateData() {
    setTimeout(() => {
      this.data = 'updated';
      this.cdr.detectChanges(); // Manual trigger
    }, 1000);
  }
}
```

**3. AsyncPipe with Observables:**
```typescript
@Component({
  template: `<div>{{ data$ | async }}</div>`
})
export class AsyncComponent {
  data$ = this.service.getData(); // AsyncPipe handles CD
}
```

**Benefits of Zone-less:**
- **Better performance** - No monkey patching overhead
- **Smaller bundle size** - No Zone.js dependency
- **More predictable** - Explicit change detection
- **Better debugging** - Clearer execution flow

**Migration Strategy:**
1. Start using signals for new components
2. Use OnPush strategy with manual triggering
3. Leverage async pipe for observables
4. Gradually remove Zone.js dependency

[Back to Change Detection & Performance](#change-detection--performance)

### 18. What are the performance implications of change detection?

**Answer:**
Change detection can significantly impact application performance, especially in large applications with complex component trees.

**Performance Costs:**

**1. Computational Overhead:**
- **Function calls** for every binding check
- **Object property access** for each binding
- **Comparison operations** between old and new values
- **Tree traversal** through all components

**2. Frequency Impact:**
```typescript
// This runs change detection frequently
setInterval(() => {
  this.timestamp = Date.now(); // Every 100ms
}, 100);

// Every mouse move triggers change detection
@HostListener('mousemove', ['$event'])
onMouseMove(event: MouseEvent) {
  this.mousePosition = { x: event.clientX, y: event.clientY };
}
```

**3. Deep Object Checks:**
```typescript
// Expensive - checks every property
get expensiveCalculation() {
  return this.items.reduce((sum, item) => {
    return sum + item.values.reduce((a, b) => a + b, 0);
  }, 0);
}
```

**Performance Bottlenecks:**

**1. Large Lists without TrackBy:**
```typescript
// BAD - Recreates all DOM elements
<div *ngFor="let item of items">
  {{ item.name }}
</div>

// GOOD - Tracks by ID for minimal DOM updates
<div *ngFor="let item of items; trackBy: trackByFn">
  {{ item.name }}
</div>

trackByFn(index: number, item: any) {
  return item.id;
}
```

**2. Expensive Getters in Templates:**
```typescript
// BAD - Runs on every change detection
get filteredItems() {
  return this.items.filter(item => item.active)
                  .sort((a, b) => a.name.localeCompare(b.name));
}

// GOOD - Cached result
private _filteredItems: Item[];
private _lastItemsHash: string;

get filteredItems() {
  const currentHash = JSON.stringify(this.items);
  if (this._lastItemsHash !== currentHash) {
    this._filteredItems = this.items.filter(item => item.active)
                                   .sort((a, b) => a.name.localeCompare(b.name));
    this._lastItemsHash = currentHash;
  }
  return this._filteredItems;
}
```

**3. Impure Pipes:**
```typescript
// BAD - Runs on every CD cycle
@Pipe({ name: 'expensiveFilter', pure: false })
export class ExpensiveFilterPipe implements PipeTransform {
  transform(items: any[], filter: string): any[] {
    // Expensive operation runs constantly
    return items.filter(item => 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }
}
```

**Optimization Strategies:**

**1. OnPush Strategy:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class OptimizedComponent {
  @Input() data: Data[]; // Use immutable updates
}
```

**2. Detach from Change Detection:**
```typescript
export class DetachedComponent implements OnInit {
  constructor(private cdr: ChangeDetectorRef) {
    this.cdr.detach(); // Stop automatic CD
  }
  
  updateData() {
    this.data = newData;
    this.cdr.detectChanges(); // Manual trigger
  }
}
```

**3. Use Observables with AsyncPipe:**
```typescript
@Component({
  template: `<div *ngFor="let item of items$ | async">{{ item.name }}</div>`
})
export class StreamComponent {
  items$ = this.service.getItems(); // AsyncPipe manages subscriptions
}
```

**Measuring Performance:**
- Use Angular DevTools Profiler
- Monitor with `ng.profiler.timeChangeDetection()`
- Analyze with Chrome DevTools Performance tab
- Set performance budgets in angular.json

[Back to Change Detection & Performance](#change-detection--performance)

### 19. How do you optimize Angular application performance?

**Answer:**
Angular performance optimization involves multiple strategies across different layers of the application.

**Change Detection Optimization:**

**1. Use OnPush Strategy:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `...`
})
export class OptimizedComponent {
  @Input() data: Data[];
  
  // Use immutable updates
  updateData(newItem: Data) {
    this.data = [...this.data, newItem]; // New reference
  }
}
```

**2. Implement TrackBy Functions:**
```typescript
@Component({
  template: `
    <div *ngFor="let item of items; trackBy: trackByFn">
      {{ item.name }}
    </div>
  `
})
export class ListComponent {
  trackByFn(index: number, item: Item) {
    return item.id; // Stable unique identifier
  }
}
```

**3. Use Pure Pipes:**
```typescript
@Pipe({ name: 'expensiveTransform', pure: true })
export class ExpensiveTransformPipe implements PipeTransform {
  private cache = new Map();
  
  transform(value: any, ...args: any[]): any {
    const key = JSON.stringify([value, ...args]);
    if (!this.cache.has(key)) {
      this.cache.set(key, this.expensiveOperation(value, ...args));
    }
    return this.cache.get(key);
  }
}
```

**Bundle Optimization:**

**1. Lazy Loading:**
```typescript
const routes: Routes = [
  {
    path: 'feature',
    loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)
  },
  {
    path: 'admin',
    loadComponent: () => import('./admin/admin.component').then(c => c.AdminComponent)
  }
];
```

**2. Tree Shaking:**
```typescript
// Import only what you need
import { map, filter } from 'rxjs/operators';
// Instead of: import * as rxjsOperators from 'rxjs/operators';

// Use barrel exports carefully
// Good: import { UtilityFunction } from './utils/utility';
// Avoid: import { UtilityFunction } from './utils'; // if index.ts exports everything
```

**3. Code Splitting:**
```typescript
// Dynamic imports for large dependencies
async loadChart() {
  const { Chart } = await import('chart.js');
  return new Chart(this.canvasRef.nativeElement, config);
}
```

**Runtime Performance:**

**1. Virtual Scrolling:**
```typescript
@Component({
  template: `
    <cdk-virtual-scroll-viewport itemSize="50" class="viewport">
      <div *cdkVirtualFor="let item of items">{{ item.name }}</div>
    </cdk-virtual-scroll-viewport>
  `
})
export class VirtualScrollComponent {
  items = Array.from({ length: 100000 }, (_, i) => ({ name: `Item ${i}` }));
}
```

**2. Image Optimization:**
```html
<!-- Lazy loading images -->
<img [src]="imageSrc" loading="lazy" alt="description">

<!-- Responsive images -->
<img [srcset]="responsiveImages" sizes="(max-width: 768px) 100vw, 50vw">
```

**3. Service Worker Caching:**
```typescript
// Add PWA support
ng add @angular/pwa

// Custom caching strategies in ngsw-config.json
{
  "index": "/index.html",
  "assetGroups": [
    {
      "name": "app",
      "installMode": "prefetch",
      "resources": {
        "files": ["/favicon.ico", "/index.html", "/*.css", "/*.js"]
      }
    }
  ]
}
```

**Memory Management:**

**1. Proper Subscription Handling:**
```typescript
export class ComponentWithSubscriptions implements OnDestroy {
  private destroy$ = new Subject<void>();
  
  ngOnInit() {
    this.service.getData()
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => this.handleData(data));
  }
  
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}

// Or with takeUntilDestroyed (Angular 16+)
export class ModernComponent {
  data$ = this.service.getData()
    .pipe(takeUntilDestroyed());
}
```

**2. Detach Heavy Components:**
```typescript
export class HeavyAnimationComponent {
  constructor(private ngZone: NgZone) {}
  
  startAnimation() {
    this.ngZone.runOutsideAngular(() => {
      // Heavy animation code that doesn't need change detection
      this.animateChart();
    });
  }
}
```

**Build Optimization:**

**1. Production Build:**
```bash
ng build --configuration=production
# Enables: AOT, minification, tree-shaking, dead code elimination
```

**2. Bundle Analysis:**
```bash
ng build --stats-json
npx webpack-bundle-analyzer dist/stats.json
```

**3. Performance Budgets:**
```json
// angular.json
"budgets": [
  {
    "type": "initial",
    "maximumWarning": "2mb",
    "maximumError": "5mb"
  },
  {
    "type": "anyComponentStyle",
    "maximumWarning": "6kb"
  }
]
```

[Back to Change Detection & Performance](#change-detection--performance)



### 20. How do you implement virtual scrolling?

**Answer:**
Virtual scrolling renders only the visible items in a large list, dramatically improving performance by avoiding DOM overhead for thousands of items.

**CDK Virtual Scrolling Setup:**

**1. Install Angular CDK:**
```bash
ng add @angular/cdk
```

**2. Import ScrollingModule:**
```typescript
import { ScrollingModule } from '@angular/cdk/scrolling';

@NgModule({
  imports: [ScrollingModule],
  // ...
})
export class FeatureModule {}
```

**Basic Implementation:**
```typescript
@Component({
  selector: 'app-virtual-list',
  template: `
    <cdk-virtual-scroll-viewport 
      itemSize="50" 
      class="viewport"
      [maxBufferPx]="200"
      [minBufferPx]="100">
      
      <div *cdkVirtualFor="let item of items; let i = index" 
           class="list-item">
        <div class="item-content">
          <h4>{{ item.name }}</h4>
          <p>{{ item.description }}</p>
          <small>Index: {{ i }}</small>
        </div>
      </div>
      
    </cdk-virtual-scroll-viewport>
  `,
  styles: [`
    .viewport {
      height: 400px;
      width: 100%;
      border: 1px solid #ccc;
    }
    
    .list-item {
      height: 50px;
      display: flex;
      align-items: center;
      padding: 0 16px;
      border-bottom: 1px solid #eee;
    }
    
    .item-content {
      flex: 1;
    }
  `]
})
export class VirtualListComponent {
  items = Array.from({ length: 100000 }, (_, i) => ({
    id: i,
    name: `Item ${i}`,
    description: `Description for item ${i}`
  }));
}
```

**Advanced Configuration:**

**1. Dynamic Item Sizes:**
```typescript
@Component({
  template: `
    <cdk-virtual-scroll-viewport 
      class="viewport"
      [itemSize]="getItemSize"
      [maxBufferPx]="600"
      [minBufferPx]="300">
      
      <div *cdkVirtualFor="let item of items" 
           [style.height.px]="getItemHeight(item)"
           class="dynamic-item">
        <h3>{{ item.title }}</h3>
        <p *ngIf="item.description">{{ item.description }}</p>
        <div *ngIf="item.content" class="content">
          {{ item.content }}
        </div>
      </div>
      
    </cdk-virtual-scroll-viewport>
  `
})
export class DynamicVirtualListComponent {
  items: ListItem[] = [];
  
  getItemSize = (index: number): number => {
    const item = this.items[index];
    return this.getItemHeight(item);
  }
  
  getItemHeight(item: ListItem): number {
    let height = 60; // Base height
    if (item.description) height += 20;
    if (item.content) height += 40;
    return height;
  }
}
```

**2. Horizontal Virtual Scrolling:**
```typescript
@Component({
  template: `
    <cdk-virtual-scroll-viewport 
      orientation="horizontal"
      itemSize="200"
      class="horizontal-viewport">
      
      <div *cdkVirtualFor="let item of items" 
           class="horizontal-item">
        <div class="card">
          <img [src]="item.imageUrl" [alt]="item.name">
          <h4>{{ item.name }}</h4>
        </div>
      </div>
      
    </cdk-virtual-scroll-viewport>
  `,
  styles: [`
    .horizontal-viewport {
      height: 300px;
      width: 100%;
      white-space: nowrap;
    }
    
    .horizontal-item {
      display: inline-block;
      width: 200px;
      height: 280px;
      margin-right: 16px;
    }
    
    .card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 16px;
      height: 100%;
    }
  `]
})
export class HorizontalVirtualListComponent {
  items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    name: `Card ${i}`,
    imageUrl: `https://picsum.photos/150/150?random=${i}`
  }));
}
```

**3. Virtual Scrolling with Data Loading:**
```typescript
@Component({
  template: `
    <cdk-virtual-scroll-viewport 
      itemSize="60"
      class="viewport"
      (scrolledIndexChange)="onScrollIndexChange($event)">
      
      <div *cdkVirtualFor="let item of items$ | async; let i = index" 
           class="list-item">
        <div *ngIf="item; else loading">
          {{ item.name }} - {{ item.email }}
        </div>
        <ng-template #loading>
          <div class="loading">Loading...</div>
        </ng-template>
      </div>
      
    </cdk-virtual-scroll-viewport>
  `
})
export class DataLoadingVirtualListComponent implements OnInit {
  items$ = new BehaviorSubject<User[]>([]);
  private currentPage = 0;
  private pageSize = 50;
  
  constructor(private userService: UserService) {}
  
  ngOnInit() {
    this.loadNextPage();
  }
  
  onScrollIndexChange(index: number) {
    const currentItems = this.items$.value;
    // Load more data when approaching the end
    if (index >= currentItems.length - 10) {
      this.loadNextPage();
    }
  }
  
  private loadNextPage() {
    this.userService.getUsers(this.currentPage, this.pageSize)
      .subscribe(newUsers => {
        const currentItems = this.items$.value;
        this.items$.next([...currentItems, ...newUsers]);
        this.currentPage++;
      });
  }
}
```

**Performance Considerations:**

**1. Buffer Configuration:**
- `minBufferPx`: Minimum rendered content outside viewport
- `maxBufferPx`: Maximum rendered content outside viewport
- Balance between smooth scrolling and memory usage

**2. Item Size Optimization:**
- Use fixed sizes when possible for best performance
- Dynamic sizing requires more calculations
- Consider average size for mixed content

**3. TrackBy Functions:**
```typescript
@Component({
  template: `
    <div *cdkVirtualFor="let item of items; trackBy: trackByFn">
      {{ item.name }}
    </div>
  `
})
export class OptimizedVirtualListComponent {
  trackByFn(index: number, item: any) {
    return item.id; // Stable unique identifier
  }
}
```

**Common Use Cases:**
- Large data tables
- Infinite scroll lists
- Image galleries
- Chat message lists
- Search results with thousands of items

**Benefits:**
- Constant DOM size regardless of data size
- Smooth scrolling performance
- Reduced memory usage
- Better mobile performance

[Back to Change Detection & Performance](#change-detection--performance)

### 21. What are the benefits of using trackBy functions in ngFor?

**Answer:**
TrackBy functions optimize *ngFor performance by providing Angular with a stable identity for each item, enabling efficient DOM updates and preventing unnecessary re-rendering.

**How ngFor Works Without TrackBy:**
Angular uses array index as the default tracking mechanism:

```typescript
// Without trackBy - Angular tracks by index
@Component({
  template: `
    <div *ngFor="let user of users">
      {{ user.name }} - {{ user.email }}
    </div>
  `
})
export class WithoutTrackByComponent {
  users = [
    { id: 1, name: 'John', email: 'john@example.com' },
    { id: 2, name: 'Jane', email: 'jane@example.com' }
  ];
  
  addUser() {
    // This causes ALL DOM elements to be recreated
    this.users = [{ id: 3, name: 'Bob', email: 'bob@example.com' }, ...this.users];
  }
}
```

**Problems Without TrackBy:**
1. **DOM Recreation** - All elements destroyed and recreated
2. **Lost Component State** - Child component state is lost
3. **Animation Issues** - Animations restart unexpectedly
4. **Performance Impact** - Unnecessary DOM manipulation
5. **Focus Loss** - Input focus is lost during updates

**Implementing TrackBy:**

```typescript
@Component({
  template: `
    <div *ngFor="let user of users; trackBy: trackByUserId">
      <input [(ngModel)]="user.name" placeholder="Name">
      <span>{{ user.email }}</span>
      <button (click)="removeUser(user.id)">Remove</button>
    </div>
  `
})
export class WithTrackByComponent {
  users: User[] = [
    { id: 1, name: 'John', email: 'john@example.com' },
    { id: 2, name: 'Jane', email: 'jane@example.com' },
    { id: 3, name: 'Bob', email: 'bob@example.com' }
  ];
  
  // TrackBy function - returns unique identifier
  trackByUserId(index: number, user: User): number {
    return user.id; // Use stable, unique property
  }
  
  addUser() {
    const newUser = { id: Date.now(), name: '', email: '' };
    this.users = [newUser, ...this.users]; // Only new element is created
  }
  
  removeUser(userId: number) {
    this.users = this.users.filter(user => user.id !== userId);
    // Only removed element is destroyed, others remain
  }
  
  updateUser(userId: number, updates: Partial<User>) {
    this.users = this.users.map(user => 
      user.id === userId ? { ...user, ...updates } : user
    );
    // Existing DOM elements are reused, only content updates
  }
}
```

**TrackBy Function Patterns:**

**1. Simple ID Tracking:**
```typescript
trackByUserId(index: number, user: User): number {
  return user.id;
}
```

**2. Composite Key Tracking:**
```typescript
trackByComposite(index: number, item: OrderItem): string {
  return `${item.orderId}-${item.productId}`;
}
```

**3. Index Fallback:**
```typescript
trackByIdOrIndex(index: number, item: any): any {
  return item.id || index;
}
```

**4. Complex Object Tracking:**
```typescript
trackByComplexKey(index: number, item: ComplexItem): string {
  return `${item.category}-${item.subcategory}-${item.id}`;
}
```

**Benefits Demonstration:**

```typescript
@Component({
  template: `
    <h3>Without TrackBy (recreates all)</h3>
    <div *ngFor="let item of items1">
      <expensive-component [data]="item"></expensive-component>
    </div>
    
    <h3>With TrackBy (reuses existing)</h3>
    <div *ngFor="let item of items2; trackBy: trackByFn">
      <expensive-component [data]="item"></expensive-component>
    </div>
    
    <button (click)="addItemToStart()">Add Item to Start</button>
  `
})
export class TrackByDemoComponent {
  items1 = this.generateItems(100);
  items2 = this.generateItems(100);
  
  trackByFn(index: number, item: any) {
    return item.id;
  }
  
  addItemToStart() {
    const newItem = { id: Date.now(), value: Math.random() };
    
    // Without trackBy: All 100 components destroyed and recreated + 1 new
    this.items1 = [newItem, ...this.items1];
    
    // With trackBy: Only 1 new component created, 100 existing reused
    this.items2 = [newItem, ...this.items2];
  }
}
```

**Performance Impact:**

**Measuring Performance:**
```typescript
@Component({
  template: `
    <button (click)="measurePerformance()">Measure Performance</button>
    <div *ngFor="let item of items; trackBy: trackByFn">
      {{ item.name }}
    </div>
  `
})
export class PerformanceMeasureComponent {
  items: Item[] = [];
  
  trackByFn(index: number, item: Item) {
    return item.id;
  }
  
  measurePerformance() {
    console.time('List Update');
    
    // Simulate data update
    this.items = this.shuffleArray([...this.items]);
    
    // Use setTimeout to measure after DOM updates
    setTimeout(() => {
      console.timeEnd('List Update');
    });
  }
}
```

**Best Practices:**

1. **Always use trackBy** for dynamic lists
2. **Use stable, unique identifiers** (avoid computed values)
3. **Keep trackBy functions simple** and fast
4. **Consider composite keys** for complex scenarios
5. **Test with large datasets** to measure impact

**Common Mistakes:**

```typescript
// BAD - Using computed values
trackByBad(index: number, item: User) {
  return `${item.firstName}-${item.lastName}`; // Changes if name changes
}

// BAD - Using objects as keys
trackByBad2(index: number, item: User) {
  return item; // Objects are compared by reference
}

// GOOD - Using stable ID
trackByGood(index: number, item: User) {
  return item.id; // Stable unique identifier
}
```

**Real-world Impact:**
- **Large lists**: 10x+ performance improvement
- **Form preservation**: Input values maintained during updates
- **Animation continuity**: Smooth transitions
- **Memory efficiency**: Reduced DOM churn

[Back to Change Detection & Performance](#change-detection--performance)

### 22. How do you implement code splitting in Angular?

**Answer:**
Code splitting divides your application into smaller chunks that are loaded on-demand, reducing initial bundle size and improving startup performance.

**Types of Code Splitting:**

**1. Route-based Code Splitting (Lazy Loading):**
```typescript
// app-routing.module.ts
const routes: Routes = [
  {
    path: 'dashboard',
    loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule)
  },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    canLoad: [AdminGuard] // Only load if user has access
  },
  // Standalone component lazy loading (Angular 14+)
  {
    path: 'profile',
    loadComponent: () => import('./profile/profile.component').then(c => c.ProfileComponent)
  }
];
```

**2. Dynamic Imports for Libraries:**
```typescript
@Component({
  template: `
    <div #chartContainer></div>
    <button (click)="loadChart()">Load Chart</button>
  `
})
export class ChartComponent {
  @ViewChild('chartContainer', { static: true }) chartContainer!: ElementRef;
  
  async loadChart() {
    // Dynamically import large chart library
    const { Chart, registerables } = await import('chart.js');
    Chart.register(...registerables);
    
    new Chart(this.chartContainer.nativeElement, {
      type: 'bar',
      data: {
        labels: ['Jan', 'Feb', 'Mar'],
        datasets: [{
          label: 'Sales',
          data: [12, 19, 3]
        }]
      }
    });
  }
  
  async loadEditor() {
    // Lazy load Monaco Editor
    const monaco = await import('monaco-editor');
    const editor = monaco.editor.create(this.editorContainer.nativeElement, {
      value: 'console.log("Hello World!");',
      language: 'javascript'
    });
  }
}
```

**3. Component-level Code Splitting:**
```typescript
@Component({
  template: `
    <div *ngIf="showAdvancedFeatures">
      <ng-container *ngComponentOutlet="advancedComponent"></ng-container>
    </div>
    <button (click)="loadAdvancedFeatures()">Load Advanced Features</button>
  `
})
export class MainComponent {
  showAdvancedFeatures = false;
  advancedComponent: any = null;
  
  async loadAdvancedFeatures() {
    if (!this.advancedComponent) {
      const { AdvancedComponent } = await import('./advanced/advanced.component');
      this.advancedComponent = AdvancedComponent;
    }
    this.showAdvancedFeatures = true;
  }
}
```

**4. Service-level Code Splitting:**
```typescript
@Injectable({
  providedIn: 'root'
})
export class DataService {
  private heavyProcessor: any;
  
  async processLargeDataset(data: any[]) {
    if (!this.heavyProcessor) {
      // Load heavy processing library only when needed
      const { HeavyProcessor } = await import('./heavy-processor');
      this.heavyProcessor = new HeavyProcessor();
    }
    
    return this.heavyProcessor.process(data);
  }
  
  async exportToPDF(data: any) {
    // Load PDF library only when export is needed
    const { jsPDF } = await import('jspdf');
    const doc = new jsPDF();
    doc.text(JSON.stringify(data), 10, 10);
    doc.save('export.pdf');
  }
}
```

**Advanced Code Splitting Strategies:**

**1. Preloading Strategies:**
```typescript
// Custom preloading strategy
@Injectable()
export class CustomPreloadingStrategy implements PreloadingStrategy {
  preload(route: Route, load: () => Observable<any>): Observable<any> {
    // Preload based on route data
    if (route.data?.['preload']) {
      return load();
    }
    
    // Preload based on user behavior
    if (this.shouldPreload(route)) {
      return load();
    }
    
    return of(null);
  }
  
  private shouldPreload(route: Route): boolean {
    // Custom logic: preload if user frequently visits
    return this.analytics.isFrequentlyVisited(route.path);
  }
}

// Apply preloading strategy
@NgModule({
  imports: [RouterModule.forRoot(routes, {
    preloadingStrategy: CustomPreloadingStrategy
  })],
  providers: [CustomPreloadingStrategy]
})
export class AppRoutingModule {}
```

**2. Network-aware Loading:**
```typescript
@Injectable()
export class NetworkAwareLoader {
  constructor(@Inject(NAVIGATOR) private navigator: Navigator) {}
  
  async loadFeature(importFn: () => Promise<any>) {
    // Check network conditions
    if ('connection' in this.navigator) {
      const connection = (this.navigator as any).connection;
      
      // Don't load heavy features on slow connections
      if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
        console.warn('Slow network detected, skipping heavy feature load');
        return null;
      }
    }
    
    return await importFn();
  }
}
```

**3. User Role-based Code Splitting:**
```typescript
const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => {
      // Only load admin module for admin users
      if (this.authService.isAdmin()) {
        return import('./admin/admin.module').then(m => m.AdminModule);
      } else {
        return import('./unauthorized/unauthorized.module').then(m => m.UnauthorizedModule);
      }
    }
  }
];
```

**Build Configuration for Code Splitting:**

**1. Webpack Bundle Analysis:**
```bash
# Generate stats file
ng build --stats-json

# Analyze bundle
npx webpack-bundle-analyzer dist/stats.json
```

**2. Custom Webpack Configuration:**
```typescript
// webpack.config.js (if using custom webpack)
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        },
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          enforce: true
        }
      }
    }
  }
};
```

**3. Angular CLI Configuration:**
```json
// angular.json
{
  "projects": {
    "my-app": {
      "architect": {
        "build": {
          "options": {
            "budgets": [
              {
                "type": "initial",
                "maximumWarning": "2mb",
                "maximumError": "5mb"
              },
              {
                "type": "anyComponentStyle",
                "maximumWarning": "6kb"
              }
            ]
          }
        }
      }
    }
  }
}
```

**Best Practices:**

1. **Route-level splitting** for major features
2. **Library-level splitting** for heavy dependencies
3. **Component-level splitting** for optional features
4. **Monitor bundle sizes** with budgets
5. **Use preloading strategies** for better UX
6. **Consider network conditions** for loading decisions
7. **Implement loading states** for better user experience

**Performance Benefits:**
- Faster initial page load
- Reduced memory usage
- Better caching strategies
- Improved Core Web Vitals scores
- Better mobile performance

[Back to Change Detection & Performance](#change-detection--performance)

### 23. What are lazy loading strategies and preloading?

**Answer:**
Lazy loading strategies determine when and how to load modules on-demand, while preloading strategies define how to load modules in the background to improve user experience.

**Lazy Loading Strategies:**

**1. Basic Lazy Loading:**
```typescript
const routes: Routes = [
  {
    path: 'feature',
    loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)
  }
];
```

**2. Preloading Strategies:**
```typescript
// app-routing.module.ts
RouterModule.forRoot(routes, {
  preloadingStrategy: PreloadAllModules, // Built-in strategy
  // preloadingStrategy: NoPreloading,   // Default - no preloading
  // preloadingStrategy: CustomPreloadingStrategy // Custom strategy
})
```

**Custom Preloading Strategy:**
```typescript
@Injectable()
export class CustomPreloadingStrategy implements PreloadingStrategy {
  preload(route: Route, load: () => Observable<any>): Observable<any> {
    // Only preload routes with specific data
    if (route.data && route.data['preload']) {
      console.log('Preloading: ' + route.path);
      return load();
    } else {
      return of(null);
    }
  }
}

// Usage in routes
const routes: Routes = [
  {
    path: 'important',
    loadChildren: () => import('./important/important.module').then(m => m.ImportantModule),
    data: { preload: true } // This will be preloaded
  },
  {
    path: 'optional',
    loadChildren: () => import('./optional/optional.module').then(m => m.OptionalModule)
    // This won't be preloaded
  }
];
```

**Benefits:**
- **Reduced initial bundle size**
- **Improved startup performance**
- **Better user experience with preloading**
- **Conditional loading based on user roles**

[Back to Change Detection & Performance](#change-detection--performance)

### 24. What is tree shaking and how does it work?

**Answer:**
Tree shaking is a dead code elimination technique that removes unused code from your final bundle, reducing bundle size and improving performance.

**How Tree Shaking Works:**

1. **Static Analysis** - Webpack analyzes ES6 module imports/exports
2. **Dependency Graph** - Builds a graph of used vs unused code
3. **Dead Code Elimination** - Removes unreferenced exports
4. **Minification** - Further optimizes the remaining code

**Tree Shaking Requirements:**

**1. ES6 Modules (ESM):**
```typescript
// ✅ Tree-shakable - ES6 imports/exports
import { SpecificFunction } from './utils';
export { UsedFunction } from './helpers';

// ❌ Not tree-shakable - CommonJS
const utils = require('./utils');
module.exports = { ... };
```

**2. Side-effect Free Code:**
```typescript
// ✅ Pure functions - tree-shakable
export function add(a: number, b: number): number {
  return a + b;
}

export function multiply(a: number, b: number): number {
  return a * b;
}

// ❌ Side effects - not tree-shakable
export function setupGlobalListener() {
  window.addEventListener('resize', () => {
    console.log('Window resized');
  });
}
```

**Optimizing for Tree Shaking:**

**1. Named Imports (Recommended):**
```typescript
// ✅ Tree-shakable - only imports what's needed
import { map, filter, reduce } from 'rxjs/operators';
import { Component, OnInit } from '@angular/core';

// ❌ Imports entire library
import * as rxjsOperators from 'rxjs/operators';
import * as angularCore from '@angular/core';
```

**2. Avoid Barrel Exports (When Problematic):**
```typescript
// utils/index.ts - Barrel export
export * from './math';
export * from './string';
export * from './date';
export * from './heavy-feature'; // This gets included even if unused

// Better approach - Direct imports
import { addNumbers } from './utils/math';
import { formatString } from './utils/string';
// heavy-feature is not imported, so it's tree-shaken
```

**3. Library-specific Optimizations:**

**Lodash:**
```typescript
// ❌ Imports entire lodash library
import _ from 'lodash';
_.map(items, item => item.name);

// ✅ Tree-shakable approach
import { map } from 'lodash';
// or
import map from 'lodash/map';
map(items, item => item.name);
```

**RxJS:**
```typescript
// ❌ Imports all operators
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/filter';

// ✅ Tree-shakable (RxJS 6+)
import { map, filter } from 'rxjs/operators';
this.data$.pipe(
  map(data => data.items),
  filter(items => items.length > 0)
);
```

**Angular Material:**
```typescript
// ❌ Imports entire Material library
import * as Material from '@angular/material';

// ✅ Import only needed components
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
```

**Package.json Side Effects:**

```json
{
  "name": "my-library",
  "sideEffects": false,
  "main": "index.js",
  "module": "index.esm.js"
}

// Or specify files with side effects
{
  "sideEffects": [
    "./src/polyfills.ts",
    "*.css",
    "*.scss"
  ]
}
```

**Webpack Configuration:**

```javascript
// webpack.config.js
module.exports = {
  mode: 'production', // Enables tree shaking
  optimization: {
    usedExports: true, // Mark unused exports
    sideEffects: false, // Assume no side effects
    minimize: true // Remove dead code
  }
};
```

**Angular CLI and Tree Shaking:**

Angular CLI automatically enables tree shaking in production builds:

```bash
# Production build with tree shaking
ng build --configuration=production

# Analyze bundle to see tree shaking results
ng build --stats-json
npx webpack-bundle-analyzer dist/stats.json
```

**Common Tree Shaking Issues:**

**1. Side Effects in Modules:**
```typescript
// ❌ This prevents tree shaking
console.log('Module loaded'); // Side effect

export function utilityFunction() {
  return 'result';
}

// ✅ Pure module
export function utilityFunction() {
  return 'result';
}
```

**2. Default Exports:**
```typescript
// ❌ Less tree-shakable
export default {
  function1,
  function2,
  function3
};

// ✅ More tree-shakable
export { function1, function2, function3 };
```

**3. Dynamic Imports:**
```typescript
// ❌ Can't be statically analyzed
const moduleName = 'lodash';
import(moduleName).then(module => {
  // Tree shaking can't determine what's used
});

// ✅ Static import path
import('./specific-module').then(module => {
  // Can be tree-shaken
});
```

**Measuring Tree Shaking Effectiveness:**

**1. Bundle Analysis:**
```typescript
// Before optimization
import * as _ from 'lodash'; // ~70KB

// After optimization
import { map, filter } from 'lodash'; // ~5KB
```

**2. Build Size Comparison:**
```bash
# Check bundle sizes
ng build --stats-json

# Compare before/after
echo "Before: $(du -h dist/main.js)"
echo "After: $(du -h dist/main.js)"
```

**Best Practices:**

1. **Use ES6 modules** consistently
2. **Import only what you need** with named imports
3. **Avoid side effects** in modules
4. **Configure sideEffects** in package.json
5. **Use production builds** for tree shaking
6. **Analyze bundles regularly** to verify effectiveness
7. **Choose tree-shake friendly libraries**
8. **Avoid dynamic imports** where possible

**Tree Shaking Results:**
- 20-50% bundle size reduction typical
- Faster loading times
- Better performance on mobile
- Reduced memory usage
- Improved Core Web Vitals scores

[Back to Change Detection & Performance](#change-detection--performance)

### 25. How do you optimize bundle size?

**Answer:**
Bundle size optimization is crucial for improving application loading performance, especially on mobile devices and slow networks.

**Analysis and Measurement:**

**1. Bundle Analysis:**
```bash
# Generate bundle analysis
ng build --stats-json
npx webpack-bundle-analyzer dist/your-app/stats.json

# Or use Angular CLI bundle analyzer
ng build --source-map
npx source-map-explorer dist/your-app/*.js
```

**2. Performance Budgets:**
```json
// angular.json
{
  "budgets": [
    {
      "type": "initial",
      "maximumWarning": "500kb",
      "maximumError": "1mb"
    },
    {
      "type": "anyComponentStyle",
      "maximumWarning": "2kb",
      "maximumError": "4kb"
    }
  ]
}
```

**Optimization Strategies:**

**1. Tree Shaking:**
```typescript
// Use ES6 imports for tree shaking
import { debounceTime } from 'rxjs/operators'; // ✅ Tree-shakable
import * as rxjs from 'rxjs'; // ❌ Imports entire library

// Mark unused exports for elimination
export { UsedFunction } from './utils';
// Don't export unused functions
```

**2. Lazy Loading:**
```typescript
// Route-based code splitting
const routes: Routes = [
  {
    path: 'feature',
    loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)
  },
  // Standalone component lazy loading
  {
    path: 'profile',
    loadComponent: () => import('./profile/profile.component').then(c => c.ProfileComponent)
  }
];
```

**3. Dynamic Imports:**
```typescript
// Load heavy libraries on demand
async loadChart() {
  const { Chart } = await import('chart.js');
  // Use Chart only when needed
}

// Conditional feature loading
async loadAdvancedFeatures() {
  if (this.user.isPremium) {
    const { AdvancedModule } = await import('./advanced/advanced.module');
    return AdvancedModule;
  }
}
```

**4. Optimize Dependencies:**
```typescript
// Use lighter alternatives
import { format } from 'date-fns/format'; // Instead of moment.js
import { debounce } from 'lodash-es/debounce'; // Instead of full lodash

// Remove unused dependencies
npm uninstall unused-package
npm audit fix
```

**5. Production Build Optimizations:**
```bash
# Production build with all optimizations
ng build --prod

# Manual optimization flags
ng build --optimization=true \
         --aot=true \
         --build-optimizer=true \
         --common-chunk=true \
         --vendor-chunk=true \
         --source-map=false
```

**6. Preloading Strategies:**
```typescript
@Injectable()
export class CustomPreloadingStrategy implements PreloadingStrategy {
  preload(route: Route, load: () => Observable<any>): Observable<any> {
    // Preload only critical routes
    if (route.data && route.data['preload']) {
      return load();
    }
    return of(null);
  }
}
```

**7. Image and Asset Optimization:**
```typescript
// Lazy load images
<img loading="lazy" src="image.jpg" alt="Description">

// Use WebP format with fallback
<picture>
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="Description">
</picture>

// Optimize with Angular CLI
ng add @angular/pwa // Adds service worker for caching
```

**8. Service Worker and Caching:**
```typescript
// Enable service worker
ng add @angular/pwa

// Custom caching strategy
import { SwUpdate } from '@angular/service-worker';

constructor(private swUpdate: SwUpdate) {
  if (swUpdate.isEnabled) {
    swUpdate.available.subscribe(() => {
      if (confirm('New version available. Load?')) {
        window.location.reload();
      }
    });
  }
}
```

**9. Remove Development Code:**
```typescript
// Use environment variables
if (!environment.production) {
  // Development-only code
  console.log('Debug info');
}

// Tree-shakable logging
import { isDevMode } from '@angular/core';
if (isDevMode()) {
  console.log('Development mode');
}
```

**10. Optimize CSS:**
```scss
// Use CSS custom properties instead of SCSS variables
:root {
  --primary-color: #007bff;
}

// Avoid deep nesting
.component {
  &__element { } // Max 2 levels deep
}

// Use PurgeCSS for unused CSS removal
```

**Bundle Size Targets:**
- **Initial bundle**: < 130KB (gzipped)
- **Total bundles**: < 500KB (gzipped)
- **Individual chunks**: < 50KB (gzipped)
- **Third-party libraries**: < 200KB (gzipped)

**Monitoring:**
```typescript
// Performance monitoring
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

getCLS(console.log);
getFID(console.log);
getFCP(console.log);
getLCP(console.log);
getTTFB(console.log);
```

[Back to Change Detection & Performance](#change-detection--performance)

### 26. What are immutable patterns with `OnPush`?

**Answer:**
Immutable patterns with OnPush change detection strategy ensure predictable and efficient updates by creating new object references instead of mutating existing ones.

**Why Immutability with OnPush:**

OnPush only triggers change detection when:
- Input reference changes (not mutations)
- Events are emitted
- Observables emit via async pipe
- Manual trigger with `markForCheck()`

**Core Immutable Patterns:**

**1. Array Updates:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div *ngFor="let item of items; trackBy: trackByFn">
      {{ item.name }}
    </div>
  `
})
export class ImmutableListComponent {
  @Input() items: Item[] = [];
  
  // ✅ CORRECT - Creates new array reference
  addItem(item: Item) {
    this.items = [...this.items, item];
  }
  
  // ✅ CORRECT - Filter creates new array
  removeItem(id: number) {
    this.items = this.items.filter(item => item.id !== id);
  }
  
  // ✅ CORRECT - Map creates new array with new objects
  updateItem(id: number, updates: Partial<Item>) {
    this.items = this.items.map(item => 
      item.id === id ? { ...item, ...updates } : item
    );
  }
  
  // ❌ WRONG - Mutates existing array
  addItemMutation(item: Item) {
    this.items.push(item); // OnPush won't detect this
  }
  
  trackByFn(index: number, item: Item) {
    return item.id;
  }
}
```

**2. Object Updates:**
```typescript
interface UserState {
  user: User;
  preferences: UserPreferences;
  notifications: Notification[];
}

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class UserProfileComponent {
  @Input() state: UserState;
  
  // ✅ CORRECT - Creates new state object
  updateUser(updates: Partial<User>) {
    this.state = {
      ...this.state,
      user: { ...this.state.user, ...updates }
    };
  }
  
  // ✅ CORRECT - Nested immutable update
  updatePreference(key: string, value: any) {
    this.state = {
      ...this.state,
      preferences: {
        ...this.state.preferences,
        [key]: value
      }
    };
  }
  
  // ❌ WRONG - Mutates existing object
  updateUserMutation(updates: Partial<User>) {
    Object.assign(this.state.user, updates); // OnPush won't detect
  }
}
```

**3. Nested Object Updates:**
```typescript
interface AppState {
  ui: {
    theme: string;
    sidebar: { collapsed: boolean; width: number };
  };
  data: {
    users: User[];
    settings: Settings;
  };
}

// ✅ CORRECT - Deep immutable update
updateSidebarWidth(newWidth: number): AppState {
  return {
    ...this.state,
    ui: {
      ...this.state.ui,
      sidebar: {
        ...this.state.ui.sidebar,
        width: newWidth
      }
    }
  };
}

// Using Immer for complex updates
import { produce } from 'immer';

updateWithImmer(newWidth: number): AppState {
  return produce(this.state, draft => {
    draft.ui.sidebar.width = newWidth;
  });
}
```

**4. Working with Forms:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <form [formGroup]="form" (ngSubmit)="onSubmit()">
      <input formControlName="name">
      <input formControlName="email">
    </form>
  `
})
export class ImmutableFormComponent {
  @Input() initialData: User;
  form: FormGroup;
  
  ngOnChanges(changes: SimpleChanges) {
    if (changes['initialData'] && this.initialData) {
      // ✅ CORRECT - Create new form with new data
      this.form = this.fb.group({
        name: [this.initialData.name],
        email: [this.initialData.email]
      });
    }
  }
  
  // ✅ CORRECT - Emit new object
  onSubmit() {
    const formValue = this.form.value;
    const updatedUser: User = {
      ...this.initialData,
      ...formValue
    };
    this.userUpdate.emit(updatedUser);
  }
}
```

**5. State Management Patterns:**
```typescript
// Redux-style reducer pattern
interface TodoState {
  todos: Todo[];
  filter: FilterType;
  loading: boolean;
}

class TodoStateManager {
  private state: TodoState = {
    todos: [],
    filter: 'ALL',
    loading: false
  };
  
  // ✅ CORRECT - Pure functions returning new state
  addTodo(todo: Todo): TodoState {
    return {
      ...this.state,
      todos: [...this.state.todos, todo]
    };
  }
  
  toggleTodo(id: number): TodoState {
    return {
      ...this.state,
      todos: this.state.todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    };
  }
  
  setFilter(filter: FilterType): TodoState {
    return {
      ...this.state,
      filter
    };
  }
}
```

**6. Using Immutable Libraries:**
```typescript
import { Map, List } from 'immutable';

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ImmutableJSComponent {
  @Input() items: List<Item>;
  @Input() settings: Map<string, any>;
  
  addItem(item: Item) {
    // Immutable.js creates new instances
    this.items = this.items.push(item);
  }
  
  updateSetting(key: string, value: any) {
    this.settings = this.settings.set(key, value);
  }
}
```

**7. Performance Optimizations:**
```typescript
// Memoization for expensive computations
import { memoize } from 'lodash-es';

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class OptimizedComponent {
  @Input() data: ComplexData[];
  
  // ✅ Memoized getter
  private _memoizedFilter = memoize((data: ComplexData[], filter: string) => {
    return data.filter(item => item.category === filter)
               .sort((a, b) => a.priority - b.priority);
  });
  
  get filteredData() {
    return this._memoizedFilter(this.data, this.currentFilter);
  }
}
```

**8. Common Pitfalls and Solutions:**
```typescript
// ❌ WRONG - Array methods that mutate
this.items.push(newItem);        // Use [...items, newItem]
this.items.splice(index, 1);     // Use items.filter((_, i) => i !== index)
this.items.sort();               // Use [...items].sort()
this.items.reverse();            // Use [...items].reverse()

// ❌ WRONG - Object mutations
this.user.name = 'New Name';     // Use {...user, name: 'New Name'}
delete this.user.email;          // Use omit(user, 'email') or destructuring

// ✅ CORRECT - Safe mutations
const { email, ...userWithoutEmail } = this.user;
this.user = userWithoutEmail;
```

**Best Practices:**
1. **Always create new references** for OnPush components
2. **Use spread operator** for shallow copies
3. **Use libraries like Immer** for deep updates
4. **Implement trackBy functions** for arrays
5. **Use memoization** for expensive computations
6. **Test immutability** with Object.freeze() in development
7. **Use TypeScript readonly** modifiers for compile-time safety

```typescript
// Type safety with readonly
interface ReadonlyUser {
  readonly id: number;
  readonly name: string;
  readonly preferences: readonly UserPreference[];
}
```

[Back to Change Detection & Performance](#change-detection--performance)

### 27. Explain `markForCheck` vs `detectChanges`

**Answer:**
Both `markForCheck()` and `detectChanges()` are methods of `ChangeDetectorRef` used to manually control change detection, but they work differently and serve different purposes.

**Key Differences:**

| Aspect | `markForCheck()` | `detectChanges()` |
|--------|------------------|-------------------|
| **Scope** | Component + ancestors | Current component only |
| **Timing** | Schedules for next CD cycle | Runs immediately |
| **OnPush** | Essential for OnPush components | Works with any strategy |
| **Performance** | More efficient | Less efficient |
| **Use Case** | Async updates, OnPush | Immediate updates needed |

**`markForCheck()` - Schedule Change Detection:**

```typescript
@Component({
  selector: 'app-onpush-component',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>{{ data }}</div>
    <button (click)="updateData()">Update</button>
  `
})
export class OnPushComponent implements OnInit {
  data: string = 'Initial';
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  ngOnInit() {
    // Async operation that won't trigger CD automatically
    setTimeout(() => {
      this.data = 'Updated after timeout';
      // ✅ Mark this component and ancestors for checking
      this.cdr.markForCheck();
    }, 2000);
  }
  
  updateData() {
    // Manual update
    this.data = 'Manually updated';
    this.cdr.markForCheck(); // Schedule CD for next cycle
  }
}
```

**`detectChanges()` - Immediate Change Detection:**

```typescript
@Component({
  selector: 'app-immediate-component',
  template: `
    <div>{{ message }}</div>
    <div>{{ computedValue }}</div>
  `
})
export class ImmediateComponent {
  message: string = 'Initial';
  computedValue: number = 0;
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  updateImmediately() {
    this.message = 'Updated';
    this.computedValue = this.expensiveCalculation();
    
    // ✅ Run change detection immediately for this component only
    this.cdr.detectChanges();
    
    // Now we can safely access updated DOM
    const element = document.querySelector('.message');
    console.log('Updated DOM:', element?.textContent);
  }
  
  private expensiveCalculation(): number {
    // Some expensive computation
    return Math.random() * 1000;
  }
}
```

**Real-World Use Cases:**

**1. OnPush with Observables:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div *ngFor="let item of items">{{ item.name }}</div>
    <div>Status: {{ status }}</div>
  `
})
export class ObservableComponent implements OnInit, OnDestroy {
  items: Item[] = [];
  status: string = 'Loading';
  private destroy$ = new Subject<void>();
  
  constructor(
    private dataService: DataService,
    private cdr: ChangeDetectorRef
  ) {}
  
  ngOnInit() {
    // ✅ markForCheck with observables
    this.dataService.getItems()
      .pipe(takeUntil(this.destroy$))
      .subscribe(items => {
        this.items = items;
        this.status = 'Loaded';
        this.cdr.markForCheck(); // Schedule CD
      });
    
    // ✅ markForCheck with interval
    interval(5000)
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        this.status = `Updated at ${new Date().toLocaleTimeString()}`;
        this.cdr.markForCheck();
      });
  }
  
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

**2. Immediate DOM Access:**
```typescript
@Component({
  template: `
    <div #content [innerHTML]="htmlContent"></div>
    <button (click)="updateAndMeasure()">Update & Measure</button>
  `
})
export class DOMAccessComponent {
  @ViewChild('content', { static: true }) contentRef!: ElementRef;
  htmlContent: string = '<p>Initial content</p>';
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  updateAndMeasure() {
    this.htmlContent = '<p>New content with more text</p>';
    
    // ✅ detectChanges for immediate DOM update
    this.cdr.detectChanges();
    
    // Now we can measure the updated DOM
    const height = this.contentRef.nativeElement.offsetHeight;
    console.log('Content height:', height);
    
    // Trigger animations based on new height
    this.animateBasedOnHeight(height);
  }
  
  private animateBasedOnHeight(height: number) {
    // Animation logic that depends on DOM measurements
  }
}
```

**3. Form Validation with Immediate Feedback:**
```typescript
@Component({
  template: `
    <form [formGroup]="form">
      <input formControlName="email" 
             (blur)="validateEmail()"
             [class.error]="showEmailError">
      <div *ngIf="showEmailError" class="error-message">
        {{ emailErrorMessage }}
      </div>
    </form>
  `
})
export class ValidationComponent {
  form: FormGroup;
  showEmailError = false;
  emailErrorMessage = '';
  
  constructor(
    private fb: FormBuilder,
    private cdr: ChangeDetectorRef
  ) {
    this.form = this.fb.group({
      email: ['', [Validators.required, Validators.email]]
    });
  }
  
  async validateEmail() {
    const emailControl = this.form.get('email');
    
    if (emailControl?.invalid) {
      this.showEmailError = true;
      this.emailErrorMessage = 'Invalid email format';
      
      // ✅ detectChanges for immediate error display
      this.cdr.detectChanges();
      
      // Focus management after immediate update
      this.focusFirstError();
    } else {
      // Check email uniqueness asynchronously
      const isUnique = await this.checkEmailUniqueness(emailControl?.value);
      
      if (!isUnique) {
        this.showEmailError = true;
        this.emailErrorMessage = 'Email already exists';
        this.cdr.detectChanges();
      }
    }
  }
  
  private focusFirstError() {
    const errorElement = document.querySelector('.error');
    if (errorElement) {
      (errorElement as HTMLElement).focus();
    }
  }
}
```

**4. Performance Optimization Patterns:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class OptimizedComponent {
  private batchedUpdates: (() => void)[] = [];
  private updateScheduled = false;
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  // ✅ Batch multiple updates with markForCheck
  batchUpdate(updateFn: () => void) {
    this.batchedUpdates.push(updateFn);
    
    if (!this.updateScheduled) {
      this.updateScheduled = true;
      
      // Use microtask to batch updates
      Promise.resolve().then(() => {
        this.batchedUpdates.forEach(fn => fn());
        this.batchedUpdates = [];
        this.updateScheduled = false;
        this.cdr.markForCheck();
      });
    }
  }
  
  // ✅ Detach and reattach for heavy operations
  performHeavyOperation() {
    this.cdr.detach(); // Stop automatic CD
    
    // Heavy operations that would trigger many CD cycles
    for (let i = 0; i < 1000; i++) {
      this.processItem(i);
    }
    
    this.cdr.reattach(); // Resume automatic CD
    this.cdr.detectChanges(); // Update once after all operations
  }
}
```

**When to Use Each:**

**Use `markForCheck()` when:**
- Working with OnPush components
- Handling async operations (HTTP, timers, observables)
- You want to schedule updates for the next CD cycle
- Performance is critical (batch updates)

**Use `detectChanges()` when:**
- You need immediate DOM updates
- Measuring DOM elements after changes
- Synchronous operations requiring instant feedback
- Working with third-party libraries that need updated DOM

**Best Practices:**
1. **Prefer `markForCheck()`** for most OnPush scenarios
2. **Use `detectChanges()` sparingly** - it bypasses Angular's optimization
3. **Batch updates** when possible with `markForCheck()`
4. **Consider `detach()/reattach()`** for heavy operations
5. **Test performance impact** of both approaches

[Back to Change Detection & Performance](#change-detection--performance)

### 28. How do you profile performance with Angular DevTools?

**Answer:**
Angular DevTools is a powerful browser extension that provides comprehensive performance profiling and debugging capabilities for Angular applications.

**Installation and Setup:**

**1. Install Angular DevTools:**
```bash
# Chrome Extension
# Visit: https://chrome.google.com/webstore/detail/angular-devtools/ienfalfjdbdpebioblfackkekamfmbnh

# Firefox Add-on
# Visit: https://addons.mozilla.org/en-US/firefox/addon/angular-devtools/

# For development builds, ensure you have:
ng serve --configuration development
# or
ng build --configuration development
```

**2. Enable in Angular App:**
```typescript
// main.ts - Development only
import { enableProdMode } from '@angular/core';
import { environment } from './environments/environment';

if (environment.production) {
  enableProdMode();
} else {
  // DevTools available in development mode
  console.log('Angular DevTools available');
}
```

**Key Profiling Features:**

**1. Component Tree Profiler:**
```typescript
// Example component for profiling
@Component({
  selector: 'app-performance-test',
  template: `
    <div *ngFor="let item of items; trackBy: trackByFn">
      <app-heavy-component 
        [data]="item" 
        (update)="onItemUpdate($event)">
      </app-heavy-component>
    </div>
  `
})
export class PerformanceTestComponent {
  items: Item[] = [];
  
  // This will show up in profiler
  trackByFn(index: number, item: Item) {
    return item.id;
  }
  
  onItemUpdate(event: any) {
    // Profile this method's performance
    console.profile('Item Update');
    this.updateItem(event);
    console.profileEnd('Item Update');
  }
}
```

**2. Change Detection Profiling:**

**Enable CD Profiling:**
```typescript
// app.component.ts
import { ApplicationRef } from '@angular/core';

export class AppComponent implements OnInit {
  constructor(private appRef: ApplicationRef) {}
  
  ngOnInit() {
    // Enable change detection profiling in development
    if (!environment.production) {
      // Monitor CD cycles
      this.appRef.tick = this.profileTick.bind(this);
    }
  }
  
  private profileTick() {
    const start = performance.now();
    ApplicationRef.prototype.tick.call(this.appRef);
    const end = performance.now();
    console.log(`CD cycle took: ${end - start}ms`);
  }
}
```

**Using Angular DevTools Profiler:**

**1. Start Profiling Session:**
```typescript
// Component to profile
@Component({
  selector: 'app-profiled-component',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <button (click)="triggerHeavyOperation()">Heavy Operation</button>
    <div *ngFor="let item of processedItems">{{ item.value }}</div>
  `
})
export class ProfiledComponent {
  items: Item[] = [];
  processedItems: ProcessedItem[] = [];
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  triggerHeavyOperation() {
    // This will be visible in the profiler
    console.time('Heavy Operation');
    
    this.processedItems = this.items.map(item => ({
      ...item,
      value: this.expensiveCalculation(item.data)
    }));
    
    this.cdr.markForCheck();
    console.timeEnd('Heavy Operation');
  }
  
  private expensiveCalculation(data: any): string {
    // Simulate expensive computation
    let result = '';
    for (let i = 0; i < 10000; i++) {
      result += data.toString();
    }
    return result.substring(0, 100);
  }
}
```

**2. Analyze Profiling Results:**

**Performance Metrics to Monitor:**
```typescript
// Custom performance monitoring
@Injectable({ providedIn: 'root' })
export class PerformanceMonitorService {
  private cdCount = 0;
  private cdTotalTime = 0;
  
  constructor() {
    this.setupChangeDetectionMonitoring();
  }
  
  private setupChangeDetectionMonitoring() {
    // Monkey patch for CD monitoring
    const originalTick = ApplicationRef.prototype.tick;
    
    ApplicationRef.prototype.tick = function() {
      const start = performance.now();
      originalTick.call(this);
      const end = performance.now();
      
      this.cdCount++;
      this.cdTotalTime += (end - start);
      
      // Log slow CD cycles
      if ((end - start) > 16) { // Slower than 60fps
        console.warn(`Slow CD cycle: ${end - start}ms`);
      }
    }.bind(this);
  }
  
  getPerformanceStats() {
    return {
      totalCycles: this.cdCount,
      averageTime: this.cdTotalTime / this.cdCount,
      totalTime: this.cdTotalTime
    };
  }
}
```

**3. Component Performance Analysis:**

**Measure Component Render Time:**
```typescript
@Component({
  selector: 'app-measured-component',
  template: `<div>{{ expensiveData }}</div>`
})
export class MeasuredComponent implements OnInit, AfterViewInit {
  expensiveData: string = '';
  
  ngOnInit() {
    console.time('Component Init');
    this.expensiveData = this.generateExpensiveData();
    console.timeEnd('Component Init');
  }
  
  ngAfterViewInit() {
    console.time('View Init');
    // Measure DOM operations
    const element = document.querySelector('app-measured-component');
    const height = element?.clientHeight;
    console.log('Component height:', height);
    console.timeEnd('View Init');
  }
  
  private generateExpensiveData(): string {
    // This will show in profiler
    const start = performance.now();
    let data = '';
    for (let i = 0; i < 1000; i++) {
      data += `Item ${i} `;
    }
    const end = performance.now();
    console.log(`Data generation took: ${end - start}ms`);
    return data;
  }
}
```

**4. Memory Usage Profiling:**

**Track Memory Leaks:**
```typescript
@Component({
  selector: 'app-memory-tracked'
})
export class MemoryTrackedComponent implements OnInit, OnDestroy {
  private subscriptions: Subscription[] = [];
  private timers: any[] = [];
  
  ngOnInit() {
    // Track subscriptions for memory leaks
    const sub1 = this.dataService.getData().subscribe(data => {
      console.log('Data received:', data);
    });
    
    const sub2 = interval(1000).subscribe(tick => {
      console.log('Tick:', tick);
    });
    
    this.subscriptions.push(sub1, sub2);
    
    // Track timers
    const timer = setInterval(() => {
      console.log('Timer tick');
    }, 5000);
    
    this.timers.push(timer);
  }
  
  ngOnDestroy() {
    // Clean up to prevent memory leaks
    console.log(`Cleaning up ${this.subscriptions.length} subscriptions`);
    this.subscriptions.forEach(sub => sub.unsubscribe());
    
    console.log(`Cleaning up ${this.timers.length} timers`);
    this.timers.forEach(timer => clearInterval(timer));
  }
}
```

**5. Bundle Analysis Integration:**

**Performance Budget Monitoring:**
```json
// angular.json
{
  "projects": {
    "your-app": {
      "architect": {
        "build": {
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kb",
                  "maximumError": "1mb"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "2kb",
                  "maximumError": "4kb"
                }
              ]
            }
          }
        }
      }
    }
  }
}
```

**6. Real-time Performance Monitoring:**

**Web Vitals Integration:**
```typescript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

@Injectable({ providedIn: 'root' })
export class WebVitalsService {
  constructor() {
    this.initWebVitals();
  }
  
  private initWebVitals() {
    getCLS((metric) => {
      console.log('CLS:', metric);
      this.sendToAnalytics('CLS', metric.value);
    });
    
    getFID((metric) => {
      console.log('FID:', metric);
      this.sendToAnalytics('FID', metric.value);
    });
    
    getFCP((metric) => {
      console.log('FCP:', metric);
      this.sendToAnalytics('FCP', metric.value);
    });
    
    getLCP((metric) => {
      console.log('LCP:', metric);
      this.sendToAnalytics('LCP', metric.value);
    });
    
    getTTFB((metric) => {
      console.log('TTFB:', metric);
      this.sendToAnalytics('TTFB', metric.value);
    });
  }
  
  private sendToAnalytics(metric: string, value: number) {
    // Send to your analytics service
    console.log(`${metric}: ${value}`);
  }
}
```

**DevTools Profiling Workflow:**

1. **Open Angular DevTools** in browser developer tools
2. **Navigate to Profiler tab**
3. **Start recording** before triggering the operation
4. **Perform the action** you want to profile
5. **Stop recording** and analyze results
6. **Look for:**
   - Slow components (red bars)
   - Frequent change detection cycles
   - Memory allocation patterns
   - Component lifecycle timing

**Performance Optimization Tips:**
- **Use OnPush** for components showing as expensive
- **Implement trackBy** for large lists
- **Lazy load** heavy components
- **Memoize** expensive computations
- **Debounce** user inputs
- **Use virtual scrolling** for large datasets

[Back to Change Detection & Performance](#change-detection--performance)

### 29. What are CD cycles and how to analyze them?

**Answer:**
Change Detection (CD) cycles are the process Angular uses to check for changes in component data and update the DOM. Understanding and analyzing these cycles is crucial for optimizing application performance.

**What are CD Cycles:**

A change detection cycle involves:
1. **Triggering event** (user interaction, HTTP response, timer)
2. **Zone.js notification** to Angular
3. **Tree traversal** from root to leaf components
4. **Binding evaluation** for each component
5. **DOM updates** for changed values
6. **Lifecycle hooks** execution

**CD Cycle Triggers:**
```typescript
// Common triggers that start CD cycles
export class CDTriggerExamples {
  constructor(private http: HttpClient) {}
  
  // 1. DOM Events
  onClick() {
    console.log('Click triggers CD cycle');
  }
  
  // 2. HTTP Requests
  loadData() {
    this.http.get('/api/data').subscribe(data => {
      this.data = data; // CD runs after subscription
    });
  }
  
  // 3. Timers
  startTimer() {
    setTimeout(() => {
      this.message = 'Updated'; // CD runs after timeout
    }, 1000);
  }
  
  // 4. Promises
  async asyncOperation() {
    const result = await fetch('/api/data');
    this.result = await result.json(); // CD runs after promise resolution
  }
  
  // 5. Observable emissions
  ngOnInit() {
    interval(1000).subscribe(tick => {
      this.tick = tick; // CD runs on each emission
    });
  }
}

[Back to Change Detection & Performance](#change-detection--performance)

### 30. How do you implement efficient data structures for large datasets? {#30-how-do-you-implement-efficient-data-structures-for-large-datasets}

**Answer:**
Efficient data structures are crucial for handling large datasets in Angular applications. Here are comprehensive strategies and implementations:

**1. Virtual Scrolling for Large Lists:**
```typescript
@Component({
  template: `
    <cdk-virtual-scroll-viewport itemSize="50" class="viewport">
      <div *cdkVirtualFor="let item of items; trackBy: trackByFn">
        <div class="item">
          <span>{{ item.name }}</span>
          <span>{{ item.email }}</span>
        </div>
      </div>
    </cdk-virtual-scroll-viewport>
  `,
  styles: [`
    .viewport { 
      height: 400px; 
      width: 100%;
    }
    .item {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      border-bottom: 1px solid #eee;
    }
  `]
})
export class VirtualListComponent {
  items = Array.from({length: 100000}, (_, i) => ({
    id: i,
    name: `User ${i}`,
    email: `user${i}@example.com`
  }));
  
  trackByFn(index: number, item: any) {
    return item.id; // Stable identity for performance
  }
}
```

**2. Immutable Data Patterns with OnPush:**
```typescript
interface AppState {
  users: User[];
  loading: boolean;
  error: string | null;
  filters: FilterState;
}

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div *ngIf="state.loading">Loading...</div>
    <div *ngIf="state.error">Error: {{ state.error }}</div>
    <user-list [users]="filteredUsers$ | async"></user-list>
  `
})
export class DataComponent {
  state: AppState = { 
    users: [], 
    loading: false, 
    error: null,
    filters: { search: '', category: 'all' }
  };
  
  filteredUsers$ = new BehaviorSubject(this.state.users);
  
  // Efficient updates with immutable patterns
  addUser(user: User) {
    this.state = {
      ...this.state,
      users: [...this.state.users, user] // New array reference
    };
    this.updateFilteredUsers();
  }
  
  updateUser(id: number, updates: Partial<User>) {
    this.state = {
      ...this.state,
      users: this.state.users.map(user => 
        user.id === id ? { ...user, ...updates } : user
      )
    };
    this.updateFilteredUsers();
  }
  
  removeUser(id: number) {
    this.state = {
      ...this.state,
      users: this.state.users.filter(user => user.id !== id)
    };
    this.updateFilteredUsers();
  }
  
  private updateFilteredUsers() {
    const filtered = this.applyFilters(this.state.users, this.state.filters);
    this.filteredUsers$.next(filtered);
  }
}
```

**3. Smart Pagination and Caching:**
```typescript
@Injectable()
export class DataService {
  private cache = new Map<string, { data: User[], timestamp: number }>();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  
  getUsers(page: number, pageSize: number, filters?: any): Observable<User[]> {
    const cacheKey = `${page}-${pageSize}-${JSON.stringify(filters || {})}`;
    const cached = this.cache.get(cacheKey);
    
    // Return cached data if fresh
    if (cached && (Date.now() - cached.timestamp) < this.CACHE_TTL) {
      return of(cached.data);
    }
    
    return this.http.get<User[]>(`/api/users`, {
      params: {
        page: page.toString(),
        size: pageSize.toString(),
        ...filters
      }
    }).pipe(
      tap(users => {
        this.cache.set(cacheKey, {
          data: users,
          timestamp: Date.now()
        });
      }),
      shareReplay(1)
    );
  }
  
  // Infinite scroll implementation
  getInfiniteUsers(lastId?: number, limit: number = 20): Observable<User[]> {
    const params: any = { limit };
    if (lastId) {
      params.lastId = lastId;
    }
    
    return this.http.get<User[]>('/api/users/infinite', { params });
  }
  
  clearCache() {
    this.cache.clear();
  }
}
```

**4. Efficient Filtering and Searching:**
```typescript
@Injectable()
export class SearchService {
  // Use Web Workers for heavy computations
  private worker?: Worker;
  
  constructor() {
    if (typeof Worker !== 'undefined') {
      this.worker = new Worker(new URL('../workers/search.worker', import.meta.url));
    }
  }
  
  // Client-side search with indexing
  searchUsers(users: User[], query: string): Observable<User[]> {
    if (!query.trim()) {
      return of(users);
    }
    
    // Use Web Worker for large datasets
    if (this.worker && users.length > 10000) {
      return new Observable(observer => {
        this.worker!.postMessage({ users, query });
        this.worker!.onmessage = ({ data }) => {
          observer.next(data.results);
          observer.complete();
        };
      });
    }
    
    // Simple client-side filtering
    const filtered = users.filter(user => 
      user.name.toLowerCase().includes(query.toLowerCase()) ||
      user.email.toLowerCase().includes(query.toLowerCase())
    );
    
    return of(filtered);
  }
  
  // Debounced search
  createDebouncedSearch(searchTerm$: Observable<string>): Observable<User[]> {
    return searchTerm$.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(term => this.searchUsers([], term)),
      shareReplay(1)
    );
  }
}
```

**5. Memory-Efficient Data Structures:**
```typescript
// Use Maps for O(1) lookups
@Injectable()
export class UserCacheService {
  private userMap = new Map<number, User>();
  private usersByCategory = new Map<string, Set<number>>();
  private searchIndex = new Map<string, Set<number>>();
  
  addUser(user: User) {
    this.userMap.set(user.id, user);
    
    // Index by category
    if (!this.usersByCategory.has(user.category)) {
      this.usersByCategory.set(user.category, new Set());
    }
    this.usersByCategory.get(user.category)!.add(user.id);
    
    // Index for search
    this.indexUserForSearch(user);
  }
  
  getUserById(id: number): User | undefined {
    return this.userMap.get(id);
  }
  
  getUsersByCategory(category: string): User[] {
    const userIds = this.usersByCategory.get(category);
    if (!userIds) return [];
    
    return Array.from(userIds)
      .map(id => this.userMap.get(id))
      .filter(user => user !== undefined) as User[];
  }
  
  searchUsers(query: string): User[] {
    const words = query.toLowerCase().split(' ');
    let resultIds: Set<number> | undefined;
    
    for (const word of words) {
      const wordIds = this.searchIndex.get(word);
      if (!wordIds) return [];
      
      if (!resultIds) {
        resultIds = new Set(wordIds);
      } else {
        // Intersection of sets
        resultIds = new Set([...resultIds].filter(id => wordIds.has(id)));
      }
    }
    
    return Array.from(resultIds || [])
      .map(id => this.userMap.get(id))
      .filter(user => user !== undefined) as User[];
  }
  
  private indexUserForSearch(user: User) {
    const words = `${user.name} ${user.email}`.toLowerCase().split(/\s+/);
    
    for (const word of words) {
      if (!this.searchIndex.has(word)) {
        this.searchIndex.set(word, new Set());
      }
      this.searchIndex.get(word)!.add(user.id);
    }
  }
}
```

**6. Component-Level Optimizations:**
```typescript
@Component({
  selector: 'app-user-table',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="table-container">
      <table>
        <thead>
          <tr>
            <th *ngFor="let column of columns" 
                (click)="sortBy(column.key)"
                [class.sorted]="sortColumn === column.key">
              {{ column.label }}
            </th>
          </tr>
        </thead>
        <tbody>
          <tr *ngFor="let user of displayedUsers; trackBy: trackByUserId">
            <td>{{ user.name }}</td>
            <td>{{ user.email }}</td>
            <td>{{ user.role }}</td>
          </tr>
        </tbody>
      </table>
    </div>
  `
})
export class UserTableComponent implements OnInit {
  @Input() users: User[] = [];
  
  displayedUsers: User[] = [];
  sortColumn = '';
  sortDirection: 'asc' | 'desc' = 'asc';
  
  columns = [
    { key: 'name', label: 'Name' },
    { key: 'email', label: 'Email' },
    { key: 'role', label: 'Role' }
  ];
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  ngOnInit() {
    this.displayedUsers = [...this.users];
  }
  
  trackByUserId(index: number, user: User): number {
    return user.id;
  }
  
  sortBy(column: string) {
    if (this.sortColumn === column) {
      this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
      this.sortColumn = column;
      this.sortDirection = 'asc';
    }
    
    this.displayedUsers = this.sortUsers(this.users, column, this.sortDirection);
    this.cdr.markForCheck();
  }
  
  private sortUsers(users: User[], column: string, direction: 'asc' | 'desc'): User[] {
    return [...users].sort((a, b) => {
      const aVal = a[column as keyof User];
      const bVal = b[column as keyof User];
      
      if (aVal < bVal) return direction === 'asc' ? -1 : 1;
      if (aVal > bVal) return direction === 'asc' ? 1 : -1;
      return 0;
    });
  }
}
```

**Performance Benefits:**

| Technique | Memory Savings | Rendering Speed | Use Case |
|-----------|----------------|-----------------|----------|
| Virtual Scrolling | 90%+ | 10x faster | Large lists (1000+ items) |
| OnPush + Immutable | 50% | 3x faster | Complex forms/tables |
| Smart Caching | 70% | 5x faster | API-heavy apps |
| Indexed Search | 80% | 20x faster | Search-heavy features |
| Web Workers | Varies | UI stays responsive | Heavy computations |

**Best Practices:**

1. **Use virtual scrolling** for lists with 1000+ items
2. **Implement OnPush** with immutable data patterns
3. **Cache strategically** with TTL and invalidation
4. **Index data** for fast lookups and searches
5. **Use Web Workers** for heavy computations
6. **Monitor memory usage** in production
7. **Implement pagination** for server-side data
8. **Use trackBy functions** for ngFor performance
9. **Lazy load** non-critical data
10. **Profile and measure** performance improvements

**Memory Leak Prevention:**
```typescript
@Component({})
export class SafeDataComponent implements OnDestroy {
  private subscriptions = new Subscription();
  
  ngOnInit() {
    // Always clean up subscriptions
    this.subscriptions.add(
      this.dataService.getData().subscribe(data => this.data = data)
    );
  }
  
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
}
```

[Back to Change Detection & Performance](#change-detection--performance)

---

## RxJS and Observables

### 31. What are Observables and how do they differ from Promises?

**Answer:**
Observables are a powerful way to handle asynchronous data streams in Angular applications. They represent a stream of values over time and are lazy, meaning they don't execute until subscribed to.

**Key Differences:**

| Feature | Observable | Promise |
|---------|------------|---------|
| **Values** | Multiple values over time | Single value |
| **Execution** | Lazy (cold) - executes on subscription | Eager - executes immediately |
| **Cancellation** | Can be cancelled with `unsubscribe()` | Cannot be cancelled |
| **Operators** | Rich set of operators (map, filter, etc.) | Limited (.then, .catch, .finally) |
| **Error Handling** | Can recover from errors and continue | Terminates on error |
| **Memory** | Must unsubscribe to prevent leaks | Automatically garbage collected |

**Observable Example:**
```typescript
import { Observable, of, interval } from 'rxjs';
import { map, filter, take } from 'rxjs/operators';

// Creating observables
const numbers$ = of(1, 2, 3, 4, 5);
const timer$ = interval(1000);

// Multiple values over time
const evenNumbers$ = numbers$.pipe(
  filter(n => n % 2 === 0),
  map(n => n * 2)
);

// Subscription (lazy execution)
const subscription = evenNumbers$.subscribe({
  next: value => console.log('Value:', value),
  error: err => console.error('Error:', err),
  complete: () => console.log('Complete!')
});

// Can unsubscribe
subscription.unsubscribe();
```

**Promise Example:**
```typescript
// Promise - single value, eager execution
const fetchUser = async (id: number): Promise<User> => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
};

// Executes immediately when called
fetchUser(1)
  .then(user => console.log(user))
  .catch(error => console.error(error));
```

**When to Use Each:**

**Use Observables for:**
- HTTP requests that might be cancelled
- Real-time data streams (WebSocket, SSE)
- Form validation and user input
- Complex async operations with multiple values
- When you need rich operators for data transformation

**Use Promises for:**
- Simple one-time async operations
- API calls that don't need cancellation
- Working with async/await syntax
- Integration with non-RxJS libraries

**Angular Integration:**
```typescript
@Component({
  template: `
    <!-- Async pipe automatically subscribes/unsubscribes -->
    <div *ngFor="let user of users$ | async">{{ user.name }}</div>
    
    <!-- Promise with async pipe -->
    <div>{{ userData | async }}</div>
  `
})
export class UserComponent {
  // Observable stream
  users$ = this.http.get<User[]>('/api/users');
  
  // Promise
  userData = this.http.get<User>('/api/user/1').toPromise();
  
  constructor(private http: HttpClient) {}
}
```

[Back to RxJS and Observables](#rxjs-and-observables)

### 32. Compare `switchMap`, `mergeMap`, `concatMap`, and `exhaustMap` with real use cases

**Answer:**
These are higher-order mapping operators that handle nested observables differently. Each has specific use cases based on how you want to handle multiple inner observables.

**Visual Comparison:**
```
Source:     --1----2----3----4----5--|
            
switchMap:  --a----c---------e----f--|  (cancels previous)
mergeMap:   --a-b--c-d--e-f--g-h--i--|  (merges all)
concatMap:  --a-b-----c-d-----e-f--g--|  (waits for completion)
exhaustMap: --a-b-----------e-f-------|  (ignores while active)
```

**1. switchMap - "Switch to Latest"**

**Behavior:** Cancels previous inner observable when new value arrives.

**Use Cases:**
- Search/autocomplete (cancel previous search)
- Navigation (cancel previous route data loading)
- Real-time data updates

```typescript
// Search autocomplete - cancel previous searches
@Component({
  template: `<input (keyup)="searchTerm$.next($event.target.value)">`
})
export class SearchComponent {
  searchTerm$ = new Subject<string>();
  
  results$ = this.searchTerm$.pipe(
    debounceTime(300),
    distinctUntilChanged(),
    switchMap(term => 
      term ? this.searchService.search(term) : of([])
    )
  );
  
  constructor(private searchService: SearchService) {}
}

// Route data loading - cancel previous route data
this.route.params.pipe(
  switchMap(params => this.userService.getUser(params['id']))
).subscribe(user => this.user = user);
```

**2. mergeMap (flatMap) - "Merge All"**

**Behavior:** Runs all inner observables concurrently and merges results.

**Use Cases:**
- Parallel API calls
- File uploads
- Independent operations

```typescript
// Upload multiple files concurrently
uploadFiles(files: File[]) {
  return from(files).pipe(
    mergeMap(file => this.uploadService.upload(file), 3), // Max 3 concurrent
    scan((acc, result) => [...acc, result], [])
  );
}

// Load user details for multiple users
loadUserDetails(userIds: number[]) {
  return from(userIds).pipe(
    mergeMap(id => this.userService.getUserDetails(id)),
    toArray() // Collect all results
  );
}

// Real-world example: Load dashboard data
loadDashboardData() {
  const sources = [
    this.userService.getCurrentUser(),
    this.notificationService.getNotifications(),
    this.analyticsService.getStats()
  ];
  
  return from(sources).pipe(
    mergeMap(source => source),
    scan((acc, data) => ({ ...acc, ...data }), {})
  );
}
```

**3. concatMap - "One After Another"**

**Behavior:** Waits for each inner observable to complete before starting the next.

**Use Cases:**
- Sequential operations (order matters)
- API calls that must be in sequence
- File processing in order

```typescript
// Sequential API calls - create user then assign role
createUserWithRole(userData: User, roleId: number) {
  return this.userService.createUser(userData).pipe(
    concatMap(user => 
      this.roleService.assignRole(user.id, roleId).pipe(
        map(() => user)
      )
    )
  );
}

// Process files in order
processFiles(files: File[]) {
  return from(files).pipe(
    concatMap(file => this.processFile(file)),
    tap(result => console.log('Processed:', result))
  );
}

// Sequential form submissions
submitForms(forms: FormData[]) {
  return from(forms).pipe(
    concatMap(form => this.http.post('/api/submit', form)),
    scan((results, response) => [...results, response], [])
  );
}
```

**4. exhaustMap - "Ignore While Busy"**

**Behavior:** Ignores new values while inner observable is active.

**Use Cases:**
- Prevent duplicate submissions
- Login/authentication
- Resource-intensive operations

```typescript
// Prevent double-click submissions
@Component({
  template: `<button (click)="submit$.next()">Submit</button>`
})
export class FormComponent {
  submit$ = new Subject<void>();
  
  constructor(private formService: FormService) {
    this.submit$.pipe(
      exhaustMap(() => this.formService.submitForm(this.formData))
    ).subscribe(response => {
      console.log('Form submitted:', response);
    });
  }
}

// Login - ignore subsequent login attempts while processing
login(credentials: LoginCredentials) {
  return this.loginClick$.pipe(
    exhaustMap(() => this.authService.login(credentials)),
    tap(response => this.handleLoginSuccess(response)),
    catchError(error => this.handleLoginError(error))
  );
}

// Resource-intensive operation
processLargeDataset() {
  return this.processButton$.pipe(
    exhaustMap(() => this.dataService.processLargeDataset()),
    tap(() => console.log('Processing complete'))
  );
}
```

**Decision Matrix:**

| Scenario | Operator | Reason |
|----------|----------|---------|
| Search/Autocomplete | `switchMap` | Cancel previous searches |
| Form submission | `exhaustMap` | Prevent duplicate submissions |
| File upload (parallel) | `mergeMap` | Upload multiple files at once |
| File processing (order matters) | `concatMap` | Process files sequentially |
| Route navigation | `switchMap` | Cancel previous route data |
| Authentication | `exhaustMap` | Ignore while login in progress |
| Dashboard data loading | `mergeMap` | Load multiple data sources concurrently |
| Wizard steps | `concatMap` | Complete steps in sequence |

**Common Pitfalls:**

```typescript
// ❌ Wrong: Using mergeMap for search (doesn't cancel)
searchTerm$.pipe(
  mergeMap(term => this.search(term)) // Can show old results
);

// ✅ Correct: Using switchMap for search
searchTerm$.pipe(
  switchMap(term => this.search(term)) // Cancels previous
);

// ❌ Wrong: Using switchMap for file uploads (cancels uploads)
files$.pipe(
  switchMap(file => this.upload(file)) // Cancels ongoing uploads
);

// ✅ Correct: Using mergeMap for file uploads
files$.pipe(
  mergeMap(file => this.upload(file), 3) // Concurrent uploads
);
```

**Memory and Performance:**
- `switchMap`: Best memory usage (cancels previous)
- `mergeMap`: Highest memory usage (keeps all active)
- `concatMap`: Moderate memory usage (one at a time)
- `exhaustMap`: Lowest CPU usage (ignores excess)

[Back to RxJS and Observables](#rxjs-and-observables)

### 33. How do you handle errors in RxJS streams?

**Answer:**
Error handling in RxJS is crucial for building robust Angular applications. RxJS provides several operators and strategies for handling errors gracefully.

**Error Handling Operators:**

**1. catchError - Handle and Recover**
```typescript
import { catchError, retry, of, EMPTY } from 'rxjs';

// Basic error handling
this.http.get<User[]>('/api/users').pipe(
  catchError(error => {
    console.error('API Error:', error);
    return of([]); // Return fallback value
  })
).subscribe(users => console.log(users));

// Different recovery strategies
getUserData(id: number) {
  return this.http.get<User>(`/api/users/${id}`).pipe(
    catchError(error => {
      if (error.status === 404) {
        return of(null); // User not found - return null
      } else if (error.status >= 500) {
        return throwError(() => new Error('Server error - please try again'));
      } else {
        return EMPTY; // Complete the stream without emitting
      }
    })
  );
}
```

**2. retry - Automatic Retry**
```typescript
// Simple retry
this.http.get('/api/data').pipe(
  retry(3), // Retry up to 3 times
  catchError(error => {
    console.error('Failed after 3 retries:', error);
    return of(null);
  })
);

// Conditional retry with retryWhen
import { retryWhen, delay, take, tap } from 'rxjs/operators';

this.http.get('/api/data').pipe(
  retryWhen(errors => 
    errors.pipe(
      tap(error => console.log('Retrying after error:', error)),
      delay(1000), // Wait 1 second between retries
      take(3) // Maximum 3 retries
    )
  ),
  catchError(error => of({ error: 'Service unavailable' }))
);
```

**3. finalize - Cleanup Actions**
```typescript
@Component({})
export class DataComponent {
  loading = false;
  
  loadData() {
    this.loading = true;
    
    this.dataService.getData().pipe(
      finalize(() => this.loading = false) // Always executed
    ).subscribe({
      next: data => this.data = data,
      error: error => this.handleError(error)
    });
  }
}
```

**Error Handling Patterns:**

**1. Global Error Handler**
```typescript
// error.service.ts
@Injectable({
  providedIn: 'root'
})
export class ErrorService {
  handleError = (error: any): Observable<never> => {
    console.error('Global error:', error);
    
    // Log to external service
    this.logError(error);
    
    // Show user-friendly message
    this.showErrorMessage(this.getUserFriendlyMessage(error));
    
    return EMPTY;
  }
  
  private getUserFriendlyMessage(error: any): string {
    if (error.status === 0) {
      return 'Connection error. Please check your internet connection.';
    } else if (error.status >= 500) {
      return 'Server error. Please try again later.';
    } else if (error.status === 401) {
      return 'You are not authorized. Please log in again.';
    }
    return 'An unexpected error occurred.';
  }
}

// Usage in service
@Injectable()
export class DataService {
  constructor(
    private http: HttpClient,
    private errorService: ErrorService
  ) {}
  
  getData() {
    return this.http.get('/api/data').pipe(
      catchError(this.errorService.handleError)
    );
  }
}
```

**2. Component-Level Error Handling**
```typescript
@Component({
  template: `
    <div *ngIf="error$ | async as error" class="error-message">
      {{ error }}
    </div>
    <div *ngIf="data$ | async as data">
      <!-- Display data -->
    </div>
  `
})
export class UserComponent {
  private errorSubject = new Subject<string>();
  error$ = this.errorSubject.asObservable();
  
  data$ = this.userService.getUsers().pipe(
    catchError(error => {
      this.errorSubject.next('Failed to load users');
      return of([]); // Return empty array as fallback
    })
  );
}
```

**3. Chain Error Recovery**
```typescript
// Try multiple endpoints
getUserData(id: number) {
  return this.http.get(`/api/v2/users/${id}`).pipe(
    catchError(error => {
      console.warn('v2 API failed, trying v1:', error);
      return this.http.get(`/api/v1/users/${id}`);
    }),
    catchError(error => {
      console.warn('v1 API failed, using cache:', error);
      return this.cacheService.getUser(id);
    }),
    catchError(error => {
      console.error('All sources failed:', error);
      return of(null);
    })
  );
}
```

**4. Selective Error Handling**
```typescript
processUserAction(action: UserAction) {
  return this.userService.performAction(action).pipe(
    catchError(error => {
      // Only handle specific errors, let others bubble up
      if (error.code === 'VALIDATION_ERROR') {
        this.showValidationErrors(error.details);
        return EMPTY;
      } else if (error.code === 'PERMISSION_DENIED') {
        this.router.navigate(['/unauthorized']);
        return EMPTY;
      }
      
      // Re-throw other errors
      return throwError(() => error);
    })
  );
}
```

**Testing Error Scenarios:**
```typescript
// Component test
it('should handle API errors gracefully', () => {
  const errorResponse = new HttpErrorResponse({
    error: 'Not found',
    status: 404,
    statusText: 'Not Found'
  });
  
  spyOn(userService, 'getUsers').and.returnValue(throwError(() => errorResponse));
  
  component.loadUsers();
  
  expect(component.error).toBe('Failed to load users');
  expect(component.users).toEqual([]);
});
```

**Best Practices:**

1. **Always handle errors** - Don't let streams die silently
2. **Provide fallback values** - Return sensible defaults
3. **Log errors appropriately** - For debugging and monitoring
4. **Show user-friendly messages** - Don't expose technical details
5. **Use finalize for cleanup** - Ensure loading states are reset
6. **Implement retry logic** - For transient network errors
7. **Handle different error types** - Network, validation, permission, etc.
8. **Test error scenarios** - Ensure error handling works correctly

**Common Anti-patterns:**
```typescript
// ❌ Don't ignore errors
this.http.get('/api/data').subscribe(data => this.data = data);

// ❌ Don't just log and continue
this.http.get('/api/data').pipe(
  catchError(error => {
    console.error(error);
    return of(null); // This might break the UI
  })
);

// ✅ Handle errors properly
this.http.get('/api/data').pipe(
  catchError(error => {
    this.handleError(error);
    return of(this.getDefaultData());
  })
).subscribe(data => this.data = data);
```

[Back to RxJS and Observables](#rxjs-and-observables)

### 34. What is the purpose of the `async` pipe?

**Answer:**
The `async` pipe is a built-in Angular pipe that automatically subscribes to observables/promises and handles the subscription lifecycle, making it easier to work with asynchronous data in templates.

**Core Benefits:**

**1. Automatic Subscription Management**
```typescript
// Without async pipe - manual subscription
@Component({
  template: `<div>{{ userData?.name }}</div>`
})
export class UserComponent implements OnInit, OnDestroy {
  userData: User | null = null;
  private subscription?: Subscription;
  
  ngOnInit() {
    this.subscription = this.userService.getUser().subscribe(
      user => this.userData = user
    );
  }
  
  ngOnDestroy() {
    this.subscription?.unsubscribe(); // Must remember to unsubscribe
  }
}

// With async pipe - automatic handling
@Component({
  template: `<div>{{ user$ | async | json }}</div>`
})
export class UserComponent {
  user$ = this.userService.getUser(); // No manual subscription needed
}
```

**2. Memory Leak Prevention**
```typescript
// Async pipe automatically unsubscribes when component is destroyed
@Component({
  template: `
    <div *ngIf="users$ | async as users">
      <div *ngFor="let user of users">{{ user.name }}</div>
    </div>
  `
})
export class UsersComponent {
  users$ = this.userService.getUsers(); // No memory leaks!
}
```

**Advanced Usage Patterns:**

**1. Multiple Subscriptions with Alias**
```typescript
@Component({
  template: `
    <div *ngIf="data$ | async as data">
      <h2>{{ data.title }}</h2>
      <p>{{ data.description }}</p>
      <span>Last updated: {{ data.updatedAt | date }}</span>
    </div>
  `
})
export class DataComponent {
  data$ = this.dataService.getData();
}
```

**2. Combining Multiple Observables**
```typescript
@Component({
  template: `
    <div *ngIf="viewModel$ | async as vm">
      <h1>{{ vm.user.name }}</h1>
      <div>Notifications: {{ vm.notifications.length }}</div>
      <div>Settings: {{ vm.settings | json }}</div>
    </div>
  `
})
export class DashboardComponent {
  viewModel$ = combineLatest({
    user: this.userService.getCurrentUser(),
    notifications: this.notificationService.getNotifications(),
    settings: this.settingsService.getSettings()
  });
}
```

**3. Error Handling with Async Pipe**
```typescript
@Component({
  template: `
    <div *ngIf="data$ | async as data; else errorTemplate">
      {{ data | json }}
    </div>
    
    <ng-template #errorTemplate>
      <div class="error">Failed to load data</div>
    </ng-template>
  `
})
export class SafeDataComponent {
  data$ = this.dataService.getData().pipe(
    catchError(error => {
      console.error('Data loading error:', error);
      return of(null); // Return null to show error template
    })
  );
}
```

**4. Loading States**
```typescript
@Component({
  template: `
    <div [ngSwitch]="(dataState$ | async)?.type">
      <div *ngSwitchCase="'loading'" class="spinner">Loading...</div>
      <div *ngSwitchCase="'success'" class="data">
        {{ (dataState$ | async)?.data | json }}
      </div>
      <div *ngSwitchCase="'error'" class="error">
        Error: {{ (dataState$ | async)?.error }}
      </div>
    </div>
  `
})
export class LoadingStateComponent {
  dataState$ = this.dataService.getData().pipe(
    map(data => ({ type: 'success', data })),
    startWith({ type: 'loading' }),
    catchError(error => of({ type: 'error', error: error.message }))
  );
}
```

**5. Form Integration**
```typescript
@Component({
  template: `
    <form [formGroup]="form">
      <input formControlName="search" placeholder="Search users...">
    </form>
    
    <div *ngFor="let user of filteredUsers$ | async">
      {{ user.name }}
    </div>
  `
})
export class SearchComponent {
  form = this.fb.group({
    search: ['']
  });
  
  filteredUsers$ = this.form.get('search')!.valueChanges.pipe(
    startWith(''),
    debounceTime(300),
    switchMap(term => this.userService.searchUsers(term))
  );
}
```

**Performance Considerations:**

**1. Multiple Async Pipes on Same Observable**
```typescript
// ❌ Bad - Multiple subscriptions
@Component({
  template: `
    <div>Name: {{ user$ | async | json }}</div>
    <div>Email: {{ (user$ | async)?.email }}</div>
    <div>Role: {{ (user$ | async)?.role }}</div>
  `
})

// ✅ Good - Single subscription with alias
@Component({
  template: `
    <div *ngIf="user$ | async as user">
      <div>Name: {{ user.name }}</div>
      <div>Email: {{ user.email }}</div>
      <div>Role: {{ user.role }}</div>
    </div>
  `
})
```

**2. ShareReplay for Expensive Operations**
```typescript
@Component({...})
export class ExpensiveDataComponent {
  // Share the result across multiple subscriptions
  expensiveData$ = this.dataService.getExpensiveData().pipe(
    shareReplay(1) // Cache the last emission
  );
}
```

**Common Patterns:**

**1. Safe Navigation**
```typescript
@Component({
  template: `
    <div>{{ (user$ | async)?.profile?.address?.city || 'Unknown' }}</div>
  `
})
```

**2. Default Values**
```typescript
@Component({
  template: `
    <div>{{ (count$ | async) || 0 }}</div>
  `
})
export class CounterComponent {
  count$ = this.counterService.getCount().pipe(
    startWith(0) // Provide initial value
  );
}
```

**3. Conditional Rendering**
```typescript
@Component({
  template: `
    <div *ngIf="isLoggedIn$ | async">
      Welcome back!
    </div>
    
    <div *ngIf="!(isLoggedIn$ | async)">
      Please log in
    </div>
  `
})
```

**Testing with Async Pipe:**
```typescript
describe('UserComponent', () => {
  it('should display user data', () => {
    const mockUser = { name: 'John', email: 'john@example.com' };
    userService.getUser.and.returnValue(of(mockUser));
    
    fixture.detectChanges();
    
    expect(fixture.nativeElement.textContent).toContain('John');
  });
  
  it('should handle loading state', () => {
    userService.getUser.and.returnValue(NEVER); // Never emits
    
    fixture.detectChanges();
    
    expect(fixture.nativeElement.textContent).toContain('Loading...');
  });
});
```

**Best Practices:**

1. **Use async pipe over manual subscriptions** in templates
2. **Use aliases** to avoid multiple subscriptions
3. **Handle null/undefined** values gracefully
4. **Provide loading states** for better UX
5. **Use shareReplay** for expensive operations
6. **Combine observables** instead of multiple async pipes
7. **Handle errors** before the async pipe
8. **Use OnPush** change detection with async pipe for better performance

[Back to RxJS and Observables](#rxjs-and-observables)

### 35. How do you unsubscribe from Observables to prevent memory leaks?

**Answer:**
Preventing memory leaks from Observable subscriptions is crucial for Angular application performance. Here are the most effective patterns for managing subscriptions.

**1. takeUntil Pattern (Most Popular)**
```typescript
import { Subject, takeUntil } from 'rxjs';

@Component({...})
export class UserComponent implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();
  
  ngOnInit() {
    // All subscriptions automatically unsubscribe on destroy
    this.userService.getUsers().pipe(
      takeUntil(this.destroy$)
    ).subscribe(users => this.users = users);
    
    this.notificationService.getNotifications().pipe(
      takeUntil(this.destroy$)
    ).subscribe(notifications => this.notifications = notifications);
    
    // Works with multiple subscriptions
    this.settingsService.getSettings().pipe(
      takeUntil(this.destroy$)
    ).subscribe(settings => this.settings = settings);
  }
  
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

**2. takeUntilDestroyed (Angular 16+)**
```typescript
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

@Component({...})
export class ModernComponent {
  private destroyRef = inject(DestroyRef);
  
  ngOnInit() {
    // Automatically unsubscribes when component is destroyed
    this.userService.getUsers().pipe(
      takeUntilDestroyed(this.destroyRef)
    ).subscribe(users => this.users = users);
  }
  
  // Or in constructor/field initialization
  users$ = this.userService.getUsers().pipe(
    takeUntilDestroyed() // Uses injected DestroyRef automatically
  );
}
```

**3. Manual Subscription Management**
```typescript
import { Subscription } from 'rxjs';

@Component({...})
export class ManualComponent implements OnInit, OnDestroy {
  private subscriptions = new Subscription();
  
  ngOnInit() {
    // Add subscriptions to main subscription
    this.subscriptions.add(
      this.userService.getUsers().subscribe(users => this.users = users)
    );
    
    this.subscriptions.add(
      this.dataService.getData().subscribe(data => this.data = data)
    );
  }
  
  ngOnDestroy() {
    this.subscriptions.unsubscribe(); // Unsubscribes from all
  }
}
```

**4. Subscription Array Pattern**
```typescript
@Component({...})
export class ArrayComponent implements OnInit, OnDestroy {
  private subscriptions: Subscription[] = [];
  
  ngOnInit() {
    this.subscriptions.push(
      this.service1.getData().subscribe(data => this.data1 = data),
      this.service2.getData().subscribe(data => this.data2 = data),
      this.service3.getData().subscribe(data => this.data3 = data)
    );
  }
  
  ngOnDestroy() {
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }
}
```

**5. Async Pipe (Automatic Management)**
```typescript
// No manual subscription needed - async pipe handles it
@Component({
  template: `
    <div *ngFor="let user of users$ | async">{{ user.name }}</div>
    <div *ngIf="loading$ | async">Loading...</div>
  `
})
export class AsyncComponent {
  users$ = this.userService.getUsers();
  loading$ = this.loadingService.loading$;
  
  // No ngOnDestroy needed!
}
```

**Advanced Patterns:**

**1. Base Component with Subscription Management**
```typescript
// base-component.ts
export abstract class BaseComponent implements OnDestroy {
  protected destroy$ = new Subject<void>();
  
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  protected addSubscription(observable: Observable<any>) {
    return observable.pipe(takeUntil(this.destroy$));
  }
}

// Usage
@Component({...})
export class UserComponent extends BaseComponent implements OnInit {
  ngOnInit() {
    this.addSubscription(this.userService.getUsers())
      .subscribe(users => this.users = users);
  }
}
```

**2. Subscription Service**
```typescript
@Injectable()
export class SubscriptionService implements OnDestroy {
  private subscriptions = new Subscription();
  
  add(subscription: Subscription) {
    this.subscriptions.add(subscription);
  }
  
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
}

// Usage in component
@Component({
  providers: [SubscriptionService]
})
export class ManagedComponent implements OnInit {
  constructor(private subscriptionService: SubscriptionService) {}
  
  ngOnInit() {
    this.subscriptionService.add(
      this.userService.getUsers().subscribe(users => this.users = users)
    );
  }
}
```

**3. Reactive Patterns (No Subscriptions Needed)**
```typescript
@Component({
  template: `
    <div *ngIf="viewModel$ | async as vm">
      <h1>{{ vm.user.name }}</h1>
      <div>{{ vm.data | json }}</div>
    </div>
  `
})
export class ReactiveComponent {
  // Combine all data into single stream
  viewModel$ = combineLatest({
    user: this.userService.getCurrentUser(),
    data: this.dataService.getData(),
    settings: this.settingsService.getSettings()
  });
  
  // Derived data
  filteredData$ = this.searchTerm$.pipe(
    switchMap(term => this.dataService.search(term))
  );
}
```

**Memory Leak Detection:**

**1. Angular DevTools**
```typescript
// Enable subscription tracking in development
if (!environment.production) {
  import('./subscription-tracker').then(tracker => {
    tracker.enableSubscriptionTracking();
  });
}
```

**2. Custom Subscription Tracker**
```typescript
@Injectable()
export class SubscriptionTracker {
  private static activeSubscriptions = new Map<string, number>();
  
  static track(componentName: string, subscription: Subscription) {
    const count = this.activeSubscriptions.get(componentName) || 0;
    this.activeSubscriptions.set(componentName, count + 1);
    
    subscription.add(() => {
      const newCount = this.activeSubscriptions.get(componentName)! - 1;
      this.activeSubscriptions.set(componentName, newCount);
    });
  }
  
  static getActiveSubscriptions() {
    return Array.from(this.activeSubscriptions.entries())
      .filter(([_, count]) => count > 0);
  }
}
```

**Testing Subscription Management:**
```typescript
describe('UserComponent', () => {
  let component: UserComponent;
  let userService: jasmine.SpyObj<UserService>;
  
  it('should unsubscribe on destroy', () => {
    const subscription = new Subscription();
    spyOn(subscription, 'unsubscribe');
    
    userService.getUsers.and.returnValue(of([]).pipe(
      tap(() => subscription)
    ));
    
    component.ngOnInit();
    component.ngOnDestroy();
    
    expect(subscription.unsubscribe).toHaveBeenCalled();
  });
});
```

**Best Practices:**

**✅ DO:**
- Use `takeUntilDestroyed()` in Angular 16+
- Use `takeUntil()` pattern for multiple subscriptions
- Prefer async pipe when possible
- Use reactive patterns to minimize subscriptions
- Test subscription cleanup
- Use OnPush change detection with observables

**❌ DON'T:**
- Forget to unsubscribe from long-lived observables
- Subscribe in templates
- Create subscriptions in loops without cleanup
- Ignore HTTP request cancellation
- Use nested subscriptions (use operators instead)

**Common Scenarios:**

```typescript
// ✅ HTTP requests (complete automatically)
this.http.get('/api/data').subscribe(); // OK - HTTP completes

// ❌ Long-lived observables (need cleanup)
this.webSocketService.messages$.subscribe(); // Memory leak!

// ✅ Proper cleanup
this.webSocketService.messages$.pipe(
  takeUntilDestroyed()
).subscribe();

// ✅ Route params (handled by Angular)
this.route.params.subscribe(); // OK in most cases

// ✅ Form controls (need cleanup in some cases)
this.form.valueChanges.pipe(
  takeUntilDestroyed()
).subscribe();
```

**Memory Leak Checklist:**
1. ✅ All component subscriptions use `takeUntil` or `takeUntilDestroyed`
2. ✅ Event listeners are removed in `ngOnDestroy`
3. ✅ Timers and intervals are cleared
4. ✅ WebSocket connections are closed
5. ✅ Service subscriptions in components are managed
6. ✅ Form subscriptions are cleaned up
7. ✅ Router subscriptions are handled appropriately

[Back to RxJS and Observables](#rxjs-and-observables)

### 36. What are Subjects and when would you use them?

**Answer:**
Subjects are a special type of Observable that can multicast to multiple observers and can be both an Observable and an Observer. They act as a bridge between imperative and reactive programming.

**Types of Subjects:**

**1. Subject (Basic)**
```typescript
import { Subject } from 'rxjs';

// Basic Subject - no initial value, no replay
const messageSubject = new Subject<string>();

// Acting as Observer (can receive values)
messageSubject.next('Hello');
messageSubject.next('World');

// Acting as Observable (can be subscribed to)
messageSubject.subscribe(message => console.log('Sub 1:', message));
messageSubject.next('New message'); // Only new subscribers see this

// Multiple subscribers
const sub1 = messageSubject.subscribe(msg => console.log('Sub 1:', msg));
const sub2 = messageSubject.subscribe(msg => console.log('Sub 2:', msg));

messageSubject.next('Broadcast to all'); // Both subscribers receive this
```

**2. BehaviorSubject (Has Current Value)**
```typescript
import { BehaviorSubject } from 'rxjs';

// Requires initial value, always has current value
const currentUser$ = new BehaviorSubject<User | null>(null);

// New subscribers immediately get current value
currentUser$.subscribe(user => console.log('Current user:', user)); // Logs: null

currentUser$.next({ id: 1, name: 'John' });

// Late subscriber gets current value immediately
currentUser$.subscribe(user => console.log('Late subscriber:', user)); // Logs: { id: 1, name: 'John' }

// Get current value synchronously
const currentValue = currentUser$.value;
console.log('Current value:', currentValue);
```

**3. ReplaySubject (Replays N Values)**
```typescript
import { ReplaySubject } from 'rxjs';

// Replays last N values to new subscribers
const messageHistory$ = new ReplaySubject<string>(3); // Keep last 3 messages

messageHistory$.next('Message 1');
messageHistory$.next('Message 2');
messageHistory$.next('Message 3');
messageHistory$.next('Message 4');

// New subscriber gets last 3 messages
messageHistory$.subscribe(msg => console.log('Replay:', msg));
// Logs: Message 2, Message 3, Message 4

// With time window
const recentMessages$ = new ReplaySubject<string>(10, 5000); // Last 10 messages within 5 seconds
```

**4. AsyncSubject (Only Last Value)**
```typescript
import { AsyncSubject } from 'rxjs';

// Only emits the last value when completed
const result$ = new AsyncSubject<number>();

result$.subscribe(value => console.log('Result:', value));

result$.next(1);
result$.next(2);
result$.next(3);
// Nothing logged yet...

result$.complete(); // Now logs: Result: 3
```

**Common Use Cases:**

**1. Component Communication**
```typescript
// Shared service for component communication
@Injectable({
  providedIn: 'root'
})
export class MessageService {
  private messageSubject = new Subject<string>();
  
  // Expose as observable (read-only)
  messages$ = this.messageSubject.asObservable();
  
  sendMessage(message: string) {
    this.messageSubject.next(message);
  }
}

// Component A - sends messages
@Component({})
export class SenderComponent {
  constructor(private messageService: MessageService) {}
  
  sendMessage() {
    this.messageService.sendMessage('Hello from Component A!');
  }
}

// Component B - receives messages
@Component({})
export class ReceiverComponent implements OnInit {
  constructor(private messageService: MessageService) {}
  
  ngOnInit() {
    this.messageService.messages$.subscribe(message => {
      console.log('Received:', message);
    });
  }
}
```

**2. State Management**
```typescript
@Injectable({
  providedIn: 'root'
})
export class UserStateService {
  private userSubject = new BehaviorSubject<User | null>(null);
  
  // Public observable
  user$ = this.userSubject.asObservable();
  
  // Current user getter
  get currentUser(): User | null {
    return this.userSubject.value;
  }
  
  setUser(user: User) {
    this.userSubject.next(user);
  }
  
  clearUser() {
    this.userSubject.next(null);
  }
  
  updateUser(updates: Partial<User>) {
    const currentUser = this.currentUser;
    if (currentUser) {
      this.userSubject.next({ ...currentUser, ...updates });
    }
  }
}
```

**3. Form State Management**
```typescript
@Injectable()
export class FormStateService {
  private formStateSubject = new BehaviorSubject({
    isValid: false,
    isDirty: false,
    errors: {}
  });
  
  formState$ = this.formStateSubject.asObservable();
  
  updateFormState(state: Partial<FormState>) {
    this.formStateSubject.next({
      ...this.formStateSubject.value,
      ...state
    });
  }
}
```

**4. Event Bus Pattern**
```typescript
interface AppEvent {
  type: string;
  payload?: any;
}

@Injectable({
  providedIn: 'root'
})
export class EventBusService {
  private eventSubject = new Subject<AppEvent>();
  
  events$ = this.eventSubject.asObservable();
  
  emit(event: AppEvent) {
    this.eventSubject.next(event);
  }
  
  // Typed event emitters
  emitUserLogin(user: User) {
    this.emit({ type: 'USER_LOGIN', payload: user });
  }
  
  emitUserLogout() {
    this.emit({ type: 'USER_LOGOUT' });
  }
  
  // Filtered event streams
  onUserEvents() {
    return this.events$.pipe(
      filter(event => event.type.startsWith('USER_'))
    );
  }
}
```

**5. Loading State Management**
```typescript
@Injectable()
export class LoadingService {
  private loadingSubject = new BehaviorSubject<boolean>(false);
  private loadingMap = new Map<string, boolean>();
  
  loading$ = this.loadingSubject.asObservable();
  
  setLoading(loading: boolean, operation?: string) {
    if (operation) {
      this.loadingMap.set(operation, loading);
      const anyLoading = Array.from(this.loadingMap.values()).some(Boolean);
      this.loadingSubject.next(anyLoading);
    } else {
      this.loadingSubject.next(loading);
    }
  }
  
  startLoading(operation: string) {
    this.setLoading(true, operation);
  }
  
  stopLoading(operation: string) {
    this.setLoading(false, operation);
  }
}
```

**Advanced Patterns:**

**1. Subject with Validation**
```typescript
class ValidatedSubject<T> extends Subject<T> {
  constructor(private validator: (value: T) => boolean) {
    super();
  }
  
  next(value: T) {
    if (this.validator(value)) {
      super.next(value);
    } else {
      console.warn('Invalid value rejected:', value);
    }
  }
}

const emailSubject = new ValidatedSubject<string>(
  email => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
);
```

**2. Subject with History**
```typescript
class HistorySubject<T> extends BehaviorSubject<T> {
  private history: T[] = [];
  
  constructor(initialValue: T) {
    super(initialValue);
    this.history.push(initialValue);
  }
  
  next(value: T) {
    this.history.push(value);
    super.next(value);
  }
  
  getHistory(): T[] {
    return [...this.history];
  }
  
  undo(): void {
    if (this.history.length > 1) {
      this.history.pop(); // Remove current
      const previous = this.history[this.history.length - 1];
      super.next(previous);
    }
  }
}
```

**When to Use Each Subject:**

| Subject Type | Use When |
|--------------|----------|
| **Subject** | Simple event broadcasting, no initial value needed |
| **BehaviorSubject** | State management, always need current value |
| **ReplaySubject** | Need to replay recent values to late subscribers |
| **AsyncSubject** | Only care about final result (like Promise) |

**Best Practices:**

**✅ DO:**
- Expose subjects as observables using `asObservable()`
- Use BehaviorSubject for state that has a current value
- Complete subjects in `ngOnDestroy`
- Use meaningful names (e.g., `userState$`, `messages$`)

**❌ DON'T:**
- Expose subjects directly (breaks encapsulation)
- Forget to complete subjects (memory leaks)
- Use subjects when simple observables would work
- Create subjects without considering their lifecycle

```typescript
// ❌ Bad - Exposing subject directly
export class BadService {
  userSubject = new BehaviorSubject<User>(null);
}

// ✅ Good - Encapsulated subject
export class GoodService {
  private userSubject = new BehaviorSubject<User>(null);
  user$ = this.userSubject.asObservable();
  
  setUser(user: User) {
    this.userSubject.next(user);
  }
}
```

[Back to RxJS and Observables](#rxjs-and-observables)

### 37. Explain hot vs cold Observables

**Answer:**
The distinction between hot and cold observables is fundamental to understanding RxJS behavior. It determines when and how observables execute and share data among subscribers.

**Cold Observables (Unicast)**

Cold observables create a new execution path for each subscriber. They are lazy and don't start producing values until subscribed to.

**Characteristics:**
- **Lazy execution** - Only run when subscribed
- **Unicast** - Each subscriber gets its own execution
- **Independent** - Subscribers don't share data
- **Repeatable** - Each subscription starts from the beginning

```typescript
// Cold Observable example
const coldObservable = new Observable(observer => {
  console.log('Observable execution started');
  
  let count = 0;
  const interval = setInterval(() => {
    observer.next(count++);
  }, 1000);
  
  // Cleanup function
  return () => {
    console.log('Observable execution stopped');
    clearInterval(interval);
  };
});

// First subscriber
coldObservable.subscribe(value => console.log('Sub 1:', value));
// Logs: "Observable execution started"
// Logs: "Sub 1: 0", "Sub 1: 1", "Sub 1: 2"...

// Second subscriber (after 3 seconds)
setTimeout(() => {
  coldObservable.subscribe(value => console.log('Sub 2:', value));
  // Logs: "Observable execution started" (again!)
  // Logs: "Sub 2: 0", "Sub 2: 1", "Sub 2: 2"... (starts from 0)
}, 3000);
```

**Hot Observables (Multicast)**

Hot observables share a single execution path among all subscribers. They produce values regardless of subscriptions.

**Characteristics:**
- **Eager execution** - Run regardless of subscribers
- **Multicast** - All subscribers share the same execution
- **Shared data** - Subscribers receive the same values
- **Live** - Late subscribers miss earlier values

```typescript
// Hot Observable example using Subject
const hotObservable = new Subject<number>();

let count = 0;
const interval = setInterval(() => {
  hotObservable.next(count++);
}, 1000);

// First subscriber
hotObservable.subscribe(value => console.log('Sub 1:', value));
// Immediately starts receiving current values

// Second subscriber (after 3 seconds)
setTimeout(() => {
  hotObservable.subscribe(value => console.log('Sub 2:', value));
  // Starts receiving values from current point (misses earlier values)
}, 3000);
```

**Converting Cold to Hot:**

**1. Using share() Operator**
```typescript
import { share, interval } from 'rxjs';

// Cold observable
const coldTimer = interval(1000);

// Convert to hot
const hotTimer = coldTimer.pipe(share());

// All subscribers share the same execution
hotTimer.subscribe(value => console.log('Sub 1:', value));
setTimeout(() => {
  hotTimer.subscribe(value => console.log('Sub 2:', value));
}, 3000);
```

**2. Using shareReplay() Operator**
```typescript
import { shareReplay, interval } from 'rxjs';

// Hot with replay capability
const hotWithReplay = interval(1000).pipe(
  shareReplay(3) // Replay last 3 values to new subscribers
);

hotWithReplay.subscribe(value => console.log('Sub 1:', value));

// Late subscriber gets last 3 values immediately
setTimeout(() => {
  hotWithReplay.subscribe(value => console.log('Sub 2:', value));
}, 5000);
```

**3. Using publish() and connect()**
```typescript
import { publish, interval } from 'rxjs';

const source = interval(1000).pipe(publish());

// Subscribe before connecting
source.subscribe(value => console.log('Sub 1:', value));
source.subscribe(value => console.log('Sub 2:', value));

// Start the execution
const connection = source.connect();

// Later, disconnect
setTimeout(() => connection.unsubscribe(), 10000);
```

**Real-World Examples:**

**Cold Observable Examples:**
```typescript
// HTTP requests (each subscription makes a new request)
const userData = this.http.get<User>('/api/user/1');

userData.subscribe(user => console.log('Sub 1:', user));
userData.subscribe(user => console.log('Sub 2:', user)); // Makes another HTTP request!

// File reading
const fileContent = new Observable(observer => {
  fs.readFile('data.txt', (err, data) => {
    if (err) observer.error(err);
    else observer.next(data);
    observer.complete();
  });
});

// Timer/Interval
const timer = interval(1000);
```

**Hot Observable Examples:**
```typescript
// DOM events
const clicks = fromEvent(document, 'click');

// WebSocket connections
const webSocketData = new Observable(observer => {
  const ws = new WebSocket('ws://localhost:8080');
  ws.onmessage = event => observer.next(event.data);
  return () => ws.close();
}).pipe(share()); // Make it hot

// Subjects
const messageSubject = new Subject<string>();

// Browser events
const resize = fromEvent(window, 'resize');
```

**Practical Patterns:**

**1. Shared HTTP Requests**
```typescript
@Injectable()
export class UserService {
  private userCache$ = this.http.get<User[]>('/api/users').pipe(
    shareReplay(1) // Cache the result, share among subscribers
  );
  
  getUsers() {
    return this.userCache$; // All subscribers get cached result
  }
}
```

**2. Real-time Data Service**
```typescript
@Injectable()
export class RealtimeService {
  private socket = new WebSocket('ws://localhost:8080');
  
  // Hot observable for real-time data
  data$ = new Observable(observer => {
    this.socket.onmessage = event => observer.next(JSON.parse(event.data));
    this.socket.onerror = error => observer.error(error);
    
    return () => this.socket.close();
  }).pipe(
    share() // Make it hot - all subscribers share the same WebSocket
  );
}
```

**3. Component Communication**
```typescript
@Injectable()
export class NotificationService {
  private notificationSubject = new Subject<Notification>();
  
  // Hot observable - all components get the same notifications
  notifications$ = this.notificationSubject.asObservable();
  
  notify(message: string) {
    this.notificationSubject.next({ message, timestamp: Date.now() });
  }
}
```

**Performance Implications:**

**Cold Observables:**
```typescript
// ❌ Problem: Multiple HTTP requests
const userData$ = this.http.get<User>('/api/user');

// Each subscription makes a separate HTTP request
userData$.subscribe(user => this.updateProfile(user));
userData$.subscribe(user => this.updatePermissions(user));
userData$.subscribe(user => this.logActivity(user));

// ✅ Solution: Make it hot
const sharedUserData$ = this.http.get<User>('/api/user').pipe(
  shareReplay(1)
);

// Only one HTTP request, result shared
sharedUserData$.subscribe(user => this.updateProfile(user));
sharedUserData$.subscribe(user => this.updatePermissions(user));
sharedUserData$.subscribe(user => this.logActivity(user));
```

**Testing Hot vs Cold:**

```typescript
describe('Hot vs Cold Observables', () => {
  it('should demonstrate cold observable behavior', () => {
    let executionCount = 0;
    
    const cold$ = new Observable(observer => {
      executionCount++;
      observer.next(executionCount);
    });
    
    cold$.subscribe(value => expect(value).toBe(1));
    cold$.subscribe(value => expect(value).toBe(2)); // New execution
  });
  
  it('should demonstrate hot observable behavior', () => {
    let executionCount = 0;
    
    const hot$ = new Observable(observer => {
      executionCount++;
      observer.next(executionCount);
    }).pipe(share());
    
    hot$.subscribe(value => expect(value).toBe(1));
    hot$.subscribe(value => expect(value).toBe(1)); // Shared execution
  });
});
```

**Decision Matrix:**

| Use Case | Observable Type | Reason |
|----------|-----------------|--------|
| HTTP requests (one-time) | Cold | Each subscriber should get fresh data |
| HTTP requests (cacheable) | Hot (shareReplay) | Share cached result |
| DOM events | Hot | Events happen regardless of subscribers |
| WebSocket data | Hot | Real-time data should be shared |
| File operations | Cold | Each subscriber should trigger operation |
| User interactions | Hot | Events should be shared across components |
| Timers/Intervals | Depends | Cold for independent timers, Hot for shared |

**Best Practices:**

1. **Default to cold** for most observables
2. **Use hot for shared resources** (WebSockets, events)
3. **Cache expensive operations** with `shareReplay()`
4. **Be explicit** about hot/cold behavior in service APIs
5. **Test both scenarios** in your applications
6. **Document** whether your observables are hot or cold
7. **Use marble testing** to verify behavior

[Back to RxJS and Observables](#rxjs-and-observables)

### 38. How do you combine multiple Observables?

**Answer:**
RxJS provides several operators to combine multiple observables, each with different behaviors for handling timing, completion, and error scenarios.

**1. combineLatest - Wait for All, Emit on Any Change**

```typescript
import { combineLatest } from 'rxjs';

// Emits when ANY source observable emits (after all have emitted at least once)
const user$ = this.userService.getCurrentUser();
const settings$ = this.settingsService.getSettings();
const permissions$ = this.permissionService.getPermissions();

// Combine into view model
const viewModel$ = combineLatest({
  user: user$,
  settings: settings$,
  permissions: permissions$
});

viewModel$.subscribe(({ user, settings, permissions }) => {
  console.log('User:', user);
  console.log('Settings:', settings);
  console.log('Permissions:', permissions);
});
```

**2. merge - Emit from Any Source**

```typescript
import { merge } from 'rxjs';

// Emits whenever ANY source observable emits
const clicks$ = fromEvent(button, 'click');
const keypress$ = fromEvent(document, 'keypress');
const touchstart$ = fromEvent(document, 'touchstart');

const userInteractions$ = merge(clicks$, keypress$, touchstart$);

userInteractions$.subscribe(event => {
  console.log('User interaction:', event.type);
});
```

**3. forkJoin - Parallel Execution, Wait for All**

```typescript
import { forkJoin } from 'rxjs';

// Waits for ALL observables to complete, then emits final values
const dashboardData$ = forkJoin({
  user: this.userService.getCurrentUser(),
  notifications: this.notificationService.getNotifications(),
  stats: this.analyticsService.getStats(),
  settings: this.settingsService.getSettings()
});

dashboardData$.subscribe(({ user, notifications, stats, settings }) => {
  this.initializeDashboard(user, notifications, stats, settings);
});
```

**Best Practices:**

1. **Choose the right operator** based on your timing needs
2. **Handle errors individually** in each stream when needed
3. **Use type-safe combinations** with TypeScript interfaces
4. **Consider performance** - avoid unnecessary combinations
5. **Test edge cases** like empty streams and errors

[Back to RxJS and Observables](#rxjs-and-observables)

### 39. How to multicast with `shareReplay` safely?

**Answer:**
`shareReplay` is a powerful operator for multicasting observables and caching their emissions, but it requires careful consideration to avoid memory leaks and unexpected behavior.

**Basic shareReplay Usage:**

```typescript
import { shareReplay } from 'rxjs/operators';

// Basic usage - replay last 1 value
const sharedData$ = this.http.get<User[]>('/api/users').pipe(
  shareReplay(1) // Cache and replay last 1 emission
);

// Multiple subscribers get cached result
sharedData$.subscribe(users => console.log('Sub 1:', users.length));
sharedData$.subscribe(users => console.log('Sub 2:', users.length)); // No new HTTP request!
```

**Safe Patterns:**

**1. With refCount for Automatic Cleanup**
```typescript
// ✅ Safe - automatically unsubscribes when no subscribers
const safeSharedData$ = this.http.get<User[]>('/api/users').pipe(
  shareReplay({ bufferSize: 1, refCount: true })
);
```

**2. Service-Level Implementation**
```typescript
@Injectable({
  providedIn: 'root'
})
export class UserService {
  private users$?: Observable<User[]>;
  
  getUsers(): Observable<User[]> {
    if (!this.users$) {
      this.users$ = this.http.get<User[]>('/api/users').pipe(
        shareReplay({ bufferSize: 1, refCount: true }),
        catchError(error => {
          this.users$ = undefined; // Reset cache
          return throwError(() => error);
        })
      );
    }
    return this.users$;
  }
}
```

**Common Pitfalls:**

```typescript
// ❌ Dangerous - can cause memory leaks
const leakyData$ = this.http.get('/api/data').pipe(
  shareReplay(1) // No refCount = subscription never ends
);

// ✅ Safe - with refCount
const safeData$ = this.http.get('/api/data').pipe(
  shareReplay({ bufferSize: 1, refCount: true })
);
```

**Additional Real-World Examples:**

**1. User Profile Service with Smart Caching:**
```typescript
@Injectable({
  providedIn: 'root'
})
export class UserProfileService {
  private profileCache$ = new Map<number, Observable<UserProfile>>();
  
  getUserProfile(userId: number): Observable<UserProfile> {
    if (!this.profileCache$.has(userId)) {
      const profile$ = this.http.get<UserProfile>(`/api/users/${userId}/profile`).pipe(
        shareReplay({ bufferSize: 1, refCount: true }),
        catchError(error => {
          // Remove from cache on error to allow retry
          this.profileCache$.delete(userId);
          return throwError(() => error);
        })
      );
      
      this.profileCache$.set(userId, profile$);
    }
    
    return this.profileCache$.get(userId)!;
  }
  
  // Method to invalidate specific user's cache
  invalidateUserProfile(userId: number) {
    this.profileCache$.delete(userId);
  }
  
  // Clear all cached profiles
  clearAllProfiles() {
    this.profileCache$.clear();
  }
}

// Usage in component
@Component({
  template: `
    <div *ngIf="userProfile$ | async as profile">
      <h2>{{ profile.name }}</h2>
      <p>{{ profile.email }}</p>
      <button (click)="refreshProfile()">Refresh</button>
    </div>
  `
})
export class UserProfileComponent {
  @Input() userId!: number;
  
  userProfile$ = this.userProfileService.getUserProfile(this.userId);
  
  constructor(private userProfileService: UserProfileService) {}
  
  refreshProfile() {
    this.userProfileService.invalidateUserProfile(this.userId);
    this.userProfile$ = this.userProfileService.getUserProfile(this.userId);
  }
}
```

**2. Configuration Service with Auto-Refresh:**
```typescript
@Injectable({
  providedIn: 'root'
})
export class ConfigService {
  private configRefresh$ = new BehaviorSubject<void>(undefined);
  
  // Auto-refreshing config that updates every 5 minutes
  config$ = this.configRefresh$.pipe(
    switchMap(() => this.http.get<AppConfig>('/api/config')),
    shareReplay({ bufferSize: 1, refCount: true }),
    catchError(error => {
      console.error('Config load failed:', error);
      return of(this.getDefaultConfig());
    })
  );
  
  constructor() {
    // Auto-refresh every 5 minutes
    timer(0, 5 * 60 * 1000).subscribe(() => {
      this.refreshConfig();
    });
  }
  
  refreshConfig() {
    this.configRefresh$.next();
  }
  
  private getDefaultConfig(): AppConfig {
    return {
      apiUrl: '/api',
      timeout: 30000,
      retryAttempts: 3
    };
  }
}

// Usage across multiple components
@Component({})
export class HeaderComponent {
  appTitle$ = this.configService.config$.pipe(
    map(config => config.appTitle)
  );
  
  constructor(private configService: ConfigService) {}
}

@Component({})
export class ApiService {
  constructor(private configService: ConfigService) {
    // All components share the same config observable
    this.configService.config$.subscribe(config => {
      this.setupApiClient(config);
    });
  }
}
```

**3. Shopping Cart with Optimistic Updates:**
```typescript
@Injectable({
  providedIn: 'root'
})
export class ShoppingCartService {
  private cartSubject = new BehaviorSubject<CartItem[]>([]);
  private cartUpdates$ = new Subject<CartOperation>();
  
  // Optimistic cart updates with server sync
  cart$ = merge(
    this.loadCartFromServer(),
    this.cartUpdates$.pipe(
      scan((cart, operation) => this.applyOperation(cart, operation), [])
    )
  ).pipe(
    shareReplay({ bufferSize: 1, refCount: true }),
    tap(cart => this.syncToServer(cart))
  );
  
  addItem(item: CartItem) {
    this.cartUpdates$.next({ type: 'ADD', item });
  }
  
  removeItem(itemId: string) {
    this.cartUpdates$.next({ type: 'REMOVE', itemId });
  }
  
  updateQuantity(itemId: string, quantity: number) {
    this.cartUpdates$.next({ type: 'UPDATE', itemId, quantity });
  }
  
  private loadCartFromServer(): Observable<CartItem[]> {
    return this.http.get<CartItem[]>('/api/cart').pipe(
      catchError(() => of([])) // Fallback to empty cart
    );
  }
  
  private applyOperation(cart: CartItem[], operation: CartOperation): CartItem[] {
    switch (operation.type) {
      case 'ADD':
        return [...cart, operation.item];
      case 'REMOVE':
        return cart.filter(item => item.id !== operation.itemId);
      case 'UPDATE':
        return cart.map(item => 
          item.id === operation.itemId 
            ? { ...item, quantity: operation.quantity }
            : item
        );
      default:
        return cart;
    }
  }
  
  private syncToServer(cart: CartItem[]) {
    // Debounce server sync to avoid too many requests
    timer(1000).pipe(
      switchMap(() => this.http.put('/api/cart', cart)),
      catchError(error => {
        console.error('Cart sync failed:', error);
        return of(null);
      })
    ).subscribe();
  }
}

// Multiple components can observe the same cart
@Component({
  template: `
    <div class="cart-summary">
      Items: {{ (cart$ | async)?.length || 0 }}
      Total: {{ cartTotal$ | async | currency }}
    </div>
  `
})
export class CartSummaryComponent {
  cart$ = this.cartService.cart$;
  cartTotal$ = this.cart$.pipe(
    map(items => items.reduce((total, item) => total + item.price * item.quantity, 0))
  );
  
  constructor(private cartService: ShoppingCartService) {}
}

@Component({
  template: `
    <div *ngFor="let item of cart$ | async" class="cart-item">
      {{ item.name }} - {{ item.quantity }}
      <button (click)="removeItem(item.id)">Remove</button>
    </div>
  `
})
export class CartListComponent {
  cart$ = this.cartService.cart$; // Same observable, shared cache
  
  constructor(private cartService: ShoppingCartService) {}
  
  removeItem(itemId: string) {
    this.cartService.removeItem(itemId);
  }
}
```

**Best Practices:**

1. **Always use refCount: true** unless you have a specific reason not to
2. **Handle errors before shareReplay** to avoid caching errors
3. **Implement cache invalidation** strategies for dynamic data
4. **Use time windows** for data that becomes stale
5. **Test cache behavior** thoroughly
6. **Consider memory usage** with large datasets
7. **Use finalize()** for cleanup when subscriptions end
8. **Monitor cache hit rates** in production
9. **Implement smart refresh strategies** for real-time data
10. **Document caching behavior** for team understanding

[Back to RxJS and Observables](#rxjs-and-observables)

### 40. How do you prevent RxJS memory leaks in components/services?

**Answer:**
Preventing RxJS memory leaks is crucial for Angular application performance. Here are the most effective strategies:

**1. takeUntilDestroyed (Angular 16+)**
```typescript
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

@Component({})
export class ModernComponent {
  ngOnInit() {
    this.userService.getUsers().pipe(
      takeUntilDestroyed() // Automatically unsubscribes on destroy
    ).subscribe(users => this.users = users);
  }
}
```

**2. takeUntil Pattern**
```typescript
@Component({})
export class SafeComponent implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();
  
  ngOnInit() {
    this.userService.getUsers().pipe(
      takeUntil(this.destroy$)
    ).subscribe(users => this.users = users);
  }
  
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

**3. Async Pipe (Automatic Management)**
```typescript
@Component({
  template: `<div *ngFor="let user of users$ | async">{{ user.name }}</div>`
})
export class AsyncComponent {
  users$ = this.userService.getUsers(); // No manual subscription needed
}
```

**Best Practices:**
- Use async pipe when possible
- Always unsubscribe from long-lived observables
- Use takeUntilDestroyed() in modern Angular
- Implement proper cleanup in services

[Back to RxJS and Observables](#rxjs-and-observables)

### 41. What are the different types of Subjects (BehaviorSubject, ReplaySubject)?

**Answer:**
Subjects are special observables that can multicast and act as both observer and observable. Each type has specific use cases:

**1. Subject (Basic)**
```typescript
const messageSubject = new Subject<string>();

// No initial value, no replay
messageSubject.subscribe(msg => console.log('Sub 1:', msg));
messageSubject.next('Hello'); // Only current subscribers receive this
```

**2. BehaviorSubject (Has Current Value)**
```typescript
const currentUser$ = new BehaviorSubject<User | null>(null);

// New subscribers immediately get current value
currentUser$.subscribe(user => console.log('Current user:', user)); // Logs: null
currentUser$.next({ id: 1, name: 'John' });

// Late subscriber gets current value immediately
currentUser$.subscribe(user => console.log('Late subscriber:', user)); // Logs: { id: 1, name: 'John' }
```

**3. ReplaySubject (Replays N Values)**
```typescript
const messageHistory$ = new ReplaySubject<string>(3); // Keep last 3 messages

messageHistory$.next('Message 1');
messageHistory$.next('Message 2');
messageHistory$.next('Message 3');

// New subscriber gets last 3 messages
messageHistory$.subscribe(msg => console.log('Replay:', msg));
```

**4. AsyncSubject (Only Last Value)**
```typescript
const result$ = new AsyncSubject<number>();

result$.next(1);
result$.next(2);
result$.next(3);
result$.complete(); // Now emits: 3 (only the last value)
```

**When to Use:**
- **Subject**: Simple event broadcasting
- **BehaviorSubject**: State management with current value
- **ReplaySubject**: Need to replay recent values
- **AsyncSubject**: Only care about final result

[Back to RxJS and Observables](#rxjs-and-observables)

### 42. How do you handle backpressure in RxJS?

**Answer:**
Backpressure occurs when observables emit values faster than subscribers can process them. RxJS provides several strategies to handle this:

**1. Throttling (Ignore Excess)**
```typescript
// throttleTime - Ignore emissions for specified time
const throttled$ = source$.pipe(
  throttleTime(1000) // Only emit once per second
);

// auditTime - Emit last value after silence period
const audited$ = source$.pipe(
  auditTime(1000) // Emit last value after 1 second of silence
);
```

**2. Debouncing (Wait for Quiet Period)**
```typescript
// debounceTime - Wait for quiet period before emitting
const debounced$ = searchInput$.pipe(
  debounceTime(300), // Wait 300ms after user stops typing
  switchMap(term => this.searchService.search(term))
);
```

**3. Sampling (Periodic Emission)**
```typescript
// sample - Emit latest value at intervals
const sampled$ = mouseMove$.pipe(
  sample(interval(100)) // Sample mouse position every 100ms
);

// sampleTime - Simpler time-based sampling
const sampledTime$ = mouseMove$.pipe(
  sampleTime(100) // Emit latest position every 100ms
);
```

**4. Buffering (Collect and Process in Batches)**
```typescript
// buffer - Collect until boundary emits
const buffered$ = clicks$.pipe(
  buffer(interval(1000)), // Collect clicks for 1 second
  filter(clicks => clicks.length > 0)
);

// bufferTime - Time-based buffering
const timedBuffer$ = events$.pipe(
  bufferTime(5000), // Collect events for 5 seconds
  filter(events => events.length > 0),
  mergeMap(events => this.processEvents(events))
);
```

**Real-World Example:**
```typescript
@Component({})
export class SearchComponent {
  searchControl = new FormControl('');
  
  results$ = this.searchControl.valueChanges.pipe(
    debounceTime(300),        // Wait for user to stop typing
    distinctUntilChanged(),   // Ignore duplicate values
    filter(term => term.length > 2), // Only search for 3+ characters
    switchMap(term => 
      this.searchService.search(term).pipe(
        catchError(() => of([])) // Handle errors gracefully
      )
    )
  );
}
```

**Best Practices:**
- Choose appropriate strategy based on use case
- Combine multiple strategies when needed
- Test with high-frequency data sources
- Monitor performance impact

[Back to RxJS and Observables](#rxjs-and-observables)

### 43. What is the difference between `subscribe` and `tap`?

**Answer:**
`subscribe` and `tap` serve different purposes in RxJS streams:

**subscribe - Terminal Operation**
```typescript
// subscribe() starts the observable execution and consumes values
const subscription = source$.subscribe({
  next: value => console.log('Received:', value),
  error: error => console.error('Error:', error),
  complete: () => console.log('Complete!')
});

// Must manually unsubscribe
subscription.unsubscribe();
```

**tap - Side Effect Operation**
```typescript
// tap() performs side effects without consuming the stream
const processed$ = source$.pipe(
  tap(value => console.log('Processing:', value)), // Side effect
  map(value => value * 2),
  tap(value => console.log('Processed:', value)),   // Another side effect
  filter(value => value > 10)
);

// Stream continues, subscription happens later
processed$.subscribe(result => console.log('Final:', result));
```

**Key Differences:**

| Feature | subscribe | tap |
|---------|-----------|-----|
| **Purpose** | Consume values | Side effects |
| **Returns** | Subscription | Observable |
| **Position** | End of chain | Anywhere in chain |
| **Chainable** | No | Yes |
| **Execution** | Starts observable | Doesn't start observable |

**Common Use Cases:**

**tap for Debugging:**
```typescript
const debugged$ = this.http.get('/api/data').pipe(
  tap(response => console.log('API Response:', response)),
  map(response => response.data),
  tap(data => console.log('Mapped Data:', data)),
  filter(data => data.length > 0),
  tap(filtered => console.log('Filtered Data:', filtered))
);
```

**tap for Side Effects:**
```typescript
const withSideEffects$ = userLogin$.pipe(
  tap(user => this.analyticsService.trackLogin(user.id)),
  tap(user => this.cacheService.setCurrentUser(user)),
  tap(user => this.notificationService.showWelcome(user.name))
);
```

**subscribe for Final Consumption:**
```typescript
withSideEffects$.subscribe({
  next: user => this.currentUser = user,
  error: error => this.handleLoginError(error)
});
```

**Best Practices:**
- Use `tap` for logging, debugging, and side effects
- Use `subscribe` only at the end of the chain
- Avoid business logic in `tap` - keep it for side effects
- Chain multiple `tap` operators for different concerns

[Back to RxJS and Observables](#rxjs-and-observables)

### 44. How do you test RxJS streams?

**Answer:**
Testing RxJS streams requires specific techniques to handle asynchronous behavior and timing:

**1. Marble Testing**
```typescript
import { TestScheduler } from 'rxjs/testing';

describe('RxJS Stream Tests', () => {
  let testScheduler: TestScheduler;
  
  beforeEach(() => {
    testScheduler = new TestScheduler((actual, expected) => {
      expect(actual).toEqual(expected);
    });
  });
  
  it('should debounce search input', () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const input$ = cold('a-b-c---d-e-f---|');
      const expected =    '--------c-------f---|';
      
      const result$ = input$.pipe(debounceTime(3));
      
      expectObservable(result$).toBe(expected);
    });
  });
});
```

**2. Synchronous Testing**
```typescript
it('should transform data correctly', () => {
  const source$ = of(1, 2, 3);
  const result$ = source$.pipe(
    map(x => x * 2),
    filter(x => x > 2)
  );
  
  const results: number[] = [];
  result$.subscribe(value => results.push(value));
  
  expect(results).toEqual([4, 6]);
});
```

**3. Async Testing with fakeAsync**
```typescript
import { fakeAsync, tick } from '@angular/core/testing';

it('should handle delayed emissions', fakeAsync(() => {
  const source$ = timer(1000).pipe(map(() => 'delayed'));
  let result: string | undefined;
  
  source$.subscribe(value => result = value);
  
  expect(result).toBeUndefined();
  
  tick(1000); // Advance time
  
  expect(result).toBe('delayed');
}));
```

**4. Testing Services with RxJS**
```typescript
describe('UserService', () => {
  let service: UserService;
  let httpMock: HttpTestingController;
  
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [UserService]
    });
    
    service = TestBed.inject(UserService);
    httpMock = TestBed.inject(HttpTestingController);
  });
  
  it('should fetch users', () => {
    const mockUsers = [{ id: 1, name: 'John' }];
    
    service.getUsers().subscribe(users => {
      expect(users).toEqual(mockUsers);
    });
    
    const req = httpMock.expectOne('/api/users');
    req.flush(mockUsers);
  });
});
```

**5. Testing Error Scenarios**
```typescript
it('should handle errors gracefully', () => {
  const errorResponse = new HttpErrorResponse({ status: 500 });
  
  service.getUsers().subscribe({
    next: () => fail('Should have failed'),
    error: (error) => expect(error.status).toBe(500)
  });
  
  const req = httpMock.expectOne('/api/users');
  req.error(new ErrorEvent('Server Error'), { status: 500 });
});
```

**Best Practices:**
- Use marble testing for complex timing scenarios
- Test both success and error cases
- Use fakeAsync for time-based operations
- Mock HTTP requests properly
- Test subscription cleanup

[Back to RxJS and Observables](#rxjs-and-observables)

### 45. What are marble diagrams and how to read them?

**Answer:**
Marble diagrams are a visual representation of observable sequences over time, used to understand and test RxJS operators. They show when values are emitted, when errors occur, and when streams complete.

**Basic Marble Syntax:**

```
Timeline:    --a-b-c-d-e-f-|
             │ │ │ │ │ │ │ │
             │ │ │ │ │ │ │ └─ Complete
             │ │ │ │ │ │ └─── Value 'f'
             │ │ │ │ │ └───── Value 'e'
             │ │ │ │ └─────── Value 'd'
             │ │ │ └───────── Value 'c'
             │ │ └─────────── Value 'b'
             │ └───────────── Value 'a'
             └─────────────── Time start
```

**Marble Symbols:**
- `-` = Time passing (no emission)
- `a`, `b`, `c` = Values emitted
- `|` = Completion
- `#` = Error
- `^` = Subscription point
- `!` = Unsubscription point
- `()` = Synchronous grouping

**Reading Marble Diagrams:**

**1. Simple Observable:**
```typescript
// Marble: --a--b--c--|
// Meaning: Emits 'a', then 'b', then 'c', then completes
const source$ = cold('--a--b--c--|');
```

**2. Error Case:**
```typescript
// Marble: --a--b--#
// Meaning: Emits 'a', then 'b', then errors
const source$ = cold('--a--b--#');
```

**3. Never Ending:**
```typescript
// Marble: --a--b--c--
// Meaning: Emits values but never completes
const source$ = cold('--a--b--c--');
```

**Operator Examples:**

**1. map Operator:**
```typescript
// Input:  --1--2--3--|
// Output: --2--4--6--|
const source$ = cold('--1--2--3--|');
const result$ = source$.pipe(map(x => x * 2));
expectObservable(result$).toBe('--2--4--6--|');
```

**2. filter Operator:**
```typescript
// Input:  --1--2--3--4--|
// Output: -----2-----4--|
const source$ = cold('--1--2--3--4--|');
const result$ = source$.pipe(filter(x => x % 2 === 0));
expectObservable(result$).toBe('-----2-----4--|');
```

**3. debounceTime Operator:**
```typescript
// Input:  --a-b-c---d-e-f---|
// Output: --------c-------f-|
const source$ = cold('--a-b-c---d-e-f---|');
const result$ = source$.pipe(debounceTime(3));
expectObservable(result$).toBe('--------c-------f-|');
```

**Complex Scenarios:**

**1. switchMap:**
```typescript
// Source:  --a----b----c-|
// Inner:   --1-2-3-|
// Result:  ----1-2-1-2-1-2-3-|
testScheduler.run(({ cold, expectObservable }) => {
  const source$ = cold('--a----b----c-|');
  const inner$ = cold('  --1-2-3-|');
  
  const result$ = source$.pipe(
    switchMap(() => inner$)
  );
  
  expectObservable(result$).toBe('----1-2-1-2-1-2-3-|');
});
```

**2. combineLatest:**
```typescript
// Source1: --a--b--c--|
// Source2: ----1--2-3-|
// Result:  ----ab-bc2c3|
const source1$ = cold('--a--b--c--|');
const source2$ = cold('----1--2-3-|');
const result$ = combineLatest([source1$, source2$]);
expectObservable(result$).toBe('----ab-bc2c3|', {
  ab: ['a', '1'],
  bc: ['b', '1'], 
  c2: ['c', '2'],
  c3: ['c', '3']
});
```

**Testing with Marble Diagrams:**

```typescript
import { TestScheduler } from 'rxjs/testing';

describe('Search Service', () => {
  let testScheduler: TestScheduler;
  
  beforeEach(() => {
    testScheduler = new TestScheduler((actual, expected) => {
      expect(actual).toEqual(expected);
    });
  });
  
  it('should debounce search input', () => {
    testScheduler.run(({ cold, expectObservable, flush }) => {
      // Arrange
      const input$ = cold('a-b-c---d-e-f---|');
      const expected =    '--------c-------f---|';
      
      // Act
      const result$ = input$.pipe(
        debounceTime(3),
        distinctUntilChanged()
      );
      
      // Assert
      expectObservable(result$).toBe(expected);
    });
  });
  
  it('should handle errors in search', () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const input$ = cold('--a--b--#');
      const expected =    '--------#';
      
      const result$ = input$.pipe(
        debounceTime(3),
        switchMap(term => throwError(() => new Error('Search failed')))
      );
      
      expectObservable(result$).toBe(expected);
    });
  });
});
```

**Advanced Marble Features:**

**1. Synchronous Grouping:**
```typescript
// (abc) means a, b, c are emitted synchronously
const source$ = cold('--(abc)--d-|');
// Time 0: nothing
// Time 2: a, b, c all at once
// Time 8: d
// Time 10: complete
```

**2. Subscription Tracking:**
```typescript
// ^     = subscription starts
// !     = subscription ends
const source$ = cold('--a--b--c--d--e--|');
const subs =         '^------!';        // Subscribe at 0, unsubscribe at 7
const expected =     '--a--b--c-';      // Only see values until unsubscribe
```

**3. Hot vs Cold Observables:**
```typescript
// Cold (each subscription starts from beginning)
const cold$ = cold('--a--b--c--|');

// Hot (shared execution)
const hot$ = hot('--a--b--c--|');
```

**Real-World Testing Example:**

```typescript
describe('User Search Component', () => {
  it('should search users with debounce and distinctUntilChanged', () => {
    testScheduler.run(({ cold, expectObservable, flush }) => {
      // User types: 'a', 'ab', 'abc', pauses, types 'abc' again, then 'abcd'
      const input$ = cold('a-b-c---c---d|');
      const expected =    '--------c-------d|';
      
      const result$ = input$.pipe(
        debounceTime(3),
        distinctUntilChanged(),
        switchMap(term => of(`results for ${term}`))
      );
      
      expectObservable(result$).toBe(expected, {
        c: 'results for c',
        d: 'results for d'
      });
    });
  });
});
```

**Best Practices:**

1. **Start simple** - Begin with basic marble patterns
2. **Use meaningful values** - Use descriptive characters (a, b, c or user, admin, etc.)
3. **Test edge cases** - Empty streams, errors, immediate completion
4. **Group related tests** - Test operator behavior systematically
5. **Document complex scenarios** - Explain what the marble diagram represents
6. **Use expectObservable** for assertions
7. **Test subscription timing** with ^ and ! markers

**Common Patterns:**
- `--|` = Empty and complete
- `#` = Error immediately  
- `--` = Never emits, never completes
- `-a-|` = Emit one value then complete
- `(abc)|` = Emit multiple values synchronously then complete

[Back to RxJS and Observables](#rxjs-and-observables)

### 46. What are Angular Signals and how do they work?

**Answer:**
Angular Signals are a **reactive primitive** introduced in Angular 16+ that provides a new way to manage state and trigger change detection. Signals offer a more predictable and performant alternative to traditional change detection.

**Core Concepts:**

**1. Signal Creation:**
```typescript
import { signal, computed, effect } from '@angular/core';

@Component({
  selector: 'app-signals',
  template: `
    <div>Count: {{count()}}</div>
    <div>Double: {{doubleCount()}}</div>
    <button (click)="increment()">+</button>
  `
})
export class SignalsComponent {
  // Writable signal
  count = signal(0);
  
  // Computed signal (readonly, derived)
  doubleCount = computed(() => this.count() * 2);
  
  // Effect (side effects)
  constructor() {
    effect(() => {
      console.log('Count changed:', this.count());
    });
  }
  
  increment() {
    this.count.update(value => value + 1);
    // or: this.count.set(this.count() + 1);
  }
}
```

**2. Signal Types:**

**Writable Signals:**
```typescript
const counter = signal(0);
const user = signal<User>({ name: 'John', age: 30 });

// Update methods
counter.set(5);                    // Set absolute value
counter.update(val => val + 1);    // Update based on current value
user.update(u => ({ ...u, age: 31 })); // Immutable update
```

**Computed Signals:**
```typescript
const firstName = signal('John');
const lastName = signal('Doe');

// Automatically updates when dependencies change
const fullName = computed(() => `${firstName()} ${lastName()}`);

// Complex computations
const expensiveComputation = computed(() => {
  return heavyCalculation(firstName(), lastName());
});
```

**3. How Signals Work:**

**Reactive Graph:**
- Signals create a **dependency graph**
- When a signal changes, all dependents are **automatically notified**
- **Lazy evaluation** - computed signals only recalculate when accessed
- **Memoization** - results are cached until dependencies change

**Change Detection Integration:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `<div>{{count()}}</div>` // Automatically triggers change detection
})
export class OptimizedComponent {
  count = signal(0);
  
  // Signal changes automatically mark component for check
  increment() {
    this.count.update(val => val + 1); // Triggers change detection
  }
}
```

**4. Effects:**
```typescript
@Component({})
export class EffectComponent {
  searchQuery = signal('');
  results = signal<any[]>([]);
  
  constructor() {
    // Effect runs when searchQuery changes
    effect(() => {
      const query = this.searchQuery();
      if (query) {
        this.searchService.search(query).subscribe(results => {
          this.results.set(results);
        });
      }
    });
  }
}
```

**5. Signal Equality:**
```typescript
const user = signal({ name: 'John' });

// Reference equality by default
user.set({ name: 'John' }); // Triggers change (new object)

// Custom equality function
const customSignal = signal(
  { name: 'John' },
  { equal: (a, b) => a.name === b.name }
);
customSignal.set({ name: 'John' }); // No change (same name)
```

**Benefits:**
- **Fine-grained reactivity** - only affected components update
- **Better performance** - no zone.js overhead
- **Predictable updates** - explicit dependency tracking
- **Developer experience** - easier debugging and reasoning

[Back to Signals (Angular 16+)](#signals-angular-16)

### 47. Signals vs Observables: when to use each?

**Answer:**
Understanding when to use **Signals** vs **Observables** is crucial for building efficient Angular applications. Both serve different purposes and excel in different scenarios.

**Key Differences:**

| Aspect | Signals | Observables |
|--------|---------|-------------|
| **Nature** | Synchronous, always has current value | Asynchronous streams over time |
| **Evaluation** | Pull-based (lazy) | Push-based (reactive) |
| **Memory** | Lightweight, automatic cleanup | Manual subscription management |
| **Time** | Current state snapshot | Events over time |
| **Complexity** | Simple state management | Complex async operations |

**When to Use Signals:**

**1. Component State Management:**
```typescript
@Component({
  template: `
    <div>Count: {{count()}}</div>
    <div>Is Even: {{isEven()}}</div>
    <button (click)="increment()">+</button>
  `
})
export class CounterComponent {
  // ✅ Perfect for simple state
  count = signal(0);
  isEven = computed(() => this.count() % 2 === 0);
  
  increment() {
    this.count.update(val => val + 1);
  }
}
```

**2. Derived/Computed Values:**
```typescript
export class UserProfileComponent {
  firstName = signal('John');
  lastName = signal('Doe');
  
  // ✅ Automatically updates when dependencies change
  fullName = computed(() => `${this.firstName()} ${this.lastName()}`);
  initials = computed(() => `${this.firstName()[0]}${this.lastName()[0]}`);
}
```

**3. Form State:**
```typescript
export class FormComponent {
  email = signal('');
  password = signal('');
  
  // ✅ Reactive validation
  isEmailValid = computed(() => this.email().includes('@'));
  isFormValid = computed(() => this.isEmailValid() && this.password().length >= 8);
}
```

**4. UI State (toggles, flags):**
```typescript
export class UIComponent {
  isLoading = signal(false);
  isModalOpen = signal(false);
  selectedTab = signal('home');
  
  // ✅ Simple boolean/string state management
  toggleModal() {
    this.isModalOpen.update(open => !open);
  }
}
```

**When to Use Observables:**

**1. HTTP Requests:**
```typescript
@Injectable()
export class UserService {
  constructor(private http: HttpClient) {}
  
  // ✅ Async operations over time
  getUsers(): Observable<User[]> {
    return this.http.get<User[]>('/api/users');
  }
  
  searchUsers(query: string): Observable<User[]> {
    return this.http.get<User[]>(`/api/users/search?q=${query}`);
  }
}
```

**2. Event Streams:**
```typescript
@Component({})
export class SearchComponent {
  private searchInput = new Subject<string>();
  
  // ✅ Debounced search with complex operators
  searchResults$ = this.searchInput.pipe(
    debounceTime(300),
    distinctUntilChanged(),
    switchMap(query => this.userService.searchUsers(query)),
    catchError(error => of([]))
  );
  
  onSearch(query: string) {
    this.searchInput.next(query);
  }
}
```

**3. WebSocket/Real-time Data:**
```typescript
@Injectable()
export class WebSocketService {
  private socket$ = new WebSocketSubject('ws://localhost:8080');
  
  // ✅ Continuous data streams
  messages$ = this.socket$.asObservable();
  
  sendMessage(message: string) {
    this.socket$.next(message);
  }
}
```

**4. Complex Async Flows:**
```typescript
@Component({})
export class ComplexFlowComponent {
  // ✅ Multi-step async operations
  processOrder$ = this.orderService.createOrder(this.order).pipe(
    switchMap(order => this.paymentService.processPayment(order.id)),
    switchMap(payment => this.inventoryService.updateStock(payment.orderId)),
    switchMap(inventory => this.emailService.sendConfirmation(inventory.orderId)),
    catchError(error => this.handleError(error))
  );
}
```

**Hybrid Approaches:**

**1. Signal + Observable for HTTP:**
```typescript
export class DataComponent {
  private refreshTrigger = signal(0);
  
  // Convert signal to observable for HTTP
  data$ = toObservable(this.refreshTrigger).pipe(
    switchMap(() => this.dataService.getData())
  );
  
  refresh() {
    this.refreshTrigger.update(val => val + 1);
  }
}
```

**2. Observable + Signal for State:**
```typescript
export class HybridComponent {
  private dataSignal = signal<User[]>([]);
  
  constructor() {
    // Observable for HTTP, Signal for state
    this.userService.getUsers().subscribe(users => {
      this.dataSignal.set(users);
    });
  }
  
  // Use signal for template
  users = this.dataSignal.asReadonly();
}
```

**3. Effect for Side Effects:**
```typescript
export class EffectComponent {
  searchQuery = signal('');
  results = signal<any[]>([]);
  
  constructor() {
    // Signal triggers observable
    effect(() => {
      const query = this.searchQuery();
      if (query) {
        this.searchService.search(query).subscribe(results => {
          this.results.set(results);
        });
      }
    });
  }
}
```

**Decision Matrix:**

**Choose Signals When:**
- ✅ Managing **component state**
- ✅ **Synchronous** computations
- ✅ **Simple** reactive patterns
- ✅ **Performance** is critical
- ✅ **Current value** is important
- ✅ Working with **forms** and **UI state**

**Choose Observables When:**
- ✅ **HTTP requests** and **API calls**
- ✅ **Event streams** over time
- ✅ **Complex async** operations
- ✅ Need **operators** (debounce, retry, etc.)
- ✅ **WebSocket** or **real-time** data
- ✅ **Multi-step** async workflows

**Migration Strategy:**
```typescript
// Phase 1: Start with Observables for async, Signals for state
// Phase 2: Gradually convert simple state to Signals
// Phase 3: Use hybrid approaches where beneficial
// Phase 4: Keep Observables for complex async patterns
```

[Back to Signals (Angular 16+)](#signals-angular-16)

### 48. How do you create computed signals?

**Answer:**
**Computed signals** are readonly signals that derive their value from other signals. They automatically recalculate when their dependencies change and are memoized for performance.

**Basic Computed Signal Creation:**

**1. Simple Computed Signals:**
```typescript
import { signal, computed } from '@angular/core';

@Component({
  template: `
    <div>First: {{firstName()}}</div>
    <div>Last: {{lastName()}}</div>
    <div>Full: {{fullName()}}</div>
    <div>Initials: {{initials()}}</div>
  `
})
export class UserComponent {
  firstName = signal('John');
  lastName = signal('Doe');
  
  // ✅ Computed signal - automatically updates
  fullName = computed(() => `${this.firstName()} ${this.lastName()}`);
  
  // ✅ Another computed based on the same dependencies
  initials = computed(() => `${this.firstName()[0]}.${this.lastName()[0]}.`);
}
```

**2. Complex Computations:**
```typescript
export class ShoppingCartComponent {
  items = signal<CartItem[]>([
    { id: 1, name: 'Book', price: 25, quantity: 2 },
    { id: 2, name: 'Pen', price: 5, quantity: 3 }
  ]);
  
  taxRate = signal(0.08);
  discountPercent = signal(10);
  
  // ✅ Multi-step computation
  subtotal = computed(() => {
    return this.items().reduce((sum, item) => sum + (item.price * item.quantity), 0);
  });
  
  discount = computed(() => {
    return this.subtotal() * (this.discountPercent() / 100);
  });
  
  taxAmount = computed(() => {
    return (this.subtotal() - this.discount()) * this.taxRate();
  });
  
  total = computed(() => {
    return this.subtotal() - this.discount() + this.taxAmount();
  });
  
  // ✅ Conditional computation
  freeShipping = computed(() => this.subtotal() > 50);
  
  shippingCost = computed(() => {
    return this.freeShipping() ? 0 : 9.99;
  });
  
  finalTotal = computed(() => this.total() + this.shippingCost());
}
```

**3. Computed with Multiple Dependencies:**
```typescript
export class WeatherComponent {
  temperature = signal(25);
  humidity = signal(60);
  windSpeed = signal(10);
  
  // ✅ Computed using multiple signals
  heatIndex = computed(() => {
    const temp = this.temperature();
    const humid = this.humidity();
    
    if (temp < 80) return temp;
    
    // Complex heat index calculation
    return -42.379 + 2.04901523 * temp + 10.14333127 * humid - 
           0.22475541 * temp * humid;
  });
  
  // ✅ Computed with conditional logic
  weatherCondition = computed(() => {
    const temp = this.temperature();
    const humid = this.humidity();
    const wind = this.windSpeed();
    
    if (temp > 30 && humid > 70) return 'Hot & Humid';
    if (temp < 10 && wind > 20) return 'Cold & Windy';
    if (temp > 25 && wind < 5) return 'Warm & Calm';
    return 'Moderate';
  });
}
```

**4. Nested Computed Signals:**
```typescript
export class AnalyticsComponent {
  rawData = signal<DataPoint[]>([]);
  
  // ✅ First level computation
  validData = computed(() => {
    return this.rawData().filter(point => point.value !== null);
  });
  
  // ✅ Computed based on another computed
  average = computed(() => {
    const data = this.validData();
    if (data.length === 0) return 0;
    return data.reduce((sum, point) => sum + point.value, 0) / data.length;
  });
  
  // ✅ Further nesting
  deviation = computed(() => {
    const data = this.validData();
    const avg = this.average();
    
    if (data.length === 0) return 0;
    
    const variance = data.reduce((sum, point) => 
      sum + Math.pow(point.value - avg, 2), 0) / data.length;
    
    return Math.sqrt(variance);
  });
  
  // ✅ Classification based on statistics
  dataQuality = computed(() => {
    const dev = this.deviation();
    const avg = this.average();
    
    if (dev / avg < 0.1) return 'Excellent';
    if (dev / avg < 0.3) return 'Good';
    if (dev / avg < 0.5) return 'Fair';
    return 'Poor';
  });
}
```

**5. Computed with External Dependencies:**
```typescript
@Injectable()
export class ConfigService {
  private config = signal({ theme: 'light', language: 'en' });
  
  theme = computed(() => this.config().theme);
  language = computed(() => this.config().language);
}

@Component({})
export class ThemedComponent {
  private configService = inject(ConfigService);
  
  // ✅ Computed using injected service
  cssClasses = computed(() => {
    const theme = this.configService.theme();
    return `theme-${theme} ${theme === 'dark' ? 'dark-mode' : 'light-mode'}`;
  });
}
```

**6. Computed with Async Data (Hybrid Approach):**
```typescript
export class UserProfileComponent {
  userId = signal(1);
  private userData = signal<User | null>(null);
  
  constructor(private userService: UserService) {
    // Effect to load data when userId changes
    effect(() => {
      const id = this.userId();
      this.userService.getUser(id).subscribe(user => {
        this.userData.set(user);
      });
    });
  }
  
  // ✅ Computed based on async-loaded data
  displayName = computed(() => {
    const user = this.userData();
    if (!user) return 'Loading...';
    return user.firstName && user.lastName 
      ? `${user.firstName} ${user.lastName}`
      : user.username;
  });
  
  isAdmin = computed(() => {
    const user = this.userData();
    return user?.roles?.includes('admin') ?? false;
  });
}
```

**7. Performance Optimization with Computed:**
```typescript
export class ExpensiveComponent {
  largeDataset = signal<number[]>(Array.from({length: 10000}, (_, i) => i));
  filterCriteria = signal(0);
  
  // ✅ Expensive computation - only runs when dependencies change
  filteredData = computed(() => {
    console.log('Computing filtered data...'); // Only logs when needed
    
    const data = this.largeDataset();
    const criteria = this.filterCriteria();
    
    return data.filter(item => item > criteria);
  });
  
  // ✅ Memoized - doesn't recalculate if filteredData hasn't changed
  statistics = computed(() => {
    console.log('Computing statistics...'); // Only logs when filteredData changes
    
    const data = this.filteredData();
    return {
      count: data.length,
      sum: data.reduce((a, b) => a + b, 0),
      average: data.length > 0 ? data.reduce((a, b) => a + b, 0) / data.length : 0
    };
  });
}
```

**8. Computed with Custom Equality:**
```typescript
export class CustomEqualityComponent {
  user = signal({ name: 'John', age: 30, metadata: { lastLogin: new Date() } });
  
  // ✅ Computed with custom equality to ignore metadata changes
  userSummary = computed(() => {  
    const user = this.user();
    return { name: user.name, age: user.age };
  }, {
    equal: (a, b) => a.name === b.name && a.age === b.age
  });
}
```

**Best Practices for Computed Signals:**

**1. Keep Computations Pure:**
```typescript
// ✅ Good - pure function
const fullName = computed(() => `${firstName()} ${lastName()}`);

// ❌ Avoid - side effects
const badComputed = computed(() => {
  console.log('Computing...'); // Side effect
  localStorage.setItem('value', firstName()); // Side effect
  return firstName();
});
```

**2. Handle Null/Undefined:**
```typescript
const safeComputed = computed(() => {
  const user = userData();
  return user?.name ?? 'Unknown';
});
```

**3. Use for Expensive Operations:**
```typescript
// ✅ Expensive operation that benefits from memoization
const expensiveComputation = computed(() => {
  return heavyCalculation(inputData());
});
```

**4. Chain Computations Logically:**
```typescript
// ✅ Logical progression
const filteredItems = computed(() => items().filter(item => item.active));
const sortedItems = computed(() => filteredItems().sort((a, b) => a.name.localeCompare(b.name)));
const paginatedItems = computed(() => sortedItems().slice(0, pageSize()));
```

[Back to Signals (Angular 16+)](#signals-angular-16)

### 49. What is the difference between signals and observables?

**Answer:**
**Signals** and **Observables** are both reactive programming constructs, but they have fundamental differences in behavior, use cases, and implementation. Understanding these differences is crucial for choosing the right tool.

**Core Conceptual Differences:**

| Aspect | Signals | Observables |
|--------|---------|-------------|
| **Nature** | Synchronous state holders | Asynchronous event streams |
| **Execution** | Pull-based (lazy evaluation) | Push-based (reactive streams) |
| **Time** | Current value snapshot | Values over time |
| **Subscription** | Automatic dependency tracking | Manual subscription management |
| **Memory** | Automatic cleanup | Manual unsubscription needed |
| **Completion** | Always "live" | Can complete or error |

**1. Execution Model:**

**Signals (Pull-based):**
```typescript
const count = signal(0);
const doubled = computed(() => count() * 2);

// ✅ Pull-based - value computed when accessed
console.log(doubled()); // Computation happens here
console.log(doubled()); // Cached result returned
```

**Observables (Push-based):**
```typescript
const count$ = new BehaviorSubject(0);
const doubled$ = count$.pipe(map(x => x * 2));

// ✅ Push-based - computation happens when source emits
doubled$.subscribe(value => console.log(value)); // Reactive to changes
```

**2. State vs Streams:**

**Signals - Current State:**
```typescript
// ✅ Signals represent current state
const user = signal({ name: 'John', age: 30 });
const isAdult = computed(() => user().age >= 18);

// Always has current value
console.log(user());     // Current user
console.log(isAdult());  // Current adult status

// Update state
user.update(u => ({ ...u, age: 17 }));
console.log(isAdult());  // false - immediately reflects change
```

**Observables - Events Over Time:**
```typescript
// ✅ Observables represent events/values over time
const user$ = new BehaviorSubject({ name: 'John', age: 30 });
const isAdult$ = user$.pipe(map(user => user.age >= 18));

// Subscribe to stream of changes
isAdult$.subscribe(isAdult => console.log('Adult status:', isAdult));

// Emit new value
user$.next({ name: 'John', age: 17 }); // Triggers subscription
```

**3. Subscription Management:**

**Signals (Automatic):**
```typescript
@Component({
  template: `<div>{{fullName()}}</div>` // Automatic subscription
})
export class SignalComponent {
  firstName = signal('John');
  lastName = signal('Doe');
  
  // ✅ No manual subscription needed
  fullName = computed(() => `${this.firstName()} ${this.lastName()}`);
  
  // ✅ No cleanup needed - automatic
}
```

**Observables (Manual):**
```typescript
@Component({
  template: `<div>{{fullName$ | async}}</div>` // async pipe handles subscription
})
export class ObservableComponent implements OnDestroy {
  firstName$ = new BehaviorSubject('John');
  lastName$ = new BehaviorSubject('Doe');
  
  fullName$ = combineLatest([this.firstName$, this.lastName$]).pipe(
    map(([first, last]) => `${first} ${last}`)
  );
  
  private destroy$ = new Subject<void>();
  
  ngOnInit() {
    // ❌ Manual subscription requires cleanup
    this.fullName$.pipe(takeUntil(this.destroy$))
      .subscribe(name => console.log(name));
  }
  
  ngOnDestroy() {
    // ❌ Manual cleanup required
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

**4. Async Operations:**

**Signals (Not Directly Async):**
```typescript
export class SignalAsyncComponent {
  data = signal<User[]>([]);
  loading = signal(false);
  
  constructor(private userService: UserService) {
    // ✅ Use effect for async operations
    effect(() => {
      this.loading.set(true);
      this.userService.getUsers().subscribe(users => {
        this.data.set(users);
        this.loading.set(false);
      });
    });
  }
  
  // ✅ Computed for derived state
  userCount = computed(() => this.data().length);
}
```

**Observables (Naturally Async):**
```typescript
export class ObservableAsyncComponent {
  // ✅ Direct async support
  users$ = this.userService.getUsers().pipe(
    shareReplay(1),
    catchError(() => of([]))
  );
  
  loading$ = this.users$.pipe(
    map(() => false),
    startWith(true)
  );
  
  userCount$ = this.users$.pipe(
    map(users => users.length)
  );
  
  constructor(private userService: UserService) {}
}
```

**5. Error Handling:**

**Signals (Synchronous Errors):**
```typescript
const data = signal<number[]>([1, 2, 3]);

const average = computed(() => {
  const values = data();
  if (values.length === 0) {
    throw new Error('No data'); // ❌ Synchronous error
  }
  return values.reduce((a, b) => a + b) / values.length;
});

// Handle with try-catch
try {
  console.log(average());
} catch (error) {
  console.error(error.message);
}
```

**Observables (Async Error Handling):**
```typescript
const data$ = of([1, 2, 3]);

const average$ = data$.pipe(
  map(values => {
    if (values.length === 0) {
      throw new Error('No data');
    }
    return values.reduce((a, b) => a + b) / values.length;
  }),
  catchError(error => {
    console.error(error.message);
    return of(0); // ✅ Recover from error
  })
);
```

**6. Operators and Transformations:**

**Signals (Limited Built-in Operators):**
```typescript
const numbers = signal([1, 2, 3, 4, 5]);

// ✅ Use computed for transformations
const evenNumbers = computed(() => numbers().filter(n => n % 2 === 0));
const sum = computed(() => numbers().reduce((a, b) => a + b, 0));

// ❌ No built-in operators like debounce, throttle, etc.
```

**Observables (Rich Operator Library):**
```typescript
const numbers$ = of([1, 2, 3, 4, 5]);

// ✅ Rich set of operators
const evenNumbers$ = numbers$.pipe(
  map(nums => nums.filter(n => n % 2 === 0))
);

const sum$ = numbers$.pipe(
  map(nums => nums.reduce((a, b) => a + b, 0))
);

// ✅ Time-based operators
const debouncedInput$ = input$.pipe(
  debounceTime(300),
  distinctUntilChanged()
);
```

**7. Performance:**

**Signals (Optimized for Sync Operations):**
```typescript
// ✅ Efficient memoization and dependency tracking
const expensiveComputation = computed(() => {
  console.log('Computing...'); // Only runs when dependencies change
  return heavyCalculation(input());
});

// ✅ Fine-grained updates
const count = signal(0);
// Only components using count() will update
```

**Observables (More Overhead):**
```typescript
// ⚠️ More memory overhead
const expensiveComputation$ = input$.pipe(
  map(value => {
    console.log('Computing...'); // Runs on every emission
    return heavyCalculation(value);
  }),
  shareReplay(1) // Needed for memoization-like behavior
);
```

**8. Testing:**

**Signals (Synchronous Testing):**
```typescript
describe('SignalComponent', () => {
  it('should compute full name', () => {
    const component = new SignalComponent();
    component.firstName.set('John');
    component.lastName.set('Doe');
    
    // ✅ Synchronous testing
    expect(component.fullName()).toBe('John Doe');
  });
});
```

**Observables (Async Testing):**
```typescript
describe('ObservableComponent', () => {
  it('should compute full name', (done) => {
    const component = new ObservableComponent();
    component.firstName$.next('John');
    component.lastName$.next('Doe');
    
    // ⚠️ Async testing required
    component.fullName$.subscribe(name => {
      expect(name).toBe('John Doe');
      done();
    });
  });
});
```

**When to Choose Each:**

**Choose Signals When:**
- ✅ Managing **component state**
- ✅ **Synchronous** computations
- ✅ **Performance** is critical
- ✅ Want **automatic** dependency tracking
- ✅ **Simple** reactive patterns
- ✅ **Current value** semantics

**Choose Observables When:**
- ✅ **HTTP requests** and **API calls**
- ✅ **Event streams** over time
- ✅ **Complex async** operations
- ✅ Need **rich operators** (debounce, retry, etc.)
- ✅ **Time-based** operations
- ✅ **Error handling** and **recovery**

**Migration Path:**
```typescript
// Start with what you know (Observables)
// Gradually adopt Signals for state management
// Use hybrid approaches where beneficial
// Keep Observables for async operations
```

[Back to Signals (Angular 16+)](#signals-angular-16)

### 50. How do you convert between signals and observables?

**Answer:**
Angular provides utilities to convert between **signals** and **observables** in both directions, enabling seamless integration between the two reactive paradigms.

**Signal to Observable Conversion:**

**1. Using `toObservable()`:**
```typescript
import { signal, computed } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';

@Component({})
export class ConversionComponent {
  // Signal sources
  count = signal(0);
  user = signal({ name: 'John', age: 30 });
  
  constructor() {
    // ✅ Convert signal to observable
    const count$ = toObservable(this.count);
    
    // Subscribe to signal changes
    count$.subscribe(value => {
      console.log('Count changed:', value);
    });
    
    // ✅ Convert computed signal to observable
    const isEven = computed(() => this.count() % 2 === 0);
    const isEven$ = toObservable(isEven);
    
    isEven$.subscribe(even => {
      console.log('Is even:', even);
    });
  }
  
  increment() {
    this.count.update(val => val + 1); // Triggers observable emission
  }
}
```

**2. Complex Signal to Observable:**
```typescript
@Component({})
export class ComplexConversionComponent {
  searchQuery = signal('');
  filters = signal({ category: 'all', sortBy: 'name' });
  
  constructor(private searchService: SearchService) {
    // ✅ Convert multiple signals to observables
    const query$ = toObservable(this.searchQuery);
    const filters$ = toObservable(this.filters);
    
    // ✅ Combine with RxJS operators
    const searchResults$ = combineLatest([query$, filters$]).pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(([query, filters]) => 
        this.searchService.search(query, filters)
      )
    );
    
    searchResults$.subscribe(results => {
      console.log('Search results:', results);
    });
  }
}
```

**Observable to Signal Conversion:**

**1. Using `toSignal()`:**
```typescript
import { toSignal } from '@angular/core/rxjs-interop';

@Component({})
export class ObservableToSignalComponent {
  private dataService = inject(DataService);
  
  // ✅ Convert observable to signal
  users = toSignal(this.dataService.getUsers(), { initialValue: [] });
  
  // ✅ Convert HTTP observable to signal
  currentUser = toSignal(
    this.dataService.getCurrentUser(),
    { initialValue: null }
  );
  
  // ✅ Use in template
  template = `
    <div *ngFor="let user of users()">{{user.name}}</div>
    <div *ngIf="currentUser()">Welcome {{currentUser()!.name}}</div>
  `;
}
```

**2. Advanced Observable to Signal:**
```typescript
@Component({})
export class AdvancedConversionComponent {
  private http = inject(HttpClient);
  
  // ✅ Convert complex observable pipeline to signal
  weatherData = toSignal(
    this.http.get<WeatherData>('/api/weather').pipe(
      retry(3),
      catchError(() => of({ temp: 0, condition: 'unknown' })),
      shareReplay(1)
    ),
    { initialValue: { temp: 0, condition: 'loading' } }
  );
  
  // ✅ Convert timer observable to signal
  currentTime = toSignal(
    timer(0, 1000).pipe(
      map(() => new Date().toLocaleTimeString())
    ),
    { initialValue: new Date().toLocaleTimeString() }
  );
  
  // ✅ Convert WebSocket to signal
  messages = toSignal(
    this.websocketService.messages$,
    { initialValue: [] as Message[] }
  );
}
```

**Bidirectional Conversion Patterns:**

**1. Signal → Observable → Signal:**
```typescript
@Component({})
export class BidirectionalComponent {
  // Original signal
  searchInput = signal('');
  
  constructor(private searchService: SearchService) {
    // Signal → Observable for HTTP operations
    const searchQuery$ = toObservable(this.searchInput).pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(query => this.searchService.search(query))
    );
    
    // Observable → Signal for template usage
    this.searchResults = toSignal(searchQuery$, { initialValue: [] });
  }
  
  // Result signal for template
  searchResults: Signal<SearchResult[]>;
  
  onSearchInput(value: string) {
    this.searchInput.set(value); // Update signal
  }
}
```

**2. Form Integration:**
```typescript
@Component({})
export class FormIntegrationComponent {
  // Form control as observable
  emailControl = new FormControl('');
  
  // Convert to signal for reactive updates
  email = toSignal(
    this.emailControl.valueChanges.pipe(startWith('')),
    { initialValue: '' }
  );
  
  // Computed validation
  isEmailValid = computed(() => {
    const email = this.email();
    return email.includes('@') && email.includes('.');
  });
  
  // Convert back to observable for HTTP
  constructor(private userService: UserService) {
    const emailValidation$ = toObservable(this.isEmailValid).pipe(
      filter(isValid => isValid),
      switchMap(() => this.userService.checkEmailAvailability(this.email()))
    );
    
    this.emailAvailable = toSignal(emailValidation$, { initialValue: null });
  }
  
  emailAvailable: Signal<boolean | null>;
}
```

**Real-World Use Cases:**

**1. HTTP + Signal State Management:**
```typescript
@Injectable()
export class UserStateService {
  private userSubject = new BehaviorSubject<User | null>(null);
  
  // Observable for HTTP operations
  private user$ = this.userSubject.asObservable();
  
  // Signal for component consumption
  user = toSignal(this.user$, { initialValue: null });
  
  // Computed signals based on user
  isLoggedIn = computed(() => this.user() !== null);
  userRole = computed(() => this.user()?.role ?? 'guest');
  
  loadUser(id: number) {
    return this.http.get<User>(`/api/users/${id}`).pipe(
      tap(user => this.userSubject.next(user))
    );
  }
  
  logout() {
    this.userSubject.next(null);
  }
}
```

**2. Real-time Data with Signals:**
```typescript
@Component({})
export class RealtimeComponent {
  private websocket$ = new WebSocketSubject('ws://localhost:8080');
  
  // Convert WebSocket observable to signal
  messages = toSignal(
    this.websocket$.asObservable(),
    { initialValue: [] as Message[] }
  );
  
  // Signal for new message input
  newMessage = signal('');
  
  sendMessage() {
    const message = this.newMessage();
    if (message.trim()) {
      // Convert signal to observable for sending
      toObservable(this.newMessage).pipe(
        take(1)
      ).subscribe(msg => {
        this.websocket$.next({ text: msg, timestamp: Date.now() });
      });
      
      this.newMessage.set('');
    }
  }
}
```

**3. State Synchronization:**
```typescript
@Injectable()
export class SyncService {
  // Local signal state
  private localData = signal<Data[]>([]);
  
  // Convert to observable for server sync
  private localData$ = toObservable(this.localData);
  
  constructor() {
    // Sync local changes to server
    this.localData$.pipe(
      debounceTime(1000),
      switchMap(data => this.http.post('/api/sync', data))
    ).subscribe();
    
    // Sync server changes to local
    this.http.get<Data[]>('/api/data').subscribe(serverData => {
      this.localData.set(serverData);
    });
  }
  
  // Public readonly signal
  data = this.localData.asReadonly();
  
  updateData(newData: Data[]) {
    this.localData.set(newData);
  }
}
```

**Best Practices:**

**1. Choose the Right Direction:**
```typescript
// ✅ Signal → Observable: For HTTP, complex async operations
const httpRequest$ = toObservable(searchQuery).pipe(
  switchMap(query => this.http.get(`/search?q=${query}`))
);

// ✅ Observable → Signal: For template consumption, computed values
const searchResults = toSignal(httpRequest$, { initialValue: [] });
```

**2. Handle Initial Values:**
```typescript
// ✅ Always provide initialValue for toSignal
const data = toSignal(this.http.get('/api/data'), {
  initialValue: [] // Prevents undefined in template
});

// ✅ Handle loading states
const loading = toSignal(
  httpRequest$.pipe(
    map(() => false),
    startWith(true)
  ),
  { initialValue: true }
);
```

**3. Memory Management:**
```typescript
// ✅ toSignal automatically handles unsubscription
// ✅ toObservable automatically completes when signal is destroyed
// No manual cleanup needed in most cases
```

[Back to Signals (Angular 16+)](#signals-angular-16)

### 51. What are effect signals and when to use them?

**Answer:**
**Effect signals** are a reactive primitive in Angular that allow you to perform **side effects** when signal values change. They automatically track signal dependencies and re-run when those dependencies change.

**Basic Effect Usage:**

**1. Simple Effect:**
```typescript
import { signal, effect } from '@angular/core';

@Component({})
export class EffectComponent {
  count = signal(0);
  
  constructor() {
    // ✅ Effect runs when count changes
    effect(() => {
      console.log('Count changed to:', this.count());
    });
  }
  
  increment() {
    this.count.update(val => val + 1); // Triggers effect
  }
}
```

**2. Multiple Dependencies:**
```typescript
@Component({})
export class MultiDependencyComponent {
  firstName = signal('John');
  lastName = signal('Doe');
  age = signal(30);
  
  constructor() {
    // ✅ Effect tracks multiple signals
    effect(() => {
      const fullName = `${this.firstName()} ${this.lastName()}`;
      const ageInfo = this.age();
      
      console.log(`User: ${fullName}, Age: ${ageInfo}`);
      // Runs when firstName, lastName, OR age changes
    });
  }
}
```

**When to Use Effects:**

**1. Logging and Debugging:**
```typescript
@Component({})
export class LoggingComponent {
  userState = signal({ isLoggedIn: false, username: '' });
  
  constructor() {
    // ✅ Log state changes for debugging
    effect(() => {
      const state = this.userState();
      console.log('User state changed:', state);
      
      // Send analytics
      if (state.isLoggedIn) {
        analytics.track('user_logged_in', { username: state.username });
      }
    });
  }
}
```

**2. Local Storage Synchronization:**
```typescript
@Component({})
export class StorageComponent {
  preferences = signal({
    theme: 'light',
    language: 'en',
    notifications: true
  });
  
  constructor() {
    // ✅ Sync to localStorage when preferences change
    effect(() => {
      const prefs = this.preferences();
      localStorage.setItem('user-preferences', JSON.stringify(prefs));
    });
    
    // Load from localStorage on init
    const saved = localStorage.getItem('user-preferences');
    if (saved) {
      this.preferences.set(JSON.parse(saved));
    }
  }
}
```

**3. HTTP Requests Based on Signal Changes:**
```typescript
@Component({})
export class SearchComponent {
  searchQuery = signal('');
  filters = signal({ category: 'all', sortBy: 'name' });
  results = signal<SearchResult[]>([]);
  loading = signal(false);
  
  constructor(private searchService: SearchService) {
    // ✅ Trigger search when query or filters change
    effect(() => {
      const query = this.searchQuery();
      const currentFilters = this.filters();
      
      if (query.trim()) {
        this.loading.set(true);
        
        this.searchService.search(query, currentFilters).subscribe({
          next: (results) => {
            this.results.set(results);
            this.loading.set(false);
          },
          error: (error) => {
            console.error('Search failed:', error);
            this.loading.set(false);
          }
        });
      } else {
        this.results.set([]);
      }
    });
  }
}
```

**4. DOM Manipulation:**
```typescript
@Component({})
export class DOMComponent {
  @ViewChild('canvas', { static: true }) canvas!: ElementRef<HTMLCanvasElement>;
  
  chartData = signal([10, 20, 30, 40, 50]);
  chartColor = signal('#3498db');
  
  constructor() {
    // ✅ Update canvas when data changes
    effect(() => {
      const data = this.chartData();
      const color = this.chartColor();
      
      this.drawChart(data, color);
    });
  }
  
  private drawChart(data: number[], color: string) {
    const ctx = this.canvas.nativeElement.getContext('2d');
    if (ctx) {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.fillStyle = color;
      
      data.forEach((value, index) => {
        ctx.fillRect(index * 20, ctx.canvas.height - value, 15, value);
      });
    }
  }
}
```

**5. WebSocket/Real-time Subscriptions:**
```typescript
@Component({})
export class RealtimeComponent {
  selectedRoom = signal('general');
  private websocket: WebSocket | null = null;
  messages = signal<Message[]>([]);
  
  constructor() {
    // ✅ Connect to different room when selection changes
    effect(() => {
      const room = this.selectedRoom();
      
      // Cleanup previous connection
      if (this.websocket) {
        this.websocket.close();
      }
      
      // Connect to new room
      this.websocket = new WebSocket(`ws://localhost:8080/rooms/${room}`);
      
      this.websocket.onmessage = (event) => {
        const message = JSON.parse(event.data);
        this.messages.update(msgs => [...msgs, message]);
      };
      
      this.websocket.onopen = () => {
        console.log(`Connected to room: ${room}`);
      };
    });
  }
  
  ngOnDestroy() {
    if (this.websocket) {
      this.websocket.close();
    }
  }
}
```

**Advanced Effect Features:**

**1. Effect Cleanup:**
```typescript
@Component({})
export class CleanupComponent {
  intervalDuration = signal(1000);
  
  constructor() {
    effect((onCleanup) => {
      const duration = this.intervalDuration();
      
      const intervalId = setInterval(() => {
        console.log('Tick every', duration, 'ms');
      }, duration);
      
      // ✅ Cleanup function - runs before next effect or on destroy
      onCleanup(() => {
        clearInterval(intervalId);
        console.log('Cleaned up interval');
      });
    });
  }
}
```

**2. Effect with Manual Dependency Tracking:**
```typescript
@Component({})
export class ManualTrackingComponent {
  user = signal({ name: 'John', age: 30, metadata: { lastSeen: new Date() } });
  
  constructor() {
    effect(() => {
      const user = this.user();
      
      // ✅ Only react to name and age changes, ignore metadata
      const relevantData = { name: user.name, age: user.age };
      
      console.log('Relevant user data changed:', relevantData);
      this.syncToServer(relevantData);
    });
  }
  
  private syncToServer(data: any) {
    // Sync logic here
  }
}
```

**3. Conditional Effects:**
```typescript
@Component({})
export class ConditionalComponent {
  isEnabled = signal(true);
  data = signal<any[]>([]);
  
  constructor() {
    effect(() => {
      if (this.isEnabled()) {
        const currentData = this.data();
        console.log('Processing data:', currentData);
        this.processData(currentData);
      }
      // Effect only runs when isEnabled is true AND data changes
    });
  }
  
  private processData(data: any[]) {
    // Processing logic
  }
}
```

**4. Effect with Error Handling:**
```typescript
@Component({})
export class ErrorHandlingComponent {
  apiEndpoint = signal('/api/users');
  
  constructor(private http: HttpClient) {
    effect(() => {
      const endpoint = this.apiEndpoint();
      
      try {
        this.http.get(endpoint).subscribe({
          next: (data) => console.log('Data received:', data),
          error: (error) => console.error('HTTP Error:', error)
        });
      } catch (error) {
        console.error('Effect error:', error);
      }
    });
  }
}
```

**Best Practices:**

**1. Keep Effects Simple and Focused:**
```typescript
// ✅ Good - single responsibility
effect(() => {
  localStorage.setItem('theme', this.theme());
});

effect(() => {
  this.analytics.track('theme_changed', this.theme());
});

// ❌ Avoid - multiple responsibilities
effect(() => {
  localStorage.setItem('theme', this.theme());
  this.analytics.track('theme_changed', this.theme());
  this.updateCSS();
  this.notifyServer();
});
```

**2. Use Cleanup for Resources:**
```typescript
effect((onCleanup) => {
  const subscription = this.dataService.getData().subscribe(data => {
    this.processData(data);
  });
  
  // ✅ Always cleanup subscriptions
  onCleanup(() => subscription.unsubscribe());
});
```

**3. Avoid Infinite Loops:**
```typescript
// ❌ Dangerous - can cause infinite loop
effect(() => {
  const count = this.count();
  this.count.set(count + 1); // DON'T modify signals in effects
});

// ✅ Safe - only read signals, perform side effects
effect(() => {
  const count = this.count();
  console.log('Count is:', count); // Safe side effect
});
```

**4. Use Guards for Conditional Logic:**
```typescript
effect(() => {
  const user = this.user();
  
  // ✅ Guard against invalid states
  if (!user || !user.id) {
    return;
  }
  
  this.loadUserPreferences(user.id);
});
```

**When NOT to Use Effects:**

**❌ For Computed Values:**
```typescript
// ❌ Don't use effect for derived state
effect(() => {
  const fullName = `${this.firstName()} ${this.lastName()}`;
  this.displayName.set(fullName);
});

// ✅ Use computed instead
displayName = computed(() => `${this.firstName()} ${this.lastName()}`);
```

**❌ For Template Updates:**
```typescript
// ❌ Don't use effect for template updates
effect(() => {
  this.elementRef.nativeElement.textContent = this.message();
});

// ✅ Use signal directly in template
template = `<div>{{message()}}</div>`;
```

**Effects are perfect for side effects like API calls, logging, storage, and DOM manipulation that need to happen reactively when signals change!**

[Back to Signals (Angular 16+)](#signals-angular-16)

### 52. How do signals integrate with change detection?

**Answer:**
**Signals integrate seamlessly with Angular's change detection** system, providing automatic and efficient updates while working alongside traditional change detection mechanisms.

**How Signal Change Detection Works:**

**1. Automatic Change Detection Triggering:**
```typescript
@Component({
  selector: 'app-counter',
  template: `
    <div>Count: {{count()}}</div>
    <button (click)="increment()">+</button>
  `
})
export class CounterComponent {
  count = signal(0);
  
  increment() {
    // ✅ Signal update automatically triggers change detection
    this.count.update(val => val + 1);
    // No need to manually call detectChanges()
  }
}
```

**2. Works with OnPush Strategy:**
```typescript
@Component({
  selector: 'app-optimized',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>User: {{user().name}}</div>
    <div>Status: {{status()}}</div>
  `
})
export class OptimizedComponent {
  user = signal({ name: 'John', age: 30 });
  status = computed(() => this.user().age >= 18 ? 'Adult' : 'Minor');
  
  updateUser() {
    // ✅ Even with OnPush, signal changes trigger updates
    this.user.update(u => ({ ...u, age: 25 }));
    // Component automatically re-renders
  }
}
```

**Signal vs Traditional Change Detection:**

**Traditional Change Detection:**
```typescript
@Component({
  template: `<div>{{message}}</div>`
})
export class TraditionalComponent {
  message = 'Hello';
  
  updateMessage() {
    this.message = 'Updated'; // ✅ Triggers change detection
  }
  
  updateAsync() {
    setTimeout(() => {
      this.message = 'Async Update'; // ✅ Zone.js detects and triggers CD
    }, 1000);
  }
}
```

**Signal-Based Change Detection:**
```typescript
@Component({
  template: `<div>{{message()}}</div>`
})
export class SignalComponent {
  message = signal('Hello');
  
  updateMessage() {
    this.message.set('Updated'); // ✅ Signal triggers change detection
  }
  
  updateAsync() {
    setTimeout(() => {
      this.message.set('Async Update'); // ✅ Signal triggers CD (no Zone.js needed)
    }, 1000);
  }
}
```

**Fine-Grained Change Detection:**

**1. Only Affected Components Update:**
```typescript
// Parent Component
@Component({
  selector: 'app-parent',
  template: `
    <app-child-a [data]="dataA()"></app-child-a>
    <app-child-b [data]="dataB()"></app-child-b>
  `
})
export class ParentComponent {
  dataA = signal('Data A');
  dataB = signal('Data B');
  
  updateA() {
    this.dataA.set('Updated A');
    // ✅ Only ChildA re-renders, ChildB stays unchanged
  }
}
```

**2. Computed Signal Optimization:**
```typescript
@Component({
  template: `
    <div>Expensive Result: {{expensiveComputation()}}</div>
    <div>Simple Count: {{count()}}</div>
  `
})
export class OptimizedComponent {
  input = signal(5);
  count = signal(0);
  
  // ✅ Only recalculates when input changes
  expensiveComputation = computed(() => {
    console.log('Computing...'); // Only logs when input changes
    return this.heavyCalculation(this.input());
  });
  
  updateCount() {
    this.count.update(val => val + 1);
    // ✅ expensiveComputation doesn't recalculate
  }
  
  updateInput() {
    this.input.update(val => val + 1);
    // ✅ expensiveComputation recalculates
  }
  
  private heavyCalculation(value: number): number {
    // Expensive operation
    return value * 1000;
  }
}
```

**Integration with Angular Features:**

**1. Reactive Forms Integration:**
```typescript
@Component({
  template: `
    <form [formGroup]="form">
      <input formControlName="email">
      <div>Valid: {{isEmailValid()}}</div>
    </form>
  `
})
export class FormComponent {
  form = new FormGroup({
    email: new FormControl('')
  });
  
  // ✅ Convert form value to signal
  email = toSignal(
    this.form.get('email')!.valueChanges.pipe(startWith('')),
    { initialValue: '' }
  );
  
  // ✅ Computed validation
  isEmailValid = computed(() => {
    const email = this.email();
    return email.includes('@') && email.length > 5;
  });
}
```

**2. HTTP Integration:**
```typescript
@Component({
  template: `
    <div *ngIf="loading()">Loading...</div>
    <div *ngFor="let user of users()">{{user.name}}</div>
  `
})
export class HttpComponent {
  private refreshTrigger = signal(0);
  
  // ✅ Signal triggers HTTP request
  users = toSignal(
    toObservable(this.refreshTrigger).pipe(
      switchMap(() => this.http.get<User[]>('/api/users'))
    ),
    { initialValue: [] }
  );
  
  loading = toSignal(
    toObservable(this.refreshTrigger).pipe(
      switchMap(() => this.http.get<User[]>('/api/users').pipe(
        map(() => false),
        startWith(true)
      ))
    ),
    { initialValue: true }
  );
  
  refresh() {
    // ✅ Signal change triggers HTTP request and change detection
    this.refreshTrigger.update(val => val + 1);
  }
  
  constructor(private http: HttpClient) {}
}
```

**3. Router Integration:**
```typescript
@Component({
  template: `
    <div>Current Route: {{currentRoute()}}</div>
    <div>Route Params: {{routeParams() | json}}</div>
  `
})
export class RouterComponent {
  // ✅ Convert router observables to signals
  currentRoute = toSignal(
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd),
      map(() => this.router.url)
    ),
    { initialValue: this.router.url }
  );
  
  routeParams = toSignal(
    this.activatedRoute.params,
    { initialValue: {} }
  );
  
  constructor(
    private router: Router,
    private activatedRoute: ActivatedRoute
  ) {}
}
```

**Zone-less Change Detection:**

**1. Disabling Zone.js:**
```typescript
// main.ts
bootstrapApplication(App, {
  providers: [
    // ✅ Disable Zone.js for better performance
    provideExperimentalZonelessChangeDetection()
  ]
});
```

**2. Manual Change Detection with Signals:**
```typescript
@Component({
  template: `<div>{{count()}}</div>`
})
export class ZonelessComponent {
  count = signal(0);
  
  constructor(private cdr: ChangeDetectorRef) {}
  
  updateFromExternalEvent() {
    // ✅ In zone-less mode, signals still trigger change detection
    document.addEventListener('click', () => {
      this.count.update(val => val + 1);
      // Signal automatically triggers change detection
    });
  }
}
```

**Performance Benefits:**

**1. Reduced Change Detection Cycles:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>Heavy Component: {{heavyData()}}</div>
    <button (click)="updateOtherData()">Update Other</button>
  `
})
export class PerformantComponent {
  heavyData = signal('Heavy computation result');
  otherData = signal('Other data');
  
  updateOtherData() {
    this.otherData.set('Updated other');
    // ✅ heavyData component doesn't re-render unnecessarily
  }
}
```

**2. Micro-optimizations:**
```typescript
@Component({
  template: `
    <div class="expensive-list">
      <div *ngFor="let item of filteredItems(); trackBy: trackByFn">
        {{item.name}}
      </div>
    </div>
  `
})
export class MicroOptimizedComponent {
  items = signal<Item[]>([]);
  filter = signal('');
  
  // ✅ Only recalculates when items or filter change
  filteredItems = computed(() => {
    const items = this.items();
    const filterValue = this.filter();
    
    return filterValue 
      ? items.filter(item => item.name.includes(filterValue))
      : items;
  });
  
  trackByFn = (index: number, item: Item) => item.id;
}
```

**Debugging Signal Change Detection:**

**1. Signal Debugging:**
```typescript
@Component({})
export class DebugComponent {
  count = signal(0, { 
    equal: (a, b) => {
      console.log('Comparing:', a, 'vs', b);
      return a === b;
    }
  });
  
  expensiveComputed = computed(() => {
    console.log('Computing expensive value...');
    return this.count() * 1000;
  });
}
```

**2. Change Detection Profiling:**
```typescript
@Component({})
export class ProfilingComponent {
  data = signal([]);
  
  constructor() {
    // ✅ Profile change detection performance
    effect(() => {
      const start = performance.now();
      const data = this.data();
      const end = performance.now();
      
      console.log(`Data access took ${end - start}ms`);
    });
  }
}
```

**Best Practices:**

**1. Prefer Signals for State:**
```typescript
// ✅ Use signals for reactive state
const user = signal<User | null>(null);
const isLoggedIn = computed(() => user() !== null);

// ❌ Avoid mixing with traditional properties
// public user: User | null = null; // Don't mix approaches
```

**2. Use OnPush with Signals:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush, // ✅ Always use OnPush
  template: `<div>{{data()}}</div>`
})
export class OptimalComponent {
  data = signal('Initial');
}
```

**3. Combine with Async Pipe When Needed:**
```typescript
@Component({
  template: `
    <div>Signal Data: {{signalData()}}</div>
    <div>Observable Data: {{observableData$ | async}}</div>
  `
})
export class HybridComponent {
  signalData = signal('Signal value');
  observableData$ = this.http.get('/api/data');
  
  constructor(private http: HttpClient) {}
}
```

**Signals provide automatic, efficient change detection that works seamlessly with Angular's existing change detection system while offering superior performance characteristics!**

[Back to Signals (Angular 16+)](#signals-angular-16)

### 53. What are the benefits of using signals over observables?

**Answer:**
**Signals offer several key advantages over observables** for certain use cases, particularly in state management, performance optimization, and developer experience. Here are the main benefits:

**1. Synchronous Nature & Immediate Values:**

**Signals:**
```typescript
const count = signal(0);
const doubled = computed(() => count() * 2);

// ✅ Always has current value, synchronous access
console.log(count());    // 0 - immediate value
console.log(doubled());  // 0 - immediate computed value

count.set(5);
console.log(doubled());  // 10 - immediately updated
```

**Observables:**
```typescript
const count$ = new BehaviorSubject(0);
const doubled$ = count$.pipe(map(x => x * 2));

// ❌ Async access, requires subscription
count$.subscribe(value => console.log(value)); // 0
doubled$.subscribe(value => console.log(value)); // 0

count$.next(5);
// Values are pushed asynchronously
```

**2. Automatic Memory Management:**

**Signals:**
```typescript
@Component({
  template: `<div>{{userCount()}}</div>`
})
export class SignalComponent {
  users = signal<User[]>([]);
  
  // ✅ No manual cleanup needed
  userCount = computed(() => this.users().length);
  
  // ✅ No ngOnDestroy required for signals
}
```

**Observables:**
```typescript
@Component({
  template: `<div>{{userCount$ | async}}</div>`
})
export class ObservableComponent implements OnDestroy {
  users$ = new BehaviorSubject<User[]>([]);
  userCount$ = this.users$.pipe(map(users => users.length));
  
  private destroy$ = new Subject<void>();
  
  ngOnInit() {
    // ❌ Manual subscription management required
    this.userCount$.pipe(takeUntil(this.destroy$))
      .subscribe(count => console.log(count));
  }
  
  ngOnDestroy() {
    // ❌ Manual cleanup required
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

**3. Performance Benefits:**

**Signals - Fine-grained Updates:**
```typescript
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>Name: {{user().name}}</div>
    <div>Age: {{user().age}}</div>
    <div>Email: {{user().email}}</div>
  `
})
export class OptimizedComponent {
  user = signal({ name: 'John', age: 30, email: 'john@example.com' });
  
  updateAge() {
    // ✅ Only this component updates, very efficient
    this.user.update(u => ({ ...u, age: 31 }));
  }
}
```

**Observables - Broader Updates:**
```typescript
@Component({
  template: `
    <div>Name: {{(user$ | async)?.name}}</div>
    <div>Age: {{(user$ | async)?.age}}</div>
    <div>Email: {{(user$ | async)?.email}}</div>
  `
})
export class TraditionalComponent {
  user$ = new BehaviorSubject({ name: 'John', age: 30, email: 'john@example.com' });
  
  updateAge() {
    // ⚠️ Multiple async pipe subscriptions, less efficient
    const current = this.user$.value;
    this.user$.next({ ...current, age: 31 });
  }
}
```

**4. Simplified State Management:**

**Signals:**
```typescript
@Injectable()
export class UserStateService {
  // ✅ Simple, direct state management
  private _user = signal<User | null>(null);
  private _loading = signal(false);
  private _error = signal<string | null>(null);
  
  // ✅ Readonly access
  user = this._user.asReadonly();
  loading = this._loading.asReadonly();
  error = this._error.asReadonly();
  
  // ✅ Computed derived state
  isLoggedIn = computed(() => this._user() !== null);
  userName = computed(() => this._user()?.name ?? 'Anonymous');
  
  async loadUser(id: number) {
    this._loading.set(true);
    this._error.set(null);
    
    try {
      const user = await this.http.get<User>(`/api/users/${id}`).toPromise();
      this._user.set(user);
    } catch (error) {
      this._error.set(error.message);
    } finally {
      this._loading.set(false);
    }
  }
  
  logout() {
    this._user.set(null);
  }
}
```

**Observables:**
```typescript
@Injectable()
export class UserStateService {
  // ❌ More complex state management
  private _userSubject = new BehaviorSubject<User | null>(null);
  private _loadingSubject = new BehaviorSubject(false);
  private _errorSubject = new BehaviorSubject<string | null>(null);
  
  user$ = this._userSubject.asObservable();
  loading$ = this._loadingSubject.asObservable();
  error$ = this._errorSubject.asObservable();
  
  // ❌ More verbose computed state
  isLoggedIn$ = this.user$.pipe(map(user => user !== null));
  userName$ = this.user$.pipe(map(user => user?.name ?? 'Anonymous'));
  
  loadUser(id: number): Observable<User> {
    this._loadingSubject.next(true);
    this._errorSubject.next(null);
    
    return this.http.get<User>(`/api/users/${id}`).pipe(
      tap(user => {
        this._userSubject.next(user);
        this._loadingSubject.next(false);
      }),
      catchError(error => {
        this._errorSubject.next(error.message);
        this._loadingSubject.next(false);
        return throwError(error);
      })
    );
  }
}
```

**5. Better Developer Experience:**

**Signals - Intuitive API:**
```typescript
// ✅ Simple, intuitive API
const counter = signal(0);
const doubled = computed(() => counter() * 2);

// Reading values
console.log(counter());  // Simple function call
console.log(doubled());  // Simple function call

// Updating values
counter.set(5);                        // Set absolute value
counter.update(current => current + 1); // Update based on current

// Debugging - easy to inspect
console.log('Current counter:', counter());
```

**Observables - More Complex API:**
```typescript
// ❌ More complex API surface
const counter$ = new BehaviorSubject(0);
const doubled$ = counter$.pipe(map(x => x * 2));

// Reading values requires subscription
counter$.subscribe(value => console.log(value));
doubled$.subscribe(value => console.log(value));

// Updating values
counter$.next(5);

// Debugging - requires subscription
counter$.pipe(take(1)).subscribe(value => 
  console.log('Current counter:', value)
);
```

**6. Type Safety and IntelliSense:**

**Signals:**
```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

const user = signal<User>({ id: 1, name: 'John', email: 'john@example.com' });

// ✅ Excellent TypeScript support
const userName = computed(() => {
  const u = user(); // Type: User
  return u.name;    // IntelliSense works perfectly
});

// ✅ Type-safe updates
user.update(u => ({
  ...u,
  name: 'Jane' // TypeScript validates this
}));
```

**Observables:**
```typescript
const user$ = new BehaviorSubject<User>({ id: 1, name: 'John', email: 'john@example.com' });

// ⚠️ Type safety in pipelines can be complex
const userName$ = user$.pipe(
  map(u => u.name), // Type inference works but can be lost in complex chains
  distinctUntilChanged()
);
```

**7. Simplified Testing:**

**Signals:**
```typescript
describe('SignalComponent', () => {
  let component: SignalComponent;
  
  beforeEach(() => {
    component = new SignalComponent();
  });
  
  it('should compute full name', () => {
    // ✅ Synchronous testing
    component.firstName.set('John');
    component.lastName.set('Doe');
    
    expect(component.fullName()).toBe('John Doe');
    
    // ✅ Test updates immediately
    component.firstName.set('Jane');
    expect(component.fullName()).toBe('Jane Doe');
  });
  
  it('should handle computed values', () => {
    // ✅ No async testing needed
    component.count.set(5);
    expect(component.doubled()).toBe(10);
  });
});
```

**Observables:**
```typescript
describe('ObservableComponent', () => {
  let component: ObservableComponent;
  
  beforeEach(() => {
    component = new ObservableComponent();
  });
  
  it('should compute full name', fakeAsync(() => {
    // ❌ Requires async testing utilities
    component.firstName$.next('John');
    component.lastName$.next('Doe');
    
    let result: string;
    component.fullName$.subscribe(name => result = name);
    
    tick();
    expect(result!).toBe('John Doe');
  }));
});
```

**8. Reduced Bundle Size:**

**Signals:**
```typescript
// ✅ Lightweight - no RxJS operators needed for basic state
import { signal, computed } from '@angular/core';

const count = signal(0);
const doubled = computed(() => count() * 2);
```

**Observables:**
```typescript
// ❌ Larger bundle - requires RxJS operators
import { BehaviorSubject } from 'rxjs';
import { map, distinctUntilChanged, shareReplay } from 'rxjs/operators';

const count$ = new BehaviorSubject(0);
const doubled$ = count$.pipe(
  map(x => x * 2),
  distinctUntilChanged(),
  shareReplay(1)
);
```

**9. Better Integration with Angular Features:**

**Signals with Forms:**
```typescript
@Component({
  template: `
    <form>
      <input [value]="email()" (input)="email.set($event.target.value)">
      <div>Valid: {{isEmailValid()}}</div>
    </form>
  `
})
export class FormComponent {
  email = signal('');
  
  // ✅ Simple computed validation
  isEmailValid = computed(() => {
    const email = this.email();
    return email.includes('@') && email.length > 5;
  });
}
```

**10. Zone.js Independence:**

**Signals:**
```typescript
// ✅ Works perfectly without Zone.js
@Component({
  template: `<div>{{count()}}</div>`
})
export class ZonelessComponent {
  count = signal(0);
  
  constructor() {
    // ✅ External events work fine with signals
    document.addEventListener('click', () => {
      this.count.update(val => val + 1); // Automatically triggers change detection
    });
  }
}
```

**When Signals Are Better:**

- ✅ **Component state management**
- ✅ **Synchronous computations**
- ✅ **Form handling and validation**
- ✅ **Performance-critical applications**
- ✅ **Simple reactive patterns**
- ✅ **When you want immediate values**
- ✅ **Reducing bundle size**
- ✅ **Simplified testing**

**When Observables Are Still Better:**

- ✅ **HTTP requests and API calls**
- ✅ **Complex async operations**
- ✅ **Event streams over time**
- ✅ **Rich operator compositions**
- ✅ **WebSocket/Server-Sent Events**
- ✅ **Time-based operations**

**Summary:**
Signals provide a simpler, more performant, and more intuitive way to handle reactive state in Angular applications, especially for component-level state management and synchronous computations. They excel in scenarios where you need immediate values, automatic memory management, and fine-grained change detection.

[Back to Signals (Angular 16+)](#signals-angular-16)

### 54. How do you handle async operations with signals?

**Answer:**
While **signals are inherently synchronous**, Angular provides several patterns to effectively handle **async operations** with signals.

**Core Patterns:**

**1. Using Effects for HTTP Requests:**
```typescript
@Component({
  template: `
    <div *ngIf="loading()">Loading...</div>
    <div *ngFor="let user of users()">{{user.name}}</div>
    <button (click)="refresh()">Refresh</button>
  `
})
export class AsyncComponent {
  private refreshTrigger = signal(0);
  users = signal<User[]>([]);
  loading = signal(false);
  
  constructor(private http: HttpClient) {
    effect(() => {
      const trigger = this.refreshTrigger();
      this.loading.set(true);
      
      this.http.get<User[]>('/api/users').subscribe({
        next: (users) => {
          this.users.set(users);
          this.loading.set(false);
        }
      });
    });
  }
  
  refresh() {
    this.refreshTrigger.update(val => val + 1);
  }
}
```

**2. Converting Observables to Signals:**
```typescript
@Component({})
export class ConversionComponent {
  private userId = signal(1);
  
  currentUser = toSignal(
    toObservable(this.userId).pipe(
      switchMap(id => this.http.get<User>(`/api/users/${id}`))
    ),
    { initialValue: null }
  );
  
  changeUser(newId: number) {
    this.userId.set(newId); // Triggers HTTP request
  }
}
```

**3. Async State Management:**
```typescript
@Injectable()
export class AsyncStateService {
  private _data = signal<Data[]>([]);
  private _loading = signal(false);
  
  data = this._data.asReadonly();
  loading = this._loading.asReadonly();
  
  async loadData(): Promise<void> {
    this._loading.set(true);
    
    try {
      const data = await firstValueFrom(this.http.get<Data[]>('/api/data'));
      this._data.set(data);
    } finally {
      this._loading.set(false);
    }
  }
}
```

**4. WebSocket Integration:**
```typescript
@Component({})
export class WebSocketComponent {
  messages = signal<Message[]>([]);
  roomId = signal('general');
  
  constructor() {
    effect((onCleanup) => {
      const room = this.roomId();
      const socket = new WebSocket(`ws://localhost:8080/rooms/${room}`);
      
      socket.onmessage = (event) => {
        const message = JSON.parse(event.data);
        this.messages.update(msgs => [...msgs, message]);
      };
      
      onCleanup(() => socket.close());
    });
  }
}
```

**Best Practices:**
- ✅ Use **effects** for side effects
- ✅ Use **toSignal()** for observable conversion  
- ✅ Always handle **loading** and **error** states
- ✅ Use **firstValueFrom()** for promise conversion

[Back to Signals (Angular 16+)](#signals-angular-16)

### 55. What is signal-based state management?

**Answer:**
**Signal-based state management** is a modern approach to managing application state using Angular signals, providing a simpler, more performant alternative to traditional state management patterns.

**Core Principles:**

**1. Simple State Container:**
```typescript
@Injectable({ providedIn: 'root' })
export class AppStateService {
  // Private writable signals
  private _user = signal<User | null>(null);
  private _theme = signal<'light' | 'dark'>('light');
  private _notifications = signal<Notification[]>([]);
  
  // Public readonly signals
  user = this._user.asReadonly();
  theme = this._theme.asReadonly();
  notifications = this._notifications.asReadonly();
  
  // Computed state
  isLoggedIn = computed(() => this._user() !== null);
  unreadCount = computed(() => 
    this._notifications().filter(n => !n.read).length
  );
  
  // State mutations
  setUser(user: User | null) {
    this._user.set(user);
  }
  
  toggleTheme() {
    this._theme.update(current => current === 'light' ? 'dark' : 'light');
  }
  
  addNotification(notification: Notification) {
    this._notifications.update(notifications => 
      [...notifications, notification]
    );
  }
}
```

**2. Feature-Based State Slices:**
```typescript
// User Feature State
@Injectable()
export class UserStateService {
  private _currentUser = signal<User | null>(null);
  private _preferences = signal<UserPreferences>({
    language: 'en',
    timezone: 'UTC'
  });
  
  currentUser = this._currentUser.asReadonly();
  preferences = this._preferences.asReadonly();
  
  // Computed selectors
  displayName = computed(() => {
    const user = this._currentUser();
    return user ? `${user.firstName} ${user.lastName}` : 'Guest';
  });
  
  login(user: User) {
    this._currentUser.set(user);
  }
  
  updatePreferences(prefs: Partial<UserPreferences>) {
    this._preferences.update(current => ({ ...current, ...prefs }));
  }
}

// Shopping Cart Feature State
@Injectable()
export class CartStateService {
  private _items = signal<CartItem[]>([]);
  
  items = this._items.asReadonly();
  
  // Computed values
  totalItems = computed(() => 
    this._items().reduce((sum, item) => sum + item.quantity, 0)
  );
  
  totalPrice = computed(() =>
    this._items().reduce((sum, item) => sum + (item.price * item.quantity), 0)
  );
  
  addItem(product: Product, quantity = 1) {
    this._items.update(items => {
      const existing = items.find(item => item.productId === product.id);
      if (existing) {
        return items.map(item =>
          item.productId === product.id
            ? { ...item, quantity: item.quantity + quantity }
            : item
        );
      }
      return [...items, { productId: product.id, ...product, quantity }];
    });
  }
  
  removeItem(productId: string) {
    this._items.update(items => items.filter(item => item.productId !== productId));
  }
}
```

**3. Global State with Local State:**
```typescript
@Component({
  template: `
    <div>Global User: {{globalState.user()?.name}}</div>
    <div>Local Count: {{localCount()}}</div>
    <div>Combined: {{combinedData()}}</div>
  `
})
export class ComponentWithMixedState {
  // Local component state
  localCount = signal(0);
  localSettings = signal({ showDetails: false });
  
  // Combined state
  combinedData = computed(() => ({
    user: this.globalState.user(),
    count: this.localCount(),
    settings: this.localSettings()
  }));
  
  constructor(public globalState: AppStateService) {}
  
  incrementLocal() {
    this.localCount.update(count => count + 1);
  }
}
```

**4. Async State Management:**
```typescript
@Injectable()
export class AsyncStateService {
  private _posts = signal<Post[]>([]);
  private _loading = signal(false);
  private _error = signal<string | null>(null);
  
  posts = this._posts.asReadonly();
  loading = this._loading.asReadonly();
  error = this._error.asReadonly();
  
  // Computed state
  publishedPosts = computed(() => 
    this._posts().filter(post => post.published)
  );
  
  async loadPosts() {
    this._loading.set(true);
    this._error.set(null);
    
    try {
      const posts = await firstValueFrom(this.http.get<Post[]>('/api/posts'));
      this._posts.set(posts);
    } catch (error: any) {
      this._error.set(error.message);
    } finally {
      this._loading.set(false);
    }
  }
  
  addPost(post: Omit<Post, 'id'>) {
    // Optimistic update
    const newPost: Post = { ...post, id: Date.now().toString() };
    this._posts.update(posts => [newPost, ...posts]);
    
    // Sync with server
    this.http.post<Post>('/api/posts', post).subscribe({
      next: (savedPost) => {
        this._posts.update(posts =>
          posts.map(p => p.id === newPost.id ? savedPost : p)
        );
      },
      error: (error) => {
        // Rollback on error
        this._posts.update(posts => posts.filter(p => p.id !== newPost.id));
        this._error.set(error.message);
      }
    });
  }
}
```

**5. State Persistence:**
```typescript
@Injectable()
export class PersistentStateService {
  private _settings = signal<AppSettings>(this.loadFromStorage());
  
  settings = this._settings.asReadonly();
  
  constructor() {
    // Auto-save to localStorage when settings change
    effect(() => {
      const settings = this._settings();
      localStorage.setItem('app-settings', JSON.stringify(settings));
    });
  }
  
  private loadFromStorage(): AppSettings {
    const saved = localStorage.getItem('app-settings');
    return saved ? JSON.parse(saved) : {
      theme: 'light',
      language: 'en',
      notifications: true
    };
  }
  
  updateSettings(updates: Partial<AppSettings>) {
    this._settings.update(current => ({ ...current, ...updates }));
  }
}
```

**6. State Composition:**
```typescript
@Injectable()
export class ComposedStateService {
  constructor(
    private userState: UserStateService,
    private cartState: CartStateService,
    private notificationState: NotificationStateService
  ) {}
  
  // Compose state from multiple services
  dashboardData = computed(() => ({
    user: this.userState.currentUser(),
    cartItemCount: this.cartState.totalItems(),
    unreadNotifications: this.notificationState.unreadCount(),
    isLoggedIn: this.userState.currentUser() !== null
  }));
  
  // Cross-service operations
  checkout() {
    const user = this.userState.currentUser();
    const items = this.cartState.items();
    
    if (!user || items.length === 0) {
      this.notificationState.addNotification({
        type: 'error',
        message: 'Cannot checkout: missing user or items'
      });
      return;
    }
    
    // Perform checkout logic
    this.processCheckout(user, items);
  }
}
```

**Benefits over Traditional State Management:**

**vs NgRx:**
```typescript
// ✅ Signal-based - Simple and direct
@Injectable()
export class SimpleCounterService {
  private _count = signal(0);
  count = this._count.asReadonly();
  
  increment() {
    this._count.update(val => val + 1);
  }
}

// ❌ NgRx - Complex boilerplate
// Requires: actions, reducers, effects, selectors
const increment = createAction('[Counter] Increment');
const counterReducer = createReducer(0, on(increment, state => state + 1));
// ... much more boilerplate
```

**Performance Benefits:**
- ✅ **Fine-grained updates** - only affected components re-render
- ✅ **No unnecessary subscriptions** - automatic dependency tracking
- ✅ **Synchronous access** - no async pipe needed
- ✅ **Smaller bundle size** - no heavy state management library

**Best Practices:**

**1. Organize by Feature:**
```typescript
// ✅ Feature-based organization
services/
  user/
    user-state.service.ts
    user-api.service.ts
  cart/
    cart-state.service.ts
    cart-api.service.ts
```

**2. Use Readonly Signals:**
```typescript
// ✅ Expose readonly signals
export class StateService {
  private _data = signal([]);
  data = this._data.asReadonly(); // Prevent external mutations
}
```

**3. Compute Derived State:**
```typescript
// ✅ Use computed for derived state
const filteredItems = computed(() => {
  const items = this._items();
  const filter = this._filter();
  return items.filter(item => item.category === filter);
});
```

**4. Handle Async Operations:**
```typescript
// ✅ Always track loading and error states
private _loading = signal(false);
private _error = signal<string | null>(null);
```

**Signal-based state management provides a simpler, more performant, and more intuitive approach to managing application state compared to traditional solutions like NgRx or services with BehaviorSubjects.**

[Back to Signals (Angular 16+)](#signals-angular-16)

### 56. How do you implement routing in Angular?

**Answer:**
Angular routing enables navigation between different views or components in a single-page application. Here's how to implement routing from basic to advanced scenarios.

**1. Basic Router Setup:**

```typescript
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';
import { ContactComponent } from './contact/contact.component';

const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent },
  { path: 'contact', component: ContactComponent },
  { path: '**', redirectTo: '/home' } // Wildcard route for 404 page
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

**2. App Module Integration:**

```typescript
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    AppRoutingModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

**3. Router Outlet in Template:**

```html
<!-- app.component.html -->
<nav>
  <a routerLink="/home" routerLinkActive="active">Home</a>
  <a routerLink="/about" routerLinkActive="active">About</a>
  <a routerLink="/contact" routerLinkActive="active">Contact</a>
</nav>

<router-outlet></router-outlet>
```

**4. Standalone Components (Angular 14+):**

```typescript
// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { AppComponent } from './app/app.component';
import { routes } from './app/app.routes';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes)
  ]
});
```

```typescript
// app.routes.ts
import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';

export const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent },
  { path: '**', redirectTo: '/home' }
];
```

**5. Programmatic Navigation:**

```typescript
// navigation.service.ts
import { Injectable } from '@angular/core';
import { Router } from '@angular/router';

@Injectable({
  providedIn: 'root'
})
export class NavigationService {
  constructor(private router: Router) {}
  
  // Navigate to route
  goToHome() {
    this.router.navigate(['/home']);
  }
  
  // Navigate with parameters
  goToUser(userId: number) {
    this.router.navigate(['/user', userId]);
  }
  
  // Navigate with query parameters
  goToSearch(query: string) {
    this.router.navigate(['/search'], { queryParams: { q: query } });
  }
  
  // Navigate by URL
  goToUrl(url: string) {
    this.router.navigateByUrl(url);
  }
}
```

**6. Route Parameters:**

```typescript
// user-detail.component.ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  template: `
    <h2>User Details</h2>
    <p>User ID: {{ userId }}</p>
    <p>Tab: {{ activeTab }}</p>
  `
})
export class UserDetailComponent implements OnInit {
  userId!: string;
  activeTab!: string;
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    // Route parameters
    this.userId = this.route.snapshot.paramMap.get('id')!;
    
    // Query parameters
    this.activeTab = this.route.snapshot.queryParamMap.get('tab') || 'profile';
    
    // Subscribe to parameter changes
    this.route.paramMap.subscribe(params => {
      this.userId = params.get('id')!;
    });
  }
}
```

**7. Advanced Routing Configuration:**

```typescript
const routes: Routes = [
  { 
    path: 'users/:id', 
    component: UserDetailComponent,
    data: { title: 'User Details' }
  },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    canActivate: [AuthGuard]
  },
  {
    path: 'products',
    children: [
      { path: '', component: ProductListComponent },
      { path: ':id', component: ProductDetailComponent },
      { path: ':id/edit', component: ProductEditComponent }
    ]
  }
];
```

**Best Practices:**
- Use lazy loading for feature modules
- Implement route guards for security
- Use resolvers for data pre-fetching
- Handle route errors gracefully
- Use meaningful route paths
- Implement proper navigation UX

[Back to Routing and Navigation](#routing-and-navigation)

### 57. What are route guards and what types exist?

**Answer:**
Route guards are interfaces that control whether a route can be activated, deactivated, or loaded. They provide security and navigation control in Angular applications.

**Types of Route Guards:**

**1. CanActivate - Control Route Access:**

```typescript
// auth.guard.ts
import { Injectable } from '@angular/core';
import { CanActivate, Router, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  constructor(
    private authService: AuthService,
    private router: Router
  ) {}
  
  canActivate(): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    if (this.authService.isAuthenticated()) {
      return true;
    } else {
      this.router.navigate(['/login']);
      return false;
    }
  }
}

// Usage in routes
const routes: Routes = [
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [AuthGuard]
  }
];
```

**2. CanActivateChild - Control Child Route Access:**

```typescript
// admin.guard.ts
@Injectable({
  providedIn: 'root'
})
export class AdminGuard implements CanActivateChild {
  constructor(private authService: AuthService) {}
  
  canActivateChild(): boolean {
    return this.authService.hasRole('admin');
  }
}

// Usage
const routes: Routes = [
  {
    path: 'admin',
    component: AdminComponent,
    canActivateChild: [AdminGuard],
    children: [
      { path: 'users', component: AdminUsersComponent },
      { path: 'settings', component: AdminSettingsComponent }
    ]
  }
];
```

**3. CanDeactivate - Control Route Exit:**

```typescript
// unsaved-changes.guard.ts
export interface CanComponentDeactivate {
  canDeactivate: () => Observable<boolean> | Promise<boolean> | boolean;
}

@Injectable({
  providedIn: 'root'
})
export class UnsavedChangesGuard implements CanDeactivate<CanComponentDeactivate> {
  canDeactivate(
    component: CanComponentDeactivate
  ): Observable<boolean> | Promise<boolean> | boolean {
    return component.canDeactivate ? component.canDeactivate() : true;
  }
}

// Component implementation
@Component({})
export class EditFormComponent implements CanComponentDeactivate {
  hasUnsavedChanges = false;
  
  canDeactivate(): boolean {
    if (this.hasUnsavedChanges) {
      return confirm('You have unsaved changes. Do you want to leave?');
    }
    return true;
  }
}
```

**4. CanLoad - Control Lazy Loading:**

```typescript
// feature.guard.ts
@Injectable({
  providedIn: 'root'
})
export class FeatureGuard implements CanLoad {
  constructor(private featureService: FeatureService) {}
  
  canLoad(): boolean {
    return this.featureService.isFeatureEnabled('premium');
  }
}

// Usage
const routes: Routes = [
  {
    path: 'premium',
    loadChildren: () => import('./premium/premium.module').then(m => m.PremiumModule),
    canLoad: [FeatureGuard]
  }
];
```

**5. CanMatch - Control Route Matching (Angular 14+):**

```typescript
// role-based.guard.ts
@Injectable({
  providedIn: 'root'
})
export class RoleBasedGuard implements CanMatch {
  constructor(private authService: AuthService) {}
  
  canMatch(route: Route): boolean {
    const requiredRole = route.data?.['role'];
    return this.authService.hasRole(requiredRole);
  }
}

// Usage - Multiple routes for same path based on role
const routes: Routes = [
  {
    path: 'dashboard',
    component: AdminDashboardComponent,
    canMatch: [RoleBasedGuard],
    data: { role: 'admin' }
  },
  {
    path: 'dashboard',
    component: UserDashboardComponent,
    canMatch: [RoleBasedGuard],
    data: { role: 'user' }
  }
];
```

**Modern Functional Guards (Angular 14+):**

```typescript
// functional-guards.ts
import { inject } from '@angular/core';
import { Router } from '@angular/router';
import { AuthService } from './auth.service';

// Functional CanActivate guard
export const authGuard = () => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  if (authService.isAuthenticated()) {
    return true;
  } else {
    return router.createUrlTree(['/login']);
  }
};

// Functional CanDeactivate guard
export const unsavedChangesGuard = (component: CanComponentDeactivate) => {
  return component.canDeactivate ? component.canDeactivate() : true;
};

// Usage
const routes: Routes = [
  {
    path: 'protected',
    component: ProtectedComponent,
    canActivate: [authGuard]
  }
];
```

**Advanced Guard Patterns:**

**1. Async Guards with Observables:**

```typescript
@Injectable({
  providedIn: 'root'
})
export class AsyncAuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}
  
  canActivate(): Observable<boolean | UrlTree> {
    return this.authService.checkAuthStatus().pipe(
      map(isAuthenticated => {
        if (isAuthenticated) {
          return true;
        } else {
          return this.router.createUrlTree(['/login']);
        }
      }),
      catchError(() => of(this.router.createUrlTree(['/error'])))
    );
  }
}
```

**2. Permission-Based Guard:**

```typescript
@Injectable({
  providedIn: 'root'
})
export class PermissionGuard implements CanActivate {
  constructor(private permissionService: PermissionService) {}
  
  canActivate(route: ActivatedRouteSnapshot): Observable<boolean> {
    const requiredPermission = route.data['permission'];
    
    return this.permissionService.hasPermission(requiredPermission).pipe(
      tap(hasPermission => {
        if (!hasPermission) {
          // Log unauthorized access attempt
          console.warn(`Unauthorized access attempt to ${route.url}`);
        }
      })
    );
  }
}
```

**3. Multi-Guard Setup:**

```typescript
const routes: Routes = [
  {
    path: 'admin/users',
    component: AdminUsersComponent,
    canActivate: [AuthGuard, AdminGuard, PermissionGuard],
    data: { permission: 'MANAGE_USERS' }
  }
];
```

**Guard Execution Order:**
1. `CanMatch` (determines if route matches)
2. `CanLoad` (for lazy-loaded modules)
3. `CanActivate` (for route activation)
4. `CanActivateChild` (for child routes)
5. `CanDeactivate` (when leaving route)

**Best Practices:**
- Use guards for authentication and authorization
- Implement proper error handling in guards
- Use functional guards in modern Angular versions
- Combine multiple guards when needed
- Provide user feedback for guard rejections
- Test guards thoroughly

[Back to Routing and Navigation](#routing-and-navigation)

### 58. How do you pass data between routes?

**Answer:**
Angular provides several ways to pass data between routes, each suitable for different scenarios and data types.

**1. Route Parameters:**

```typescript
// Routes configuration
const routes: Routes = [
  { path: 'user/:id', component: UserDetailComponent },
  { path: 'user/:id/edit/:section', component: UserEditComponent }
];

// Navigation with parameters
export class UserListComponent {
  constructor(private router: Router) {}
  
  viewUser(userId: number) {
    this.router.navigate(['/user', userId]);
  }
  
  editUserSection(userId: number, section: string) {
    this.router.navigate(['/user', userId, 'edit', section]);
  }
}

// Receiving route parameters
export class UserDetailComponent implements OnInit {
  userId!: string;
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    // Snapshot approach (for one-time access)
    this.userId = this.route.snapshot.paramMap.get('id')!;
    
    // Observable approach (for parameter changes)
    this.route.paramMap.subscribe(params => {
      this.userId = params.get('id')!;
      this.loadUser(this.userId);
    });
  }
}
```

**2. Query Parameters:**

```typescript
// Navigation with query parameters
export class SearchComponent {
  constructor(private router: Router) {}
  
  search(query: string, category: string, page: number) {
    this.router.navigate(['/search'], {
      queryParams: {
        q: query,
        category: category,
        page: page
      }
    });
  }
  
  // Merge with existing query parameters
  updatePage(page: number) {
    this.router.navigate([], {
      relativeTo: this.route,
      queryParams: { page: page },
      queryParamsHandling: 'merge' // Preserve other query params
    });
  }
}

// Receiving query parameters
export class SearchResultsComponent implements OnInit {
  query!: string;
  category!: string;
  page = 1;
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    this.route.queryParamMap.subscribe(params => {
      this.query = params.get('q') || '';
      this.category = params.get('category') || 'all';
      this.page = Number(params.get('page')) || 1;
      
      this.performSearch();
    });
  }
}
```

**3. Route Data (Static Data):**

```typescript
// Routes with static data
const routes: Routes = [
  {
    path: 'about',
    component: AboutComponent,
    data: {
      title: 'About Us',
      breadcrumb: 'About',
      showSidebar: false,
      permissions: ['read']
    }
  }
];

// Accessing route data
export class AboutComponent implements OnInit {
  pageTitle!: string;
  showSidebar!: boolean;
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    this.pageTitle = this.route.snapshot.data['title'];
    this.showSidebar = this.route.snapshot.data['showSidebar'];
    
    // Or using observable
    this.route.data.subscribe(data => {
      this.pageTitle = data['title'];
      this.showSidebar = data['showSidebar'];
    });
  }
}
```

**4. Navigation State:**

```typescript
// Passing complex objects via navigation state
export class ProductListComponent {
  constructor(private router: Router) {}
  
  viewProduct(product: Product) {
    this.router.navigateByUrl('/product-detail', {
      state: {
        product: product,
        returnUrl: '/products',
        timestamp: Date.now()
      }
    });
  }
}

// Receiving navigation state
export class ProductDetailComponent implements OnInit {
  product!: Product;
  returnUrl!: string;
  
  constructor(private router: Router) {}
  
  ngOnInit() {
    const navigation = this.router.getCurrentNavigation();
    if (navigation?.extras.state) {
      this.product = navigation.extras.state['product'];
      this.returnUrl = navigation.extras.state['returnUrl'];
    }
    
    // Alternative: access via window.history.state
    if (window.history.state) {
      this.product = window.history.state.product;
      this.returnUrl = window.history.state.returnUrl;
    }
  }
}
```

**5. Route Resolvers (Pre-fetched Data):**

```typescript
// Data resolver
@Injectable({
  providedIn: 'root'
})
export class ProductResolver implements Resolve<Product> {
  constructor(private productService: ProductService) {}
  
  resolve(route: ActivatedRouteSnapshot): Observable<Product> {
    const productId = route.paramMap.get('id')!;
    return this.productService.getProduct(productId);
  }
}

// Route configuration with resolver
const routes: Routes = [
  {
    path: 'product/:id',
    component: ProductDetailComponent,
    resolve: {
      product: ProductResolver
    }
  }
];

// Accessing resolved data
export class ProductDetailComponent implements OnInit {
  product!: Product;
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    // Data is already available
    this.product = this.route.snapshot.data['product'];
    
    // Or using observable
    this.route.data.subscribe(data => {
      this.product = data['product'];
    });
  }
}
```

**6. Services for Complex Data Sharing:**

```typescript
// Shared data service
@Injectable({
  providedIn: 'root'
})
export class DataSharingService {
  private selectedItemSubject = new BehaviorSubject<any>(null);
  selectedItem$ = this.selectedItemSubject.asObservable();
  
  setSelectedItem(item: any) {
    this.selectedItemSubject.next(item);
  }
  
  clearSelectedItem() {
    this.selectedItemSubject.next(null);
  }
}

// Source component
export class ItemListComponent {
  constructor(
    private dataSharing: DataSharingService,
    private router: Router
  ) {}
  
  selectItem(item: any) {
    this.dataSharing.setSelectedItem(item);
    this.router.navigate(['/item-detail']);
  }
}

// Destination component
export class ItemDetailComponent implements OnInit, OnDestroy {
  selectedItem$ = this.dataSharing.selectedItem$;
  
  constructor(private dataSharing: DataSharingService) {}
  
  ngOnDestroy() {
    this.dataSharing.clearSelectedItem();
  }
}
```

**7. Fragment and Scroll Position:**

```typescript
// Navigation with fragment
export class DocumentComponent {
  constructor(private router: Router) {}
  
  scrollToSection(sectionId: string) {
    this.router.navigate(['/document'], {
      fragment: sectionId
    });
  }
}

// Handling fragments
export class DocumentViewComponent implements OnInit {
  constructor(
    private route: ActivatedRoute,
    private viewportScroller: ViewportScroller
  ) {}
  
  ngOnInit() {
    this.route.fragment.subscribe(fragment => {
      if (fragment) {
        this.viewportScroller.scrollToAnchor(fragment);
      }
    });
  }
}
```

**8. Complex Data Passing Patterns:**

```typescript
// Multiple data sources combined
export class ComplexNavigationComponent {
  constructor(private router: Router) {}
  
  navigateWithComplexData(item: any, filters: any) {
    this.router.navigate(['/results', item.id], {
      queryParams: {
        category: filters.category,
        sortBy: filters.sortBy,
        page: filters.page
      },
      state: {
        searchContext: filters,
        selectedItem: item,
        timestamp: Date.now()
      },
      fragment: 'results-section'
    });
  }
}
```

**Best Practices:**

| Method | Use Case | Pros | Cons |
|--------|----------|------|------|
| **Route Parameters** | Required data, SEO-friendly URLs | Bookmarkable, shareable | Limited to simple data |
| **Query Parameters** | Optional data, filtering | Bookmarkable, mergeable | URL can become long |
| **Route Data** | Static configuration | Simple, cached | Only static data |
| **Navigation State** | Complex objects | No URL pollution | Not bookmarkable |
| **Resolvers** | Pre-fetched data | Data ready on load | Can slow navigation |
| **Services** | Complex sharing | Flexible, reactive | Requires cleanup |

**When to Use What:**
- **Route/Query Params**: User ID, filters, pagination
- **Navigation State**: Complex objects, temporary data
- **Route Data**: Configuration, permissions, metadata
- **Resolvers**: Critical data needed before component loads
- **Services**: Complex state, multiple components

[Back to Routing and Navigation](#routing-and-navigation)

### 59. What are route resolvers and how do you implement them?

**Answer:**
Route resolvers are services that pre-fetch data before a route is activated, ensuring the component has all necessary data when it loads.

**Basic Route Resolver:**
```typescript
@Injectable({ providedIn: 'root' })
export class UserResolver implements Resolve<User> {
  constructor(private userService: UserService, private router: Router) {}
  
  resolve(route: ActivatedRouteSnapshot): Observable<User> {
    const userId = route.paramMap.get('id')!;
    
    return this.userService.getUser(userId).pipe(
      catchError(error => {
        console.error('Error loading user:', error);
        this.router.navigate(['/users']); // Redirect on error
        return EMPTY; // Cancel navigation
      })
    );
  }
}
```

**Using Resolvers in Routes:**
```typescript
const routes: Routes = [
  {
    path: 'user/:id',
    component: UserDetailComponent,
    resolve: {
      user: UserResolver,
      permissions: PermissionResolver
    }
  }
];
```

**Accessing Resolved Data:**
```typescript
@Component({
  template: `
    <div *ngIf="user">
      <h1>{{ user.name }}</h1>
      <p>{{ user.email }}</p>
    </div>
  `
})
export class UserDetailComponent implements OnInit {
  user: User;
  permissions: Permission[];
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    // Access resolved data
    this.user = this.route.snapshot.data['user'];
    this.permissions = this.route.snapshot.data['permissions'];
    
    // Or subscribe to data changes
    this.route.data.subscribe(data => {
      this.user = data['user'];
      this.permissions = data['permissions'];
    });
  }
}
```

**Multiple Data Resolver:**
```typescript
@Injectable({ providedIn: 'root' })
export class DashboardResolver implements Resolve<DashboardData> {
  constructor(
    private userService: UserService,
    private statsService: StatsService
  ) {}
  
  resolve(): Observable<DashboardData> {
    return forkJoin({
      user: this.userService.getCurrentUser(),
      stats: this.statsService.getStats(),
      notifications: this.userService.getNotifications()
    }).pipe(
      map(({ user, stats, notifications }) => ({
        user,
        stats,
        notifications
      }))
    );
  }
}
```

**Benefits:**
- **Better UX** - No loading states in components
- **Error handling** - Centralized error handling
- **Data consistency** - Guaranteed data availability
- **Navigation control** - Can prevent navigation on errors

[Back to Routing and Navigation](#routing-and-navigation)

### 60. How do you handle route parameters and query parameters?

**Answer:**
Route parameters and query parameters are essential for passing data through URLs in Angular applications. Here's how to handle them effectively.

**1. Route Parameters (Path Parameters):**

**Route Configuration:**
```typescript
const routes: Routes = [
  { path: 'user/:id', component: UserComponent },
  { path: 'user/:id/post/:postId', component: PostComponent },
  { path: 'category/:category/product/:productId', component: ProductComponent }
];
```

**Reading Route Parameters:**
```typescript
import { ActivatedRoute } from '@angular/router';

@Component({})
export class UserComponent implements OnInit {
  userId!: string;
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    // Method 1: Snapshot (one-time read)
    this.userId = this.route.snapshot.paramMap.get('id')!;
    
    // Method 2: Observable (reactive to changes)
    this.route.paramMap.subscribe(params => {
      this.userId = params.get('id')!;
      this.loadUserData(this.userId);
    });
    
    // Method 3: Using params directly (less type-safe)
    this.route.params.subscribe(params => {
      this.userId = params['id'];
    });
  }
}
```

**2. Query Parameters:**

**Setting Query Parameters:**
```typescript
export class SearchComponent {
  constructor(private router: Router, private route: ActivatedRoute) {}
  
  // Navigate with query parameters
  search(query: string, filters: any) {
    this.router.navigate(['/search'], {
      queryParams: {
        q: query,
        category: filters.category,
        minPrice: filters.minPrice,
        maxPrice: filters.maxPrice,
        page: 1
      }
    });
  }
  
  // Update specific query parameter
  updatePage(page: number) {
    this.router.navigate([], {
      relativeTo: this.route,
      queryParams: { page },
      queryParamsHandling: 'merge' // Preserve existing params
    });
  }
  
  // Remove query parameter
  clearFilter(paramName: string) {
    this.router.navigate([], {
      relativeTo: this.route,
      queryParams: { [paramName]: null },
      queryParamsHandling: 'merge'
    });
  }
}
```

**Reading Query Parameters:**
```typescript
@Component({})
export class SearchResultsComponent implements OnInit {
  searchQuery = '';
  category = 'all';
  currentPage = 1;
  filters: any = {};
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    // Method 1: Snapshot
    this.searchQuery = this.route.snapshot.queryParamMap.get('q') || '';
    this.category = this.route.snapshot.queryParamMap.get('category') || 'all';
    
    // Method 2: Observable (recommended)
    this.route.queryParamMap.subscribe(params => {
      this.searchQuery = params.get('q') || '';
      this.category = params.get('category') || 'all';
      this.currentPage = Number(params.get('page')) || 1;
      
      // Build filters object
      this.filters = {
        category: this.category,
        minPrice: params.get('minPrice'),
        maxPrice: params.get('maxPrice')
      };
      
      this.performSearch();
    });
  }
}
```

**3. Combined Parameters Handling:**

```typescript
@Component({})
export class ProductDetailComponent implements OnInit {
  productId!: string;
  categoryId!: string;
  variant = '';
  color = '';
  size = '';
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    // Combine route and query parameters
    combineLatest([
      this.route.paramMap,
      this.route.queryParamMap
    ]).subscribe(([params, queryParams]) => {
      // Route parameters
      this.productId = params.get('productId')!;
      this.categoryId = params.get('category')!;
      
      // Query parameters
      this.variant = queryParams.get('variant') || '';
      this.color = queryParams.get('color') || '';
      this.size = queryParams.get('size') || '';
      
      this.loadProduct();
    });
  }
}
```

**4. Advanced Parameter Handling:**

**Type-Safe Parameter Handling:**
```typescript
interface ProductParams {
  id: string;
  category: string;
}

interface ProductQueryParams {
  variant?: string;
  color?: string;
  size?: string;
  tab?: string;
}

@Component({})
export class TypeSafeProductComponent implements OnInit {
  private getRouteParams(): ProductParams {
    const params = this.route.snapshot.paramMap;
    return {
      id: params.get('id')!,
      category: params.get('category')!
    };
  }
  
  private getQueryParams(): ProductQueryParams {
    const params = this.route.snapshot.queryParamMap;
    return {
      variant: params.get('variant') || undefined,
      color: params.get('color') || undefined,
      size: params.get('size') || undefined,
      tab: params.get('tab') || undefined
    };
  }
}
```

**Parameter Validation:**
```typescript
@Component({})
export class ValidatedParamsComponent implements OnInit {
  constructor(private route: ActivatedRoute, private router: Router) {}
  
  ngOnInit() {
    this.route.paramMap.subscribe(params => {
      const id = params.get('id');
      
      // Validate parameter
      if (!id || !this.isValidId(id)) {
        this.router.navigate(['/404']);
        return;
      }
      
      this.loadData(id);
    });
  }
  
  private isValidId(id: string): boolean {
    return /^\d+$/.test(id); // Only numeric IDs
  }
}
```

**5. Programmatic Navigation with Parameters:**

```typescript
export class NavigationService {
  constructor(private router: Router) {}
  
  // Navigate with route parameters
  goToUser(userId: number) {
    this.router.navigate(['/user', userId]);
  }
  
  // Navigate with query parameters
  searchProducts(filters: any) {
    this.router.navigate(['/products'], {
      queryParams: filters
    });
  }
  
  // Navigate with both
  goToProductWithFilters(categoryId: string, productId: string, options: any) {
    this.router.navigate(['/category', categoryId, 'product', productId], {
      queryParams: options
    });
  }
  
  // Update URL without navigation
  updateUrl(params: any, queryParams: any) {
    this.router.navigate(['/current-route', ...Object.values(params)], {
      queryParams,
      replaceUrl: true // Don't add to history
    });
  }
}
```

**6. Parameter Subscription Management:**

```typescript
@Component({})
export class ParameterSubscriptionComponent implements OnInit, OnDestroy {
  private subscriptions = new Subscription();
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    // Combine multiple parameter subscriptions
    this.subscriptions.add(
      this.route.paramMap.subscribe(params => {
        // Handle route parameters
      })
    );
    
    this.subscriptions.add(
      this.route.queryParamMap.subscribe(queryParams => {
        // Handle query parameters
      })
    );
    
    // Or use takeUntilDestroyed (Angular 16+)
    this.route.paramMap.pipe(
      takeUntilDestroyed()
    ).subscribe(params => {
      // Handle parameters
    });
  }
  
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
}
```

**7. URL Building and Manipulation:**

```typescript
export class UrlBuilderService {
  constructor(private router: Router, private route: ActivatedRoute) {}
  
  // Build URL with parameters
  buildProductUrl(categoryId: string, productId: string, options: any): string {
    const urlTree = this.router.createUrlTree(
      ['/category', categoryId, 'product', productId],
      { queryParams: options }
    );
    return this.router.serializeUrl(urlTree);
  }
  
  // Get current URL with modified parameters
  getCurrentUrlWithParams(newParams: any): string {
    return this.router.createUrlTree([], {
      relativeTo: this.route,
      queryParams: newParams,
      queryParamsHandling: 'merge'
    }).toString();
  }
}
```

**Best Practices:**

1. **Use Observable subscriptions** for parameters that can change
2. **Validate parameters** before using them
3. **Use type-safe interfaces** for parameter structures
4. **Handle missing or invalid parameters** gracefully
5. **Unsubscribe properly** to prevent memory leaks
6. **Use `queryParamsHandling: 'merge'`** to preserve existing parameters
7. **Keep URLs clean** and user-friendly
8. **Use route parameters for required data**, query parameters for optional data

**Common Patterns:**
- **Pagination**: `?page=2&size=20`
- **Filtering**: `?category=electronics&price=100-500`
- **Sorting**: `?sortBy=price&order=desc`
- **Search**: `?q=angular&type=tutorial`
- **Tabs/Views**: `?tab=reviews&view=grid`

[Back to Routing and Navigation](#routing-and-navigation)

### 61. What is the difference between `router.navigate()` and `router.navigateByUrl()`?

**Answer:**
Both methods are used for programmatic navigation in Angular, but they handle navigation parameters differently and serve different use cases.

**`router.navigate()`:**

**1. Array-based Navigation:**
```typescript
// Navigate with route segments
this.router.navigate(['/users', userId, 'profile']);
// Results in: /users/123/profile

// With query parameters
this.router.navigate(['/products'], {
  queryParams: { category: 'electronics', page: 2 },
  fragment: 'top'
});
// Results in: /products?category=electronics&page=2#top
```

**2. Relative Navigation:**
```typescript
// Relative to current route
this.router.navigate(['../sibling'], { relativeTo: this.route });
this.router.navigate(['./child'], { relativeTo: this.route });
this.router.navigate(['../../parent'], { relativeTo: this.route });
```

**3. Navigation Extras:**
```typescript
this.router.navigate(['/dashboard'], {
  queryParams: { tab: 'settings' },
  fragment: 'profile',
  state: { fromLogin: true },
  replaceUrl: true,
  skipLocationChange: false
});
```

**`router.navigateByUrl()`:**

**1. String-based Navigation:**
```typescript
// Navigate with complete URL string
this.router.navigateByUrl('/users/123/profile');

// With query parameters and fragment
this.router.navigateByUrl('/products?category=electronics&page=2#top');
```

**2. URL Tree Navigation:**
```typescript
// Using UrlTree for complex navigation
const urlTree = this.router.createUrlTree(['/users', userId], {
  queryParams: { tab: 'profile' }
});
this.router.navigateByUrl(urlTree);
```

**3. Limited Navigation Options:**
```typescript
// Only supports basic navigation extras
this.router.navigateByUrl('/dashboard', {
  replaceUrl: true,
  skipLocationChange: false,
  state: { data: 'value' }
});
```

**Key Differences:**

| Aspect | `navigate()` | `navigateByUrl()` |
|--------|-------------|------------------|
| **Parameter Format** | Array of segments | String URL or UrlTree |
| **Relative Navigation** | ✅ Supported | ❌ Not supported |
| **Query Parameters** | Via options object | Part of URL string |
| **Fragments** | Via options object | Part of URL string |
| **Type Safety** | ✅ Better with arrays | ❌ String-based |
| **Flexibility** | ✅ More navigation options | ❌ Limited options |
| **Use Case** | Dynamic route building | Direct URL navigation |

**When to Use Each:**

**Use `navigate()` when:**
```typescript
// ✅ Building routes dynamically
navigateToUser(userId: number, tab: string) {
  this.router.navigate(['/users', userId], {
    queryParams: { tab },
    relativeTo: this.route
  });
}

// ✅ Relative navigation
goToSibling() {
  this.router.navigate(['../sibling'], { relativeTo: this.route });
}

// ✅ Complex navigation with multiple options
navigateWithExtras() {
  this.router.navigate(['/dashboard'], {
    queryParams: { view: 'grid' },
    fragment: 'content',
    state: { previousRoute: this.router.url },
    replaceUrl: true
  });
}
```

**Use `navigateByUrl()` when:**
```typescript
// ✅ You have a complete URL string
navigateToUrl(url: string) {
  this.router.navigateByUrl(url);
}

// ✅ Redirecting to external-like routes
redirectToLogin() {
  this.router.navigateByUrl('/auth/login?returnUrl=' + encodeURIComponent(this.router.url));
}

// ✅ Working with UrlTree objects
navigateWithUrlTree() {
  const tree = this.router.createUrlTree(['/products'], {
    queryParams: { category: 'books' }
  });
  this.router.navigateByUrl(tree);
}
```

**Best Practices:**
- Use `navigate()` for most programmatic navigation scenarios
- Use `navigateByUrl()` when you have complete URL strings
- Prefer `navigate()` for type safety and flexibility
- Use `navigateByUrl()` for simple absolute navigation

[Back to Routing and Navigation](#routing-and-navigation)

### 62. How do you implement nested routing?

**Answer:**
Nested routing allows you to create hierarchical navigation structures where child routes are rendered within parent components. This is essential for complex applications with multiple levels of navigation.

**Basic Nested Routing Setup:**

**1. Parent Route Configuration:**
```typescript
// app-routing.module.ts
const routes: Routes = [
  {
    path: 'dashboard',
    component: DashboardComponent,
    children: [
      { path: '', redirectTo: 'overview', pathMatch: 'full' },
      { path: 'overview', component: OverviewComponent },
      { path: 'analytics', component: AnalyticsComponent },
      { path: 'settings', component: SettingsComponent }
    ]
  },
  {
    path: 'users',
    component: UsersComponent,
    children: [
      { path: '', component: UserListComponent },
      { path: ':id', component: UserDetailComponent },
      { path: ':id/edit', component: UserEditComponent }
    ]
  }
];
```

**2. Parent Component Template:**
```typescript
// dashboard.component.ts
@Component({
  selector: 'app-dashboard',
  template: `
    <div class="dashboard-layout">
      <nav class="sidebar">
        <a routerLink="overview" routerLinkActive="active">Overview</a>
        <a routerLink="analytics" routerLinkActive="active">Analytics</a>
        <a routerLink="settings" routerLinkActive="active">Settings</a>
      </nav>
      
      <main class="content">
        <!-- Child routes render here -->
        <router-outlet></router-outlet>
      </main>
    </div>
  `
})
export class DashboardComponent {}
```

**Multi-Level Nested Routing:**

**1. Deep Nesting Configuration:**
```typescript
const routes: Routes = [
  {
    path: 'admin',
    component: AdminComponent,
    children: [
      {
        path: 'users',
        component: AdminUsersComponent,
        children: [
          { path: '', component: UserListComponent },
          {
            path: ':id',
            component: UserDetailComponent,
            children: [
              { path: '', redirectTo: 'profile', pathMatch: 'full' },
              { path: 'profile', component: UserProfileComponent },
              { path: 'permissions', component: UserPermissionsComponent },
              { path: 'activity', component: UserActivityComponent }
            ]
          }
        ]
      },
      {
        path: 'products',
        component: AdminProductsComponent,
        children: [
          { path: '', component: ProductListComponent },
          { path: 'categories', component: CategoriesComponent },
          { path: ':id/edit', component: ProductEditComponent }
        ]
      }
    ]
  }
];
```

**2. Multi-Level Component Structure:**
```typescript
// admin.component.ts
@Component({
  selector: 'app-admin',
  template: `
    <div class="admin-layout">
      <header>Admin Panel</header>
      <nav class="main-nav">
        <a routerLink="users" routerLinkActive="active">Users</a>
        <a routerLink="products" routerLinkActive="active">Products</a>
      </nav>
      <router-outlet></router-outlet>
    </div>
  `
})
export class AdminComponent {}

// admin-users.component.ts
@Component({
  selector: 'app-admin-users',
  template: `
    <div class="users-section">
      <h2>User Management</h2>
      <nav class="sub-nav">
        <a routerLink="./" [routerLinkActiveOptions]="{exact: true}" routerLinkActive="active">All Users</a>
      </nav>
      <router-outlet></router-outlet>
    </div>
  `
})
export class AdminUsersComponent {}

// user-detail.component.ts
@Component({
  selector: 'app-user-detail',
  template: `
    <div class="user-detail">
      <h3>User: {{user?.name}}</h3>
      <nav class="detail-nav">
        <a routerLink="profile" routerLinkActive="active">Profile</a>
        <a routerLink="permissions" routerLinkActive="active">Permissions</a>
        <a routerLink="activity" routerLinkActive="active">Activity</a>
      </nav>
      <router-outlet></router-outlet>
    </div>
  `
})
export class UserDetailComponent {
  user: User;
  
  constructor(
    private route: ActivatedRoute,
    private userService: UserService
  ) {}
  
  ngOnInit() {
    const id = this.route.snapshot.params['id'];
    this.user = this.userService.getUser(id);
  }
}
```

**Route Guards with Nested Routes:**

```typescript
// Protecting nested routes
const routes: Routes = [
  {
    path: 'admin',
    component: AdminComponent,
    canActivate: [AdminGuard], // Protects entire admin section
    children: [
      {
        path: 'users',
        component: AdminUsersComponent,
        canActivateChild: [UserManagementGuard], // Protects all child routes
        children: [
          { 
            path: ':id/edit', 
            component: UserEditComponent,
            canActivate: [EditPermissionGuard] // Specific route protection
          }
        ]
      }
    ]
  }
];
```

**Data Sharing Between Nested Routes:**

```typescript
// Parent component sharing data with children
@Component({
  selector: 'app-dashboard',
  template: `
    <div class="dashboard">
      <h1>Welcome {{user?.name}}</h1>
      <router-outlet></router-outlet>
    </div>
  `
})
export class DashboardComponent implements OnInit {
  user: User;
  
  constructor(
    private route: ActivatedRoute,
    private userService: UserService
  ) {}
  
  ngOnInit() {
    // Parent loads data that children can access
    this.route.data.subscribe(data => {
      this.user = data['user'];
    });
  }
}

// Child component accessing parent data
@Component({...})
export class OverviewComponent implements OnInit {
  parentUser: User;
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit() {
    // Access parent route data
    this.parentUser = this.route.parent?.snapshot.data['user'];
  }
}
```

**Relative Navigation in Nested Routes:**

```typescript
@Component({...})
export class UserDetailComponent {
  constructor(
    private router: Router,
    private route: ActivatedRoute
  ) {}
  
  // Navigate to sibling routes
  goToProfile() {
    this.router.navigate(['profile'], { relativeTo: this.route });
  }
  
  goToPermissions() {
    this.router.navigate(['permissions'], { relativeTo: this.route });
  }
  
  // Navigate to parent route
  goToUserList() {
    this.router.navigate(['../'], { relativeTo: this.route });
  }
  
  // Navigate to another user
  goToUser(userId: number) {
    this.router.navigate(['../', userId], { relativeTo: this.route });
  }
}
```

**Standalone Components with Nested Routing:**

```typescript
// Modern approach with standalone components
const routes: Routes = [
  {
    path: 'dashboard',
    loadComponent: () => import('./dashboard/dashboard.component').then(c => c.DashboardComponent),
    children: [
      {
        path: 'overview',
        loadComponent: () => import('./overview/overview.component').then(c => c.OverviewComponent)
      },
      {
        path: 'analytics',
        loadComponent: () => import('./analytics/analytics.component').then(c => c.AnalyticsComponent)
      }
    ]
  }
];

@Component({
  selector: 'app-dashboard',
  standalone: true,
  imports: [RouterOutlet, RouterLink, RouterLinkActive],
  template: `
    <nav>
      <a routerLink="overview" routerLinkActive="active">Overview</a>
      <a routerLink="analytics" routerLinkActive="active">Analytics</a>
    </nav>
    <router-outlet></router-outlet>
  `
})
export class DashboardComponent {}
```

**Best Practices:**
- Keep nested routes logical and intuitive
- Use route guards appropriately at different levels
- Share data efficiently between parent and child routes
- Implement proper loading states for nested components
- Use relative navigation for better maintainability
- Consider lazy loading for deeply nested feature modules

[Back to Routing and Navigation](#routing-and-navigation)

### 63. Routing with standalone APIs

**Answer:**
Angular's standalone APIs revolutionize routing by eliminating the need for NgModules, making applications more modular and tree-shakable. Introduced in Angular 14+ and enhanced in Angular 15+.

**Bootstrapping with Standalone APIs:**

**1. Main Application Bootstrap:**
```typescript
// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { provideRouter } from '@angular/router';
import { routes } from './app/app.routes';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes),
    // Other providers
    provideHttpClient(),
    provideAnimations()
  ]
}).catch(err => console.error(err));
```

**2. Standalone App Component:**
```typescript
// app.component.ts
import { Component } from '@angular/core';
import { RouterOutlet, RouterLink } from '@angular/router';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, RouterOutlet, RouterLink],
  template: `
    <nav>
      <a routerLink="/home">Home</a>
      <a routerLink="/about">About</a>
      <a routerLink="/products">Products</a>
    </nav>
    <router-outlet></router-outlet>
  `
})
export class AppComponent {}
```

**Route Configuration with Standalone Components:**

**1. Basic Route Setup:**
```typescript
// app.routes.ts
import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';

export const routes: Routes = [
  {
    path: '',
    redirectTo: '/home',
    pathMatch: 'full'
  },
  {
    path: 'home',
    component: HomeComponent
  },
  {
    path: 'about',
    component: AboutComponent
  },
  {
    path: 'products',
    loadComponent: () => import('./products/products.component').then(c => c.ProductsComponent)
  }
];
```

**2. Lazy Loading with Standalone Components:**
```typescript
// Lazy load individual components
const routes: Routes = [
  {
    path: 'dashboard',
    loadComponent: () => import('./dashboard/dashboard.component').then(c => c.DashboardComponent)
  },
  {
    path: 'profile',
    loadComponent: () => import('./profile/profile.component').then(c => c.ProfileComponent)
  },
  // Lazy load entire feature routes
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.routes').then(r => r.adminRoutes)
  }
];
```

**3. Feature Routes:**
```typescript
// admin/admin.routes.ts
import { Routes } from '@angular/router';

export const adminRoutes: Routes = [
  {
    path: '',
    loadComponent: () => import('./admin-layout/admin-layout.component').then(c => c.AdminLayoutComponent),
    children: [
      {
        path: 'users',
        loadComponent: () => import('./users/users.component').then(c => c.UsersComponent)
      },
      {
        path: 'settings',
        loadComponent: () => import('./settings/settings.component').then(c => c.SettingsComponent)
      }
    ]
  }
];
```

**Standalone Components with Dependencies:**

```typescript
// product-list.component.ts
import { Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import { ProductService } from '../services/product.service';
import { ProductCardComponent } from './product-card.component';

@Component({
  selector: 'app-product-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterLink,
    ProductCardComponent
  ],
  template: `
    <div class="product-grid">
      <app-product-card 
        *ngFor="let product of products" 
        [product]="product"
        routerLink="/products/{{product.id}}">
      </app-product-card>
    </div>
  `
})
export class ProductListComponent {
  private productService = inject(ProductService);
  products = this.productService.getProducts();
}
```

**Guards with Standalone APIs:**

**1. Functional Guards:**
```typescript
// guards/auth.guard.ts
import { inject } from '@angular/core';
import { Router, CanActivateFn } from '@angular/router';
import { AuthService } from '../services/auth.service';

export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  if (authService.isLoggedIn()) {
    return true;
  }
  
  router.navigate(['/login']);
  return false;
};

export const adminGuard: CanActivateFn = () => {
  const authService = inject(AuthService);
  return authService.hasRole('admin');
};
```

**2. Using Guards in Routes:**
```typescript
// app.routes.ts
import { authGuard, adminGuard } from './guards/auth.guard';

export const routes: Routes = [
  {
    path: 'dashboard',
    loadComponent: () => import('./dashboard/dashboard.component').then(c => c.DashboardComponent),
    canActivate: [authGuard]
  },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.routes').then(r => r.adminRoutes),
    canActivate: [authGuard, adminGuard]
  }
];
```

**Resolvers with Standalone APIs:**

```typescript
// resolvers/user.resolver.ts
import { inject } from '@angular/core';
import { ResolveFn } from '@angular/router';
import { UserService } from '../services/user.service';
import { User } from '../models/user.model';

export const userResolver: ResolveFn<User> = (route, state) => {
  const userService = inject(UserService);
  const userId = route.paramMap.get('id')!;
  return userService.getUser(userId);
};

// Using in routes
const routes: Routes = [
  {
    path: 'user/:id',
    loadComponent: () => import('./user-detail/user-detail.component').then(c => c.UserDetailComponent),
    resolve: {
      user: userResolver
    }
  }
];
```

**Providers in Standalone Routing:**

**1. Route-Level Providers:**
```typescript
const routes: Routes = [
  {
    path: 'feature',
    loadComponent: () => import('./feature/feature.component').then(c => c.FeatureComponent),
    providers: [
      FeatureService,
      { provide: API_URL, useValue: 'https://api.feature.com' }
    ]
  }
];
```

**2. Application-Level Providers:**
```typescript
// main.ts
bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withEnabledBlockingInitialNavigation()),
    provideHttpClient(withInterceptors([authInterceptor])),
    provideAnimations(),
    // Custom providers
    AuthService,
    { provide: API_BASE_URL, useValue: 'https://api.example.com' }
  ]
});
```

**Router Configuration Options:**

```typescript
// main.ts with router features
import { 
  provideRouter, 
  withEnabledBlockingInitialNavigation,
  withHashLocation,
  withInMemoryScrolling,
  withPreloading,
  PreloadAllModules
} from '@angular/router';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(
      routes,
      withEnabledBlockingInitialNavigation(),
      withPreloading(PreloadAllModules),
      withInMemoryScrolling({
        scrollPositionRestoration: 'enabled'
      }),
      withHashLocation() // For hash-based routing
    )
  ]
});
```

**Testing Standalone Routes:**

```typescript
// component.spec.ts
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { provideRouter } from '@angular/router';
import { Component } from '@angular/core';
import { ProductListComponent } from './product-list.component';

@Component({ template: '' })
class MockComponent {}

describe('ProductListComponent', () => {
  let component: ProductListComponent;
  let fixture: ComponentFixture<ProductListComponent>;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ProductListComponent],
      providers: [
        provideRouter([
          { path: 'products/:id', component: MockComponent }
        ])
      ]
    }).compileComponents();
    
    fixture = TestBed.createComponent(ProductListComponent);
    component = fixture.componentInstance;
  });
  
  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
```

**Migration from Module-based to Standalone:**

```typescript
// Before (Module-based)
@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}

// After (Standalone)
export const routes: Routes = [...]; // Same routes

// main.ts
bootstrapApplication(AppComponent, {
  providers: [provideRouter(routes)]
});
```

**Benefits of Standalone Routing:**
- **Smaller bundle size** - Better tree shaking
- **Simplified architecture** - No NgModules needed
- **Better performance** - Lazy loading at component level
- **Easier testing** - Less boilerplate
- **Modern approach** - Future-proof Angular applications

[Back to Routing and Navigation](#routing-and-navigation)

### 64. `CanMatch` vs `CanLoad` vs `CanActivate`

**Answer:**
These three guards serve different purposes in Angular routing and run at different phases of the navigation process. Understanding when each executes is crucial for proper route protection.

**Execution Order and Timing:**

```
Navigation Process:
1. CanMatch → 2. CanLoad → 3. CanActivate
     ↓             ↓            ↓
 Route Matching → Module Loading → Component Activation
```

**CanMatch (Angular 14+):**

**Purpose**: Controls whether a route configuration should match the URL
**When it runs**: During route matching phase, before any loading
**What it controls**: Route selection and matching logic

```typescript
// can-match.guard.ts
import { inject } from '@angular/core';
import { CanMatchFn } from '@angular/router';
import { FeatureToggleService } from '../services/feature-toggle.service';

export const featureToggleGuard: CanMatchFn = (route, segments) => {
  const featureService = inject(FeatureToggleService);
  
  // Only match this route if feature is enabled
  return featureService.isEnabled('new-dashboard');
};

// Route configuration
const routes: Routes = [
  {
    path: 'dashboard',
    loadComponent: () => import('./new-dashboard.component').then(c => c.NewDashboardComponent),
    canMatch: [featureToggleGuard]
  },
  {
    path: 'dashboard', // Fallback route
    loadComponent: () => import('./old-dashboard.component').then(c => c.OldDashboardComponent)
  }
];
```

**Use Cases for CanMatch:**
- Feature toggles and A/B testing
- Conditional route configurations
- Environment-based routing
- User role-based route variations

**CanLoad (Deprecated in Angular 15+):**

**Purpose**: Controls whether a lazy-loaded module can be downloaded
**When it runs**: Before module loading, after route matching
**What it controls**: Module download and loading

```typescript
// can-load.guard.ts (Legacy approach)
@Injectable()
export class AdminCanLoadGuard implements CanLoad {
  constructor(private authService: AuthService, private router: Router) {}
  
  canLoad(route: Route, segments: UrlSegment[]): boolean {
    if (this.authService.hasAdminRole()) {
      return true;
    }
    
    this.router.navigate(['/unauthorized']);
    return false; // Module won't be downloaded
  }
}

// Route configuration
const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    canLoad: [AdminCanLoadGuard]
  }
];
```

**CanActivate:**

**Purpose**: Controls whether a route can be activated (component instantiated)
**When it runs**: After module loading, before component activation
**What it controls**: Component instantiation and route access

```typescript
// can-activate.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from '../services/auth.service';

export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  if (authService.isAuthenticated()) {
    return true;
  }
  
  // Redirect to login with return URL
  router.navigate(['/login'], { 
    queryParams: { returnUrl: state.url } 
  });
  return false;
};

// Route configuration
const routes: Routes = [
  {
    path: 'profile',
    component: ProfileComponent,
    canActivate: [authGuard]
  }
];
```

**Detailed Comparison:**

| Aspect | CanMatch | CanLoad | CanActivate |
|--------|----------|---------|-------------|
| **Execution Phase** | Route matching | Module loading | Component activation |
| **Prevents** | Route matching | Module download | Component creation |
| **Network Impact** | No download | Prevents download | Downloads but no activation |
| **Use Case** | Route selection | Access control | Authentication/Authorization |
| **Angular Version** | 14+ | Legacy (deprecated) | All versions |
| **Return URL** | Not applicable | Not preserved | Can preserve |
| **Performance** | Best | Good | Downloads unnecessarily |

**Practical Examples:**

**1. Feature Toggle with CanMatch:**
```typescript
const routes: Routes = [
  {
    path: 'beta-feature',
    loadComponent: () => import('./beta-feature.component').then(c => c.BetaFeatureComponent),
    canMatch: [(route, segments) => {
      return inject(FeatureService).isBetaEnabled();
    }]
  },
  {
    path: 'beta-feature', // Fallback
    component: ComingSoonComponent
  }
];
```

**2. Role-based Access with CanActivate:**
```typescript
const adminGuard: CanActivateFn = () => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  if (authService.hasRole('admin')) {
    return true;
  }
  
  router.navigate(['/access-denied']);
  return false;
};

const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.routes').then(r => r.adminRoutes),
    canActivate: [adminGuard]
  }
];
```

**3. Migration from CanLoad to CanMatch:**
```typescript
// Old approach with CanLoad
const routes: Routes = [
  {
    path: 'premium',
    loadChildren: () => import('./premium/premium.module').then(m => m.PremiumModule),
    canLoad: [PremiumGuard] // Deprecated
  }
];

// New approach with CanMatch
const routes: Routes = [
  {
    path: 'premium',
    loadChildren: () => import('./premium/premium.routes').then(r => r.premiumRoutes),
    canMatch: [premiumGuard] // Modern approach
  }
];
```

**Best Practices:**

**✅ Use CanMatch for:**
- Feature flags and toggles
- A/B testing scenarios
- Environment-specific routes
- Preventing unnecessary downloads

**✅ Use CanActivate for:**
- Authentication checks
- Authorization and permissions
- Data validation before component load
- User state verification

**❌ Avoid CanLoad:**
- Deprecated in Angular 15+
- Use CanMatch instead for better performance
- Less flexible than modern alternatives

**Combined Usage:**
```typescript
const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.routes').then(r => r.adminRoutes),
    canMatch: [featureEnabledGuard], // Check if admin feature is enabled
    canActivate: [authGuard, adminRoleGuard] // Check auth and permissions
  }
];
```

**Migration Strategy:**
1. Replace `CanLoad` with `CanMatch` for route matching logic
2. Use `CanActivate` for authentication/authorization
3. Combine both when needed for comprehensive protection
4. Test thoroughly to ensure proper guard execution order

[Back to Routing and Navigation](#routing-and-navigation)

### 65. What are preloading strategies and how to implement custom preloader?

**Answer:**
Preloading strategies determine when and how Angular loads lazy-loaded modules in the background, improving perceived performance by loading modules before they're needed.

**Built-in Preloading Strategies:**

**1. NoPreloading (Default):**
```typescript
// No preloading - modules loaded only when navigated to
import { provideRouter, NoPreloading } from '@angular/router';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withPreloading(NoPreloading))
  ]
});
```

**2. PreloadAllModules:**
```typescript
// Preloads all lazy modules after initial navigation
import { provideRouter, PreloadAllModules } from '@angular/router';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withPreloading(PreloadAllModules))
  ]
});
```

**Custom Preloading Strategies:**

**1. Selective Preloading Strategy:**
```typescript
// selective-preload.strategy.ts
import { Injectable } from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { Observable, of } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class SelectivePreloadingStrategy implements PreloadingStrategy {
  preloadedModules: string[] = [];
  
  preload(route: Route, fn: () => Observable<any>): Observable<any> {
    // Only preload routes with preload: true in data
    if (route.data && route.data['preload']) {
      console.log('Preloading: ' + route.path);
      this.preloadedModules.push(route.path!);
      return fn();
    } else {
      return of(null);
    }
  }
}

// Route configuration
const routes: Routes = [
  {
    path: 'dashboard',
    loadChildren: () => import('./dashboard/dashboard.routes').then(r => r.dashboardRoutes),
    data: { preload: true } // Will be preloaded
  },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.routes').then(r => r.adminRoutes),
    data: { preload: false } // Won't be preloaded
  },
  {
    path: 'reports',
    loadChildren: () => import('./reports/reports.routes').then(r => r.reportsRoutes)
    // No preload data - won't be preloaded
  }
];

// Usage
bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withPreloading(SelectivePreloadingStrategy))
  ]
});
```

**2. Network-Aware Preloading:**
```typescript
// network-aware-preload.strategy.ts
import { Injectable } from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { Observable, of } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class NetworkAwarePreloadingStrategy implements PreloadingStrategy {
  
  preload(route: Route, fn: () => Observable<any>): Observable<any> {
    // Check network conditions
    if (this.hasGoodConnection()) {
      console.log(`Preloading ${route.path} - good connection`);
      return fn();
    } else {
      console.log(`Skipping preload of ${route.path} - poor connection`);
      return of(null);
    }
  }
  
  private hasGoodConnection(): boolean {
    // Check if navigator.connection is available (Chrome/Edge)
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      
      // Don't preload on slow connections
      if (connection.effectiveType === 'slow-2g' || 
          connection.effectiveType === '2g') {
        return false;
      }
      
      // Don't preload if user has data saver enabled
      if (connection.saveData) {
        return false;
      }
    }
    
    return true;
  }
}
```

**3. Priority-Based Preloading:**
```typescript
// priority-preload.strategy.ts
import { Injectable } from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { Observable, of, timer } from 'rxjs';
import { mergeMap } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class PriorityPreloadingStrategy implements PreloadingStrategy {
  
  preload(route: Route, fn: () => Observable<any>): Observable<any> {
    const priority = route.data?.['priority'] || 'low';
    const delay = this.getDelayForPriority(priority);
    
    if (priority === 'none') {
      return of(null);
    }
    
    console.log(`Preloading ${route.path} with ${priority} priority (delay: ${delay}ms)`);
    
    return timer(delay).pipe(
      mergeMap(() => fn())
    );
  }
  
  private getDelayForPriority(priority: string): number {
    switch (priority) {
      case 'high': return 0;
      case 'medium': return 2000;
      case 'low': return 5000;
      default: return 10000;
    }
  }
}

// Route configuration with priorities
const routes: Routes = [
  {
    path: 'dashboard',
    loadChildren: () => import('./dashboard/dashboard.routes').then(r => r.dashboardRoutes),
    data: { priority: 'high' } // Preload immediately
  },
  {
    path: 'profile',
    loadChildren: () => import('./profile/profile.routes').then(r => r.profileRoutes),
    data: { priority: 'medium' } // Preload after 2 seconds
  },
  {
    path: 'settings',
    loadChildren: () => import('./settings/settings.routes').then(r => r.settingsRoutes),
    data: { priority: 'low' } // Preload after 5 seconds
  },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.routes').then(r => r.adminRoutes),
    data: { priority: 'none' } // Never preload
  }
];
```

**4. User Behavior-Based Preloading:**
```typescript
// behavior-preload.strategy.ts
import { Injectable } from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { Observable, of } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class BehaviorPreloadingStrategy implements PreloadingStrategy {
  private userInteractions = 0;
  private preloadedRoutes = new Set<string>();
  
  constructor() {
    // Track user interactions
    this.trackUserActivity();
  }
  
  preload(route: Route, fn: () => Observable<any>): Observable<any> {
    const routePath = route.path!;
    
    // Don't preload if already preloaded
    if (this.preloadedRoutes.has(routePath)) {
      return of(null);
    }
    
    // Preload based on user activity level
    if (this.shouldPreloadBasedOnActivity(route)) {
      console.log(`Preloading ${routePath} based on user activity`);
      this.preloadedRoutes.add(routePath);
      return fn();
    }
    
    return of(null);
  }
  
  private shouldPreloadBasedOnActivity(route: Route): boolean {
    const minInteractions = route.data?.['minInteractions'] || 5;
    return this.userInteractions >= minInteractions;
  }
  
  private trackUserActivity(): void {
    ['click', 'keydown', 'scroll', 'mousemove'].forEach(event => {
      document.addEventListener(event, () => {
        this.userInteractions++;
      }, { passive: true });
    });
  }
}
```

**5. Time-Based Preloading:**
```typescript
// time-based-preload.strategy.ts
import { Injectable } from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { Observable, of, timer } from 'rxjs';
import { mergeMap } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class TimeBasedPreloadingStrategy implements PreloadingStrategy {
  
  preload(route: Route, fn: () => Observable<any>): Observable<any> {
    const preloadAfter = route.data?.['preloadAfter'] || 0;
    
    if (preloadAfter === -1) {
      return of(null); // Don't preload
    }
    
    console.log(`Preloading ${route.path} after ${preloadAfter}ms`);
    
    return timer(preloadAfter).pipe(
      mergeMap(() => fn())
    );
  }
}

// Route configuration
const routes: Routes = [
  {
    path: 'immediate',
    loadChildren: () => import('./immediate/immediate.routes').then(r => r.immediateRoutes),
    data: { preloadAfter: 0 } // Preload immediately
  },
  {
    path: 'delayed',
    loadChildren: () => import('./delayed/delayed.routes').then(r => r.delayedRoutes),
    data: { preloadAfter: 3000 } // Preload after 3 seconds
  },
  {
    path: 'never',
    loadChildren: () => import('./never/never.routes').then(r => r.neverRoutes),
    data: { preloadAfter: -1 } // Never preload
  }
];
```

**Monitoring Preloading:**

```typescript
// preload-monitor.service.ts
import { Injectable } from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { filter } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class PreloadMonitorService {
  private preloadedModules: string[] = [];
  private loadTimes: Map<string, number> = new Map();
  
  constructor(private router: Router) {
    this.trackNavigationPerformance();
  }
  
  recordPreload(moduleName: string): void {
    this.preloadedModules.push(moduleName);
    console.log(`Preloaded modules: ${this.preloadedModules.join(', ')}`);
  }
  
  private trackNavigationPerformance(): void {
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd)
    ).subscribe((event: NavigationEnd) => {
      const loadTime = performance.now();
      this.loadTimes.set(event.url, loadTime);
      
      if (this.preloadedModules.some(module => event.url.includes(module))) {
        console.log(`Fast navigation to ${event.url} - module was preloaded`);
      } else {
        console.log(`Standard navigation to ${event.url} - module loaded on demand`);
      }
    });
  }
  
  getPreloadStats(): any {
    return {
      preloadedCount: this.preloadedModules.length,
      preloadedModules: this.preloadedModules,
      averageLoadTime: this.calculateAverageLoadTime()
    };
  }
  
  private calculateAverageLoadTime(): number {
    const times = Array.from(this.loadTimes.values());
    return times.reduce((sum, time) => sum + time, 0) / times.length;
  }
}
```

**Testing Preloading Strategies:**

```typescript
// preload.strategy.spec.ts
import { TestBed } from '@angular/core/testing';
import { Route } from '@angular/router';
import { of } from 'rxjs';
import { SelectivePreloadingStrategy } from './selective-preload.strategy';

describe('SelectivePreloadingStrategy', () => {
  let strategy: SelectivePreloadingStrategy;
  
  beforeEach(() => {
    TestBed.configureTestingModule({});
    strategy = TestBed.inject(SelectivePreloadingStrategy);
  });
  
  it('should preload routes with preload: true', () => {
    const route: Route = {
      path: 'test',
      data: { preload: true }
    };
    
    const loadFn = jasmine.createSpy('loadFn').and.returnValue(of('loaded'));
    
    strategy.preload(route, loadFn).subscribe();
    
    expect(loadFn).toHaveBeenCalled();
    expect(strategy.preloadedModules).toContain('test');
  });
  
  it('should not preload routes with preload: false', () => {
    const route: Route = {
      path: 'test',
      data: { preload: false }
    };
    
    const loadFn = jasmine.createSpy('loadFn');
    
    strategy.preload(route, loadFn).subscribe();
    
    expect(loadFn).not.toHaveBeenCalled();
  });
});
```

**Best Practices:**
- Use network-aware preloading for mobile users
- Implement priority-based loading for critical features
- Monitor preloading effectiveness with analytics
- Consider user behavior patterns when designing strategies
- Test preloading strategies across different network conditions
- Combine multiple strategies for optimal performance

[Back to Routing and Navigation](#routing-and-navigation)

### 66. How do you handle route resolvers?

**Answer:**
Route resolvers are services that fetch data before a route is activated, ensuring that required data is available when the component initializes. They prevent components from rendering in a loading state.

**Basic Resolver Implementation:**

**1. Creating a Resolver (Angular 14+ Functional Approach):**
```typescript
// user.resolver.ts
import { inject } from '@angular/core';
import { ResolveFn } from '@angular/router';
import { Observable } from 'rxjs';
import { UserService } from '../services/user.service';
import { User } from '../models/user.model';

export const userResolver: ResolveFn<User> = (route, state) => {
  const userService = inject(UserService);
  const userId = route.paramMap.get('id')!;
  
  console.log(`Resolving user data for ID: ${userId}`);
  return userService.getUser(userId);
};

// Multiple data resolver
export const userProfileResolver: ResolveFn<{user: User, posts: Post[]}> = (route, state) => {
  const userService = inject(UserService);
  const postService = inject(PostService);
  const userId = route.paramMap.get('id')!;
  
  return forkJoin({
    user: userService.getUser(userId),
    posts: postService.getUserPosts(userId)
  });
};
```

**2. Class-Based Resolver (Legacy Approach):**
```typescript
// user.resolver.ts
import { Injectable } from '@angular/core';
import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { Observable } from 'rxjs';
import { UserService } from '../services/user.service';
import { User } from '../models/user.model';

@Injectable({ providedIn: 'root' })
export class UserResolver implements Resolve<User> {
  constructor(private userService: UserService) {}
  
  resolve(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<User> | Promise<User> | User {
    const userId = route.paramMap.get('id')!;
    return this.userService.getUser(userId);
  }
}
```

**3. Route Configuration with Resolvers:**
```typescript
// app.routes.ts
import { Routes } from '@angular/router';
import { userResolver, userProfileResolver } from './resolvers/user.resolver';

export const routes: Routes = [
  {
    path: 'user/:id',
    component: UserDetailComponent,
    resolve: {
      user: userResolver
    }
  },
  {
    path: 'profile/:id',
    component: UserProfileComponent,
    resolve: {
      data: userProfileResolver // Resolves multiple pieces of data
    }
  }
];
```

**Accessing Resolved Data in Components:**

**1. Using ActivatedRoute:**
```typescript
// user-detail.component.ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { User } from '../models/user.model';

@Component({
  selector: 'app-user-detail',
  template: `
    <div *ngIf="user">
      <h1>{{user.name}}</h1>
      <p>{{user.email}}</p>
      <p>Role: {{user.role}}</p>
    </div>
  `
})
export class UserDetailComponent implements OnInit {
  user: User;
  
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit(): void {
    // Access resolved data
    this.user = this.route.snapshot.data['user'];
    
    // Or subscribe to data changes
    this.route.data.subscribe(data => {
      this.user = data['user'];
    });
  }
}
```

**2. Using Input Signals (Angular 16+):**
```typescript
// user-detail.component.ts
import { Component, input } from '@angular/core';
import { User } from '../models/user.model';

@Component({
  selector: 'app-user-detail',
  template: `
    <div>
      <h1>{{user().name}}</h1>
      <p>{{user().email}}</p>
    </div>
  `
})
export class UserDetailComponent {
  // Automatically receives resolved data
  user = input.required<User>();
}
```

**Advanced Resolver Patterns:**

**1. Error Handling in Resolvers:**
```typescript
// user-with-error-handling.resolver.ts
import { inject } from '@angular/core';
import { ResolveFn, Router } from '@angular/router';
import { catchError, EMPTY } from 'rxjs';
import { UserService } from '../services/user.service';

export const userWithErrorHandlingResolver: ResolveFn<User | null> = (route, state) => {
  const userService = inject(UserService);
  const router = inject(Router);
  const userId = route.paramMap.get('id')!;
  
  return userService.getUser(userId).pipe(
    catchError(error => {
      console.error('Failed to load user:', error);
      
      // Redirect to error page
      router.navigate(['/user-not-found']);
      
      // Return empty to prevent navigation
      return EMPTY;
      
      // Or return null to continue with null data
      // return of(null);
    })
  );
};
```

**2. Conditional Resolving:**
```typescript
// conditional.resolver.ts
export const conditionalDataResolver: ResolveFn<any> = (route, state) => {
  const authService = inject(AuthService);
  const dataService = inject(DataService);
  
  // Only resolve data if user is authenticated
  if (authService.isAuthenticated()) {
    return dataService.getSensitiveData();
  }
  
  return of(null);
};
```

**3. Dependent Resolvers:**
```typescript
// dependent-data.resolver.ts
export const dependentDataResolver: ResolveFn<any> = (route, state) => {
  const userService = inject(UserService);
  const preferencesService = inject(PreferencesService);
  const userId = route.paramMap.get('id')!;
  
  // First get user, then get their preferences
  return userService.getUser(userId).pipe(
    switchMap(user => 
      preferencesService.getUserPreferences(user.id).pipe(
        map(preferences => ({ user, preferences }))
      )
    )
  );
};
```

**4. Caching Resolver:**
```typescript
// cached-data.resolver.ts
import { inject } from '@angular/core';
import { ResolveFn } from '@angular/router';
import { of } from 'rxjs';
import { tap } from 'rxjs/operators';

const cache = new Map<string, any>();

export const cachedDataResolver: ResolveFn<any> = (route, state) => {
  const dataService = inject(DataService);
  const cacheKey = route.paramMap.get('id')!;
  
  // Return cached data if available
  if (cache.has(cacheKey)) {
    console.log('Returning cached data');
    return of(cache.get(cacheKey));
  }
  
  // Fetch and cache data
  return dataService.getData(cacheKey).pipe(
    tap(data => {
      console.log('Caching data');
      cache.set(cacheKey, data);
    })
  );
};
```

**Loading States with Resolvers:**

**1. Global Loading Indicator:**
```typescript
// loading.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class LoadingService {
  private loadingSubject = new BehaviorSubject<boolean>(false);
  loading$ = this.loadingSubject.asObservable();
  
  setLoading(loading: boolean): void {
    this.loadingSubject.next(loading);
  }
}

// loading-resolver.ts
export const loadingResolver: ResolveFn<any> = (route, state) => {
  const dataService = inject(DataService);
  const loadingService = inject(LoadingService);
  
  loadingService.setLoading(true);
  
  return dataService.getData().pipe(
    finalize(() => loadingService.setLoading(false))
  );
};
```

**2. Route-Specific Loading:**
```typescript
// app.component.ts
@Component({
  selector: 'app-root',
  template: `
    <div class="loading-overlay" *ngIf="isRouteLoading">
      <div class="spinner">Loading...</div>
    </div>
    <router-outlet></router-outlet>
  `
})
export class AppComponent {
  isRouteLoading = false;
  
  constructor(private router: Router) {
    router.events.subscribe(event => {
      if (event instanceof RouteConfigLoadStart) {
        this.isRouteLoading = true;
      } else if (event instanceof RouteConfigLoadEnd) {
        this.isRouteLoading = false;
      }
    });
  }
}
```

**Testing Resolvers:**

```typescript
// user.resolver.spec.ts
import { TestBed } from '@angular/core/testing';
import { ActivatedRouteSnapshot } from '@angular/router';
import { of } from 'rxjs';
import { UserService } from '../services/user.service';
import { userResolver } from './user.resolver';

describe('userResolver', () => {
  let userService: jasmine.SpyObj<UserService>;
  
  beforeEach(() => {
    const spy = jasmine.createSpyObj('UserService', ['getUser']);
    
    TestBed.configureTestingModule({
      providers: [
        { provide: UserService, useValue: spy }
      ]
    });
    
    userService = TestBed.inject(UserService) as jasmine.SpyObj<UserService>;
  });
  
  it('should resolve user data', () => {
    const mockUser = { id: '1', name: 'John Doe', email: 'john@example.com' };
    const route = {
      paramMap: {
        get: (key: string) => key === 'id' ? '1' : null
      }
    } as any;
    
    userService.getUser.and.returnValue(of(mockUser));
    
    const result = TestBed.runInInjectionContext(() => {
      return userResolver(route, {} as any);
    });
    
    result.subscribe(user => {
      expect(user).toEqual(mockUser);
      expect(userService.getUser).toHaveBeenCalledWith('1');
    });
  });
});
```

**Performance Considerations:**

**1. Parallel Data Loading:**
```typescript
export const parallelDataResolver: ResolveFn<any> = (route, state) => {
  const userService = inject(UserService);
  const postService = inject(PostService);
  const commentService = inject(CommentService);
  const userId = route.paramMap.get('id')!;
  
  // Load data in parallel for better performance
  return forkJoin({
    user: userService.getUser(userId),
    posts: postService.getUserPosts(userId),
    comments: commentService.getUserComments(userId)
  });
};
```

**2. Selective Data Loading:**
```typescript
export const selectiveDataResolver: ResolveFn<any> = (route, state) => {
  const dataService = inject(DataService);
  const includeDetails = route.queryParamMap.get('details') === 'true';
  
  if (includeDetails) {
    return dataService.getDetailedData();
  } else {
    return dataService.getBasicData();
  }
};
```

**Best Practices:**
- Use resolvers for critical data that must be available before component initialization
- Implement proper error handling in resolvers
- Consider caching strategies for frequently accessed data
- Use loading indicators for better user experience
- Keep resolvers focused on single responsibilities
- Test resolvers thoroughly with different scenarios
- Use parallel loading when data is independent

[Back to Routing and Navigation](#routing-and-navigation)

### 67. What are auxiliary routes?

**Answer:**
Auxiliary routes (also called secondary routes) allow you to display multiple routed components simultaneously in different router outlets. This enables complex layouts with independent navigation areas like sidebars, modals, or popup content.

**Basic Auxiliary Route Setup:**

**1. Multiple Router Outlets:**
```typescript
// app.component.ts
@Component({
  selector: 'app-root',
  template: `
    <div class="app-layout">
      <nav>
        <a routerLink="/products">Products</a>
        <a routerLink="/users">Users</a>
        <!-- Auxiliary route navigation -->
        <a routerLink="[{outlets: {sidebar: 'help'}}]">Help</a>
        <a routerLink="[{outlets: {sidebar: 'settings'}}]">Settings</a>
        <a routerLink="[{outlets: {sidebar: null}}]">Close Sidebar</a>
      </nav>
      
      <div class="content-area">
        <!-- Primary outlet -->
        <main>
          <router-outlet></router-outlet>
        </main>
        
        <!-- Auxiliary outlet -->
        <aside class="sidebar">
          <router-outlet name="sidebar"></router-outlet>
        </aside>
        
        <!-- Modal outlet -->
        <div class="modal-container">
          <router-outlet name="modal"></router-outlet>
        </div>
      </div>
    </div>
  `,
  styles: [`
    .app-layout { display: flex; flex-direction: column; height: 100vh; }
    .content-area { display: flex; flex: 1; }
    main { flex: 1; padding: 20px; }
    .sidebar { width: 300px; background: #f5f5f5; padding: 20px; }
    .modal-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
  `]
})
export class AppComponent {}
```

**2. Route Configuration:**
```typescript
// app.routes.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  // Primary routes
  { path: 'products', component: ProductsComponent },
  { path: 'users', component: UsersComponent },
  { path: 'dashboard', component: DashboardComponent },
  
  // Auxiliary routes for sidebar
  { path: 'help', component: HelpComponent, outlet: 'sidebar' },
  { path: 'settings', component: SettingsComponent, outlet: 'sidebar' },
  { path: 'profile', component: ProfileComponent, outlet: 'sidebar' },
  
  // Auxiliary routes for modal
  { path: 'user/:id/edit', component: UserEditModalComponent, outlet: 'modal' },
  { path: 'product/:id/details', component: ProductDetailsModalComponent, outlet: 'modal' },
  
  // Default routes
  { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
  { path: '**', component: NotFoundComponent }
];
```

**Navigation with Auxiliary Routes:**

**1. Programmatic Navigation:**
```typescript
// navigation.service.ts
import { Injectable } from '@angular/core';
import { Router } from '@angular/router';

@Injectable({ providedIn: 'root' })
export class NavigationService {
  constructor(private router: Router) {}
  
  // Open sidebar with help content
  openHelp(): void {
    this.router.navigate([{ outlets: { sidebar: 'help' } }]);
  }
  
  // Open settings in sidebar while keeping primary route
  openSettings(): void {
    this.router.navigate([{ outlets: { sidebar: 'settings' } }]);
  }
  
  // Close sidebar
  closeSidebar(): void {
    this.router.navigate([{ outlets: { sidebar: null } }]);
  }
  
  // Open modal while preserving other routes
  openUserEditModal(userId: number): void {
    this.router.navigate([{ outlets: { modal: ['user', userId, 'edit'] } }]);
  }
  
  // Navigate primary and auxiliary routes simultaneously
  navigateToDashboardWithHelp(): void {
    this.router.navigate([
      { outlets: { primary: 'dashboard', sidebar: 'help' } }
    ]);
  }
  
  // Complex navigation with multiple outlets
  openComplexView(productId: number): void {
    this.router.navigate([
      { outlets: {
        primary: ['products', productId],
        sidebar: 'product-info',
        modal: ['product', productId, 'details']
      }}
    ]);
  }
}
```

**2. Template-Based Navigation:**
```typescript
// navigation.component.ts
@Component({
  selector: 'app-navigation',
  template: `
    <nav class="main-nav">
      <!-- Primary navigation -->
      <div class="primary-nav">
        <a routerLink="/dashboard" routerLinkActive="active">Dashboard</a>
        <a routerLink="/products" routerLinkActive="active">Products</a>
        <a routerLink="/users" routerLinkActive="active">Users</a>
      </div>
      
      <!-- Auxiliary navigation -->
      <div class="auxiliary-nav">
        <button (click)="toggleSidebar('help')">Help</button>
        <button (click)="toggleSidebar('settings')">Settings</button>
        <button (click)="closeSidebar()">Close Sidebar</button>
      </div>
      
      <!-- Direct auxiliary links -->
      <div class="direct-links">
        <a [routerLink]="[{outlets: {sidebar: 'help'}}]">Direct Help Link</a>
        <a [routerLink]="[{outlets: {sidebar: 'settings'}}]">Direct Settings Link</a>
        <a [routerLink]="[{outlets: {sidebar: null}}]">Close Sidebar</a>
      </div>
    </nav>
  `
})
export class NavigationComponent {
  constructor(private router: Router) {}
  
  toggleSidebar(route: string): void {
    this.router.navigate([{ outlets: { sidebar: route } }]);
  }
  
  closeSidebar(): void {
    this.router.navigate([{ outlets: { sidebar: null } }]);
  }
}
```

**Advanced Auxiliary Route Patterns:**

**1. Nested Auxiliary Routes:**
```typescript
const routes: Routes = [
  {
    path: 'admin',
    component: AdminLayoutComponent,
    children: [
      { path: 'users', component: AdminUsersComponent },
      { path: 'products', component: AdminProductsComponent },
      // Auxiliary routes within admin section
      { path: 'tools', component: AdminToolsComponent, outlet: 'admin-sidebar' },
      { path: 'logs', component: AdminLogsComponent, outlet: 'admin-sidebar' }
    ]
  }
];

// admin-layout.component.ts
@Component({
  template: `
    <div class="admin-layout">
      <main><router-outlet></router-outlet></main>
      <aside><router-outlet name="admin-sidebar"></router-outlet></aside>
    </div>
  `
})
export class AdminLayoutComponent {}
```

**2. Modal Management with Auxiliary Routes:**
```typescript
// modal.service.ts
import { Injectable } from '@angular/core';
import { Router } from '@angular/router';
import { Subject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class ModalService {
  private modalStack: string[] = [];
  private modalClosed$ = new Subject<string>();
  
  constructor(private router: Router) {}
  
  openModal(modalRoute: string): void {
    this.modalStack.push(modalRoute);
    this.router.navigate([{ outlets: { modal: modalRoute } }]);
  }
  
  closeModal(): void {
    const closedModal = this.modalStack.pop();
    if (closedModal) {
      this.modalClosed$.next(closedModal);
    }
    
    if (this.modalStack.length > 0) {
      // Show previous modal
      const previousModal = this.modalStack[this.modalStack.length - 1];
      this.router.navigate([{ outlets: { modal: previousModal } }]);
    } else {
      // Close all modals
      this.router.navigate([{ outlets: { modal: null } }]);
    }
  }
  
  closeAllModals(): void {
    this.modalStack = [];
    this.router.navigate([{ outlets: { modal: null } }]);
  }
  
  get modalClosed() {
    return this.modalClosed$.asObservable();
  }
}
```

**3. Dynamic Auxiliary Route Loading:**
```typescript
// dynamic-content.service.ts
@Injectable({ providedIn: 'root' })
export class DynamicContentService {
  constructor(private router: Router) {}
  
  loadContentInSidebar(contentType: string, params?: any): void {
    let route: any[];
    
    switch (contentType) {
      case 'user-details':
        route = ['user-details', params.userId];
        break;
      case 'product-info':
        route = ['product-info', params.productId];
        break;
      case 'notifications':
        route = ['notifications'];
        break;
      default:
        route = ['default-content'];
    }
    
    this.router.navigate([{ outlets: { sidebar: route } }]);
  }
  
  loadMultipleAuxiliaryRoutes(config: {[outlet: string]: any[]}): void {
    this.router.navigate([{ outlets: config }]);
  }
}
```

**URL Structure with Auxiliary Routes:**

```typescript
// URL examples with auxiliary routes:

// Primary route only
// /products

// Primary route with sidebar
// /products/(sidebar:help)

// Primary route with multiple auxiliary routes
// /products/(sidebar:help//modal:product/123/details)

// Complex URL with nested routes
// /admin/users/(admin-sidebar:tools//modal:user/456/edit)

// parsing auxiliary routes
@Component({})
export class RouteParserComponent implements OnInit {
  constructor(private route: ActivatedRoute) {}
  
  ngOnInit(): void {
    // Access auxiliary route parameters
    this.route.children.forEach(child => {
      if (child.outlet === 'sidebar') {
        child.params.subscribe(params => {
          console.log('Sidebar params:', params);
        });
      }
    });
  }
}
```

**State Management with Auxiliary Routes:**

```typescript
// auxiliary-route-state.service.ts
@Injectable({ providedIn: 'root' })
export class AuxiliaryRouteStateService {
  private sidebarState = new BehaviorSubject<string | null>(null);
  private modalState = new BehaviorSubject<string | null>(null);
  
  sidebarState$ = this.sidebarState.asObservable();
  modalState$ = this.modalState.asObservable();
  
  constructor(private router: Router) {
    // Track auxiliary route changes
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd)
    ).subscribe(() => {
      this.updateAuxiliaryStates();
    });
  }
  
  private updateAuxiliaryStates(): void {
    const urlTree = this.router.parseUrl(this.router.url);
    
    // Update sidebar state
    const sidebarSegments = urlTree.root.children['sidebar'];
    this.sidebarState.next(
      sidebarSegments ? sidebarSegments.segments.map(s => s.path).join('/') : null
    );
    
    // Update modal state
    const modalSegments = urlTree.root.children['modal'];
    this.modalState.next(
      modalSegments ? modalSegments.segments.map(s => s.path).join('/') : null
    );
  }
}
```

**Testing Auxiliary Routes:**

```typescript
// auxiliary-routes.spec.ts
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { Router } from '@angular/router';
import { Location } from '@angular/common';
import { Component } from '@angular/core';
import { RouterTestingModule } from '@angular/router/testing';

@Component({ template: 'Main' })
class MainComponent {}

@Component({ template: 'Sidebar' })
class SidebarComponent {}

describe('Auxiliary Routes', () => {
  let router: Router;
  let location: Location;
  let fixture: ComponentFixture<any>;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [
        RouterTestingModule.withRoutes([
          { path: 'main', component: MainComponent },
          { path: 'sidebar', component: SidebarComponent, outlet: 'sidebar' }
        ])
      ],
      declarations: [MainComponent, SidebarComponent]
    }).compileComponents();
    
    router = TestBed.inject(Router);
    location = TestBed.inject(Location);
    fixture = TestBed.createComponent(AppComponent);
  });
  
  it('should navigate to auxiliary route', async () => {
    await router.navigate([{ outlets: { sidebar: 'sidebar' } }]);
    expect(location.path()).toBe('/(sidebar:sidebar)');
  });
  
  it('should navigate to primary and auxiliary routes', async () => {
    await router.navigate([{ outlets: { primary: 'main', sidebar: 'sidebar' } }]);
    expect(location.path()).toBe('/main/(sidebar:sidebar)');
  });
});
```

**Use Cases for Auxiliary Routes:**
- **Sidebars**: Help content, navigation, filters
- **Modals**: Edit forms, details, confirmations
- **Chat widgets**: Customer support, notifications
- **Multi-panel layouts**: Email clients, IDEs
- **Dashboard widgets**: Independent content areas
- **Popup content**: Context-sensitive information

**Best Practices:**
- Keep auxiliary routes focused and lightweight
- Use clear naming conventions for outlets
- Implement proper state management for complex layouts
- Consider mobile responsiveness with auxiliary routes
- Test navigation scenarios thoroughly
- Use auxiliary routes sparingly to avoid URL complexity

[Back to Routing and Navigation](#routing-and-navigation)

### 68. How do you implement route animations?

**Answer:**
Route animations provide smooth visual transitions between different views in Angular applications, enhancing user experience and providing visual continuity during navigation.

**Basic Route Animation Setup:**

**1. Animation Configuration:**
```typescript
// animations/route-animations.ts
import {
  trigger,
  transition,
  style,
  query,
  group,
  animate,
  keyframes
} from '@angular/animations';

export const slideInAnimation = trigger('routeAnimations', [
  // Slide transition
  transition('* <=> *', [
    query(':enter, :leave', [
      style({
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%'
      })
    ], { optional: true }),
    
    query(':enter', [
      style({ left: '100%' })
    ], { optional: true }),
    
    group([
      query(':leave', [
        animate('300ms ease-in', style({ left: '-100%' }))
      ], { optional: true }),
      
      query(':enter', [
        animate('300ms ease-in', style({ left: '0%' }))
      ], { optional: true })
    ])
  ])
]);

// Fade transition
export const fadeAnimation = trigger('fadeAnimation', [
  transition('* <=> *', [
    query(':enter, :leave', [
      style({ position: 'absolute', width: '100%' })
    ], { optional: true }),
    
    group([
      query(':leave', [
        animate('200ms ease-out', style({ opacity: 0 }))
      ], { optional: true }),
      
      query(':enter', [
        style({ opacity: 0 }),
        animate('200ms ease-in', style({ opacity: 1 }))
      ], { optional: true })
    ])
  ])
]);
```

**2. Route Configuration with Animation Data:**
```typescript
// app.routes.ts
export const routes: Routes = [
  {
    path: 'home',
    component: HomeComponent,
    data: { animation: 'HomePage' }
  },
  {
    path: 'about',
    component: AboutComponent,
    data: { animation: 'AboutPage' }
  },
  {
    path: 'products',
    component: ProductsComponent,
    data: { animation: 'ProductsPage' }
  },
  {
    path: 'contact',
    component: ContactComponent,
    data: { animation: 'ContactPage' }
  }
];
```

**3. App Component with Animation:**
```typescript
// app.component.ts
import { Component } from '@angular/core';
import { Router, ChildrenOutletContexts } from '@angular/router';
import { slideInAnimation } from './animations/route-animations';

@Component({
  selector: 'app-root',
  template: `
    <nav>
      <a routerLink="/home" routerLinkActive="active">Home</a>
      <a routerLink="/about" routerLinkActive="active">About</a>
      <a routerLink="/products" routerLinkActive="active">Products</a>
      <a routerLink="/contact" routerLinkActive="active">Contact</a>
    </nav>
    
    <div class="route-container" [@routeAnimations]="getRouteAnimationData()">
      <router-outlet></router-outlet>
    </div>
  `,
  animations: [slideInAnimation],
  styles: [`
    .route-container {
      position: relative;
      height: 100vh;
      overflow: hidden;
    }
    
    nav {
      display: flex;
      gap: 1rem;
      padding: 1rem;
      background: #f0f0f0;
    }
    
    nav a {
      padding: 0.5rem 1rem;
      text-decoration: none;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    
    nav a.active {
      background: #007bff;
      color: white;
    }
  `]
})
export class AppComponent {
  constructor(private contexts: ChildrenOutletContexts) {}
  
  getRouteAnimationData() {
    return this.contexts.getContext('primary')?.route?.snapshot?.data?.['animation'];
  }
}
```

**Advanced Animation Patterns:**

**1. Direction-Based Animations:**
```typescript
// directional-animations.ts
export const directionalSlideAnimation = trigger('routeAnimations', [
  // Left to right (forward navigation)
  transition('HomePage => AboutPage', [
    query(':enter, :leave', [
      style({ position: 'absolute', top: 0, left: 0, width: '100%' })
    ], { optional: true }),
    
    query(':enter', [style({ left: '100%' })], { optional: true }),
    
    group([
      query(':leave', [animate('300ms ease-in', style({ left: '-100%' }))], { optional: true }),
      query(':enter', [animate('300ms ease-in', style({ left: '0%' }))], { optional: true })
    ])
  ]),
  
  // Right to left (backward navigation)
  transition('AboutPage => HomePage', [
    query(':enter, :leave', [
      style({ position: 'absolute', top: 0, left: 0, width: '100%' })
    ], { optional: true }),
    
    query(':enter', [style({ left: '-100%' })], { optional: true }),
    
    group([
      query(':leave', [animate('300ms ease-in', style({ left: '100%' }))], { optional: true }),
      query(':enter', [animate('300ms ease-in', style({ left: '0%' }))], { optional: true })
    ])
  ])
]);
```

**2. Scale and Rotate Animations:**
```typescript
export const scaleRotateAnimation = trigger('scaleRotateAnimation', [
  transition('* <=> *', [
    query(':enter, :leave', [
      style({ position: 'absolute', top: 0, left: 0, width: '100%' })
    ], { optional: true }),
    
    group([
      query(':leave', [
        animate('400ms cubic-bezier(0.25, 0.46, 0.45, 0.94)', 
          style({ 
            transform: 'scale(0.8) rotate(-5deg)', 
            opacity: 0 
          })
        )
      ], { optional: true }),
      
      query(':enter', [
        style({ 
          transform: 'scale(1.2) rotate(5deg)', 
          opacity: 0 
        }),
        animate('400ms cubic-bezier(0.25, 0.46, 0.45, 0.94)', 
          style({ 
            transform: 'scale(1) rotate(0deg)', 
            opacity: 1 
          })
        )
      ], { optional: true })
    ])
  ])
]);
```

**3. Keyframe Animations:**
```typescript
export const bounceAnimation = trigger('bounceAnimation', [
  transition('* <=> *', [
    query(':enter', [
      style({ opacity: 0 }),
      animate('600ms ease-in-out', keyframes([
        style({ opacity: 0, transform: 'translateY(-100px)', offset: 0 }),
        style({ opacity: 0.5, transform: 'translateY(15px)', offset: 0.3 }),
        style({ opacity: 1, transform: 'translateY(0)', offset: 0.8 }),
        style({ opacity: 1, transform: 'translateY(-5px)', offset: 0.9 }),
        style({ opacity: 1, transform: 'translateY(0)', offset: 1.0 })
      ]))
    ], { optional: true }),
    
    query(':leave', [
      animate('300ms ease-in', style({ opacity: 0, transform: 'translateY(100px)' }))
    ], { optional: true })
  ])
]);
```

**4. Page-Specific Animations:**
```typescript
// page-specific-animations.ts
export const pageSpecificAnimations = trigger('pageAnimations', [
  // Home page entrance
  transition(':enter', [
    query('.hero', [
      style({ opacity: 0, transform: 'translateY(50px)' }),
      animate('500ms 100ms ease-out', style({ opacity: 1, transform: 'translateY(0)' }))
    ], { optional: true }),
    
    query('.feature-card', [
      style({ opacity: 0, transform: 'scale(0.8)' }),
      animate('400ms 300ms ease-out', style({ opacity: 1, transform: 'scale(1)' }))
    ], { optional: true })
  ])
]);

// Component usage
@Component({
  selector: 'app-home',
  template: `
    <div class="hero">Welcome to our site!</div>
    <div class="feature-card">Feature 1</div>
    <div class="feature-card">Feature 2</div>
    <div class="feature-card">Feature 3</div>
  `,
  animations: [pageSpecificAnimations]
})
export class HomeComponent {}
```

**Navigation-Aware Animations:**

```typescript
// navigation-aware.service.ts
import { Injectable } from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { filter, pairwise } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class NavigationService {
  private navigationDirection = new BehaviorSubject<'forward' | 'backward' | 'none'>('none');
  private routeHistory: string[] = [];
  
  direction$ = this.navigationDirection.asObservable();
  
  constructor(private router: Router) {
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd),
      pairwise()
    ).subscribe(([previous, current]: [NavigationEnd, NavigationEnd]) => {
      this.determineDirection(previous.url, current.url);
    });
  }
  
  private determineDirection(previousUrl: string, currentUrl: string): void {
    const previousIndex = this.routeHistory.indexOf(previousUrl);
    
    if (previousIndex === -1) {
      // New route - forward navigation
      this.routeHistory.push(currentUrl);
      this.navigationDirection.next('forward');
    } else {
      // Existing route - check if going back
      const currentIndex = this.routeHistory.indexOf(currentUrl);
      if (currentIndex !== -1 && currentIndex < previousIndex) {
        this.navigationDirection.next('backward');
      } else {
        this.navigationDirection.next('forward');
      }
    }
  }
}

// Direction-aware animation
export const navigationAwareAnimation = trigger('navigationAnimation', [
  transition('forward', [
    query(':enter, :leave', [
      style({ position: 'absolute', width: '100%' })
    ], { optional: true }),
    
    query(':enter', [style({ left: '100%' })], { optional: true }),
    
    group([
      query(':leave', [animate('300ms ease', style({ left: '-100%' }))], { optional: true }),
      query(':enter', [animate('300ms ease', style({ left: '0%' }))], { optional: true })
    ])
  ]),
  
  transition('backward', [
    query(':enter, :leave', [
      style({ position: 'absolute', width: '100%' })
    ], { optional: true }),
    
    query(':enter', [style({ left: '-100%' })], { optional: true }),
    
    group([
      query(':leave', [animate('300ms ease', style({ left: '100%' }))], { optional: true }),
      query(':enter', [animate('300ms ease', style({ left: '0%' }))], { optional: true })
    ])
  ])
]);
```

**Performance Optimizations:**

**1. Hardware Acceleration:**
```typescript
export const optimizedAnimation = trigger('optimizedAnimation', [
  transition('* <=> *', [
    query(':enter, :leave', [
      style({
        position: 'absolute',
        width: '100%',
        // Enable hardware acceleration
        transform: 'translateZ(0)',
        willChange: 'transform'
      })
    ], { optional: true }),
    
    group([
      query(':leave', [
        animate('250ms cubic-bezier(0.4, 0.0, 0.2, 1)', 
          style({ transform: 'translateX(-100%) translateZ(0)' })
        )
      ], { optional: true }),
      
      query(':enter', [
        style({ transform: 'translateX(100%) translateZ(0)' }),
        animate('250ms cubic-bezier(0.4, 0.0, 0.2, 1)', 
          style({ transform: 'translateX(0) translateZ(0)' })
        )
      ], { optional: true })
    ])
  ])
]);
```

**2. Reduced Motion Support:**
```typescript
export const accessibleAnimation = trigger('accessibleAnimation', [
  transition('* <=> *', [
    query(':enter, :leave', [
      style({ position: 'absolute', width: '100%' })
    ], { optional: true }),
    
    // Check for reduced motion preference
    group([
      query(':leave', [
        animate('{{ duration }}ms {{ easing }}', style({ opacity: 0 }))
      ], { optional: true }),
      
      query(':enter', [
        style({ opacity: 0 }),
        animate('{{ duration }}ms {{ easing }}', style({ opacity: 1 }))
      ], { optional: true })
    ])
  ], {
    params: {
      duration: '{{ reducedMotion ? 0 : 300 }}',
      easing: 'ease-in-out'
    }
  })
]);

// Usage with reduced motion detection
@Component({
  animations: [accessibleAnimation]
})
export class AccessibleComponent {
  reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  
  getAnimationParams() {
    return { reducedMotion: this.reducedMotion };
  }
}
```

**Testing Route Animations:**

```typescript
// route-animations.spec.ts
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { BrowserAnimationsModule, NoopAnimationsModule } from '@angular/platform-browser/animations';
import { RouterTestingModule } from '@angular/router/testing';
import { Component } from '@angular/core';

@Component({ template: 'Test' })
class TestComponent {}

describe('Route Animations', () => {
  let fixture: ComponentFixture<AppComponent>;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [
        BrowserAnimationsModule, // or NoopAnimationsModule for faster tests
        RouterTestingModule.withRoutes([
          { path: 'test', component: TestComponent, data: { animation: 'TestPage' } }
        ])
      ],
      declarations: [AppComponent, TestComponent]
    }).compileComponents();
    
    fixture = TestBed.createComponent(AppComponent);
  });
  
  it('should apply animation trigger', () => {
    const compiled = fixture.nativeElement;
    expect(compiled.querySelector('.route-container')).toBeTruthy();
  });
  
  it('should get correct animation data', () => {
    const component = fixture.componentInstance;
    // Test animation data retrieval logic
    expect(component.getRouteAnimationData).toBeDefined();
  });
});
```

**Best Practices:**
- Keep animations short (200-400ms) for better perceived performance
- Use hardware-accelerated properties (transform, opacity)
- Provide reduced motion alternatives for accessibility
- Test animations on different devices and browsers
- Use easing functions for natural motion
- Avoid animating layout properties (width, height, margin)
- Consider mobile performance when designing animations

[Back to Routing and Navigation](#routing-and-navigation)

### 69. How do you handle router events?

**Answer:**
Router events provide detailed information about navigation lifecycle, allowing you to track navigation progress, implement loading indicators, handle errors, and perform actions at different stages of routing.

**Router Event Types:**

**1. Navigation Events Sequence:**
```typescript
// Complete navigation event flow:
// NavigationStart → RoutesRecognized → RouteConfigLoadStart → 
// RouteConfigLoadEnd → NavigationEnd (or NavigationCancel/NavigationError)

import { 
  Router, 
  NavigationStart, 
  NavigationEnd, 
  NavigationCancel, 
  NavigationError,
  RoutesRecognized,
  RouteConfigLoadStart,
  RouteConfigLoadEnd,
  ChildActivationStart,
  ChildActivationEnd,
  ActivationStart,
  ActivationEnd,
  Scroll
} from '@angular/router';
```

**2. Basic Router Event Handling:**
```typescript
// router-event.service.ts
import { Injectable } from '@angular/core';
import { Router, Event } from '@angular/router';
import { filter } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class RouterEventService {
  constructor(private router: Router) {
    this.trackAllRouterEvents();
  }
  
  private trackAllRouterEvents(): void {
    this.router.events.subscribe((event: Event) => {
      console.log('Router Event:', event.constructor.name, event);
      
      switch (true) {
        case event instanceof NavigationStart:
          this.onNavigationStart(event);
          break;
          
        case event instanceof NavigationEnd:
          this.onNavigationEnd(event);
          break;
          
        case event instanceof NavigationCancel:
          this.onNavigationCancel(event);
          break;
          
        case event instanceof NavigationError:
          this.onNavigationError(event);
          break;
          
        case event instanceof RoutesRecognized:
          this.onRoutesRecognized(event);
          break;
      }
    });
  }
  
  private onNavigationStart(event: NavigationStart): void {
    console.log('Navigation started to:', event.url);
  }
  
  private onNavigationEnd(event: NavigationEnd): void {
    console.log('Navigation completed to:', event.url);
  }
  
  private onNavigationCancel(event: NavigationCancel): void {
    console.log('Navigation cancelled:', event.url, event.reason);
  }
  
  private onNavigationError(event: NavigationError): void {
    console.error('Navigation error:', event.url, event.error);
  }
  
  private onRoutesRecognized(event: RoutesRecognized): void {
    console.log('Routes recognized:', event.url, event.state);
  }
}
```

**Loading Indicator Implementation:**

**1. Global Loading Service:**
```typescript
// loading.service.ts
import { Injectable } from '@angular/core';
import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { filter } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class LoadingService {
  private loadingSubject = new BehaviorSubject<boolean>(false);
  private loadingCounter = 0;
  
  loading$ = this.loadingSubject.asObservable();
  
  constructor(private router: Router) {
    this.initializeRouterEventHandling();
  }
  
  private initializeRouterEventHandling(): void {
    this.router.events.pipe(
      filter(event => 
        event instanceof NavigationStart ||
        event instanceof NavigationEnd ||
        event instanceof NavigationCancel ||
        event instanceof NavigationError
      )
    ).subscribe(event => {
      if (event instanceof NavigationStart) {
        this.startLoading();
      } else {
        this.stopLoading();
      }
    });
  }
  
  startLoading(): void {
    this.loadingCounter++;
    this.loadingSubject.next(true);
  }
  
  stopLoading(): void {
    this.loadingCounter = Math.max(0, this.loadingCounter - 1);
    if (this.loadingCounter === 0) {
      this.loadingSubject.next(false);
    }
  }
  
  forceStopLoading(): void {
    this.loadingCounter = 0;
    this.loadingSubject.next(false);
  }
}

// loading-indicator.component.ts
@Component({
  selector: 'app-loading-indicator',
  template: `
    <div class="loading-overlay" *ngIf="loadingService.loading$ | async">
      <div class="loading-spinner">
        <div class="spinner"></div>
        <p>Loading...</p>
      </div>
    </div>
  `,
  styles: [`
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    
    .loading-spinner {
      text-align: center;
    }
    
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `]
})
export class LoadingIndicatorComponent {
  constructor(public loadingService: LoadingService) {}
}
```

**2. Progress Bar Implementation:**
```typescript
// progress-bar.service.ts
import { Injectable } from '@angular/core';
import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError } from '@angular/router';
import { BehaviorSubject, timer } from 'rxjs';
import { takeUntil, filter } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class ProgressBarService {
  private progressSubject = new BehaviorSubject<number>(0);
  private activeNavigation$ = new BehaviorSubject<boolean>(false);
  
  progress$ = this.progressSubject.asObservable();
  
  constructor(private router: Router) {
    this.initializeProgressTracking();
  }
  
  private initializeProgressTracking(): void {
    this.router.events.subscribe(event => {
      if (event instanceof NavigationStart) {
        this.startProgress();
      } else if (
        event instanceof NavigationEnd ||
        event instanceof NavigationCancel ||
        event instanceof NavigationError
      ) {
        this.completeProgress();
      } else if (event instanceof RouteConfigLoadStart) {
        this.updateProgress(30);
      } else if (event instanceof RouteConfigLoadEnd) {
        this.updateProgress(70);
      }
    });
  }
  
  private startProgress(): void {
    this.activeNavigation$.next(true);
    this.progressSubject.next(10);
    
    // Simulate progress
    timer(100, 100).pipe(
      takeUntil(this.activeNavigation$.pipe(filter(active => !active)))
    ).subscribe(() => {
      const current = this.progressSubject.value;
      if (current < 90) {
        this.progressSubject.next(current + Math.random() * 10);
      }
    });
  }
  
  private updateProgress(value: number): void {
    this.progressSubject.next(Math.max(this.progressSubject.value, value));
  }
  
  private completeProgress(): void {
    this.progressSubject.next(100);
    
    setTimeout(() => {
      this.progressSubject.next(0);
      this.activeNavigation$.next(false);
    }, 200);
  }
}
```

**Navigation Analytics:**

```typescript
// analytics.service.ts
import { Injectable } from '@angular/core';
import { Router, NavigationEnd, NavigationStart } from '@angular/router';
import { filter } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class AnalyticsService {
  private navigationStartTime: number = 0;
  private pageViews: Map<string, number> = new Map();
  private navigationTimes: number[] = [];
  
  constructor(private router: Router) {
    this.trackPageViews();
    this.trackNavigationPerformance();
  }
  
  private trackPageViews(): void {
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd)
    ).subscribe((event: NavigationEnd) => {
      const url = event.url;
      const currentCount = this.pageViews.get(url) || 0;
      this.pageViews.set(url, currentCount + 1);
      
      // Send to analytics service
      this.sendPageView(url);
    });
  }
  
  private trackNavigationPerformance(): void {
    this.router.events.subscribe(event => {
      if (event instanceof NavigationStart) {
        this.navigationStartTime = performance.now();
      } else if (event instanceof NavigationEnd) {
        const navigationTime = performance.now() - this.navigationStartTime;
        this.navigationTimes.push(navigationTime);
        
        console.log(`Navigation to ${event.url} took ${navigationTime.toFixed(2)}ms`);
        
        // Send performance data
        this.sendPerformanceData(event.url, navigationTime);
      }
    });
  }
  
  private sendPageView(url: string): void {
    // Integrate with your analytics service
    console.log('Page view:', url);
  }
  
  private sendPerformanceData(url: string, time: number): void {
    // Send performance metrics
    console.log('Navigation performance:', { url, time });
  }
  
  getAnalytics() {
    return {
      pageViews: Array.from(this.pageViews.entries()),
      averageNavigationTime: this.navigationTimes.reduce((a, b) => a + b, 0) / this.navigationTimes.length,
      totalNavigations: this.navigationTimes.length
    };
  }
}
```

**Error Handling with Router Events:**

```typescript
// error-handler.service.ts
import { Injectable } from '@angular/core';
import { Router, NavigationError, NavigationCancel } from '@angular/router';
import { filter } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class NavigationErrorService {
  constructor(private router: Router) {
    this.handleNavigationErrors();
  }
  
  private handleNavigationErrors(): void {
    // Handle navigation errors
    this.router.events.pipe(
      filter(event => event instanceof NavigationError)
    ).subscribe((event: NavigationError) => {
      console.error('Navigation Error:', {
        url: event.url,
        error: event.error,
        target: event.target
      });
      
      this.handleError(event);
    });
    
    // Handle navigation cancellations
    this.router.events.pipe(
      filter(event => event instanceof NavigationCancel)
    ).subscribe((event: NavigationCancel) => {
      console.warn('Navigation Cancelled:', {
        url: event.url,
        reason: event.reason
      });
      
      this.handleCancellation(event);
    });
  }
  
  private handleError(event: NavigationError): void {
    // Redirect to error page or show error message
    if (event.error?.status === 404) {
      this.router.navigate(['/404']);
    } else if (event.error?.status === 403) {
      this.router.navigate(['/unauthorized']);
    } else {
      this.router.navigate(['/error']);
    }
  }
  
  private handleCancellation(event: NavigationCancel): void {
    // Handle different cancellation reasons
    if (event.reason.includes('guard')) {
      console.log('Navigation blocked by guard');
    } else if (event.reason.includes('resolver')) {
      console.log('Navigation cancelled by resolver');
    }
  }
}
```

**Breadcrumb Implementation:**

```typescript
// breadcrumb.service.ts
import { Injectable } from '@angular/core';
import { Router, NavigationEnd, ActivatedRoute } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { filter } from 'rxjs/operators';

interface Breadcrumb {
  label: string;
  url: string;
}

@Injectable({ providedIn: 'root' })
export class BreadcrumbService {
  private breadcrumbsSubject = new BehaviorSubject<Breadcrumb[]>([]);
  breadcrumbs$ = this.breadcrumbsSubject.asObservable();
  
  constructor(private router: Router, private activatedRoute: ActivatedRoute) {
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd)
    ).subscribe(() => {
      const breadcrumbs = this.buildBreadcrumbs(this.activatedRoute.root);
      this.breadcrumbsSubject.next(breadcrumbs);
    });
  }
  
  private buildBreadcrumbs(route: ActivatedRoute, url: string = '', breadcrumbs: Breadcrumb[] = []): Breadcrumb[] {
    const children: ActivatedRoute[] = route.children;
    
    if (children.length === 0) {
      return breadcrumbs;
    }
    
    for (const child of children) {
      const routeURL: string = child.snapshot.url.map(segment => segment.path).join('/');
      if (routeURL !== '') {
        url += `/${routeURL}`;
      }
      
      const label = child.snapshot.data['breadcrumb'];
      if (label) {
        breadcrumbs.push({ label, url });
      }
      
      return this.buildBreadcrumbs(child, url, breadcrumbs);
    }
    
    return breadcrumbs;
  }
}

// breadcrumb.component.ts
@Component({
  selector: 'app-breadcrumb',
  template: `
    <nav class="breadcrumb" *ngIf="(breadcrumbService.breadcrumbs$ | async)?.length">
      <ol>
        <li><a routerLink="/">Home</a></li>
        <li *ngFor="let breadcrumb of breadcrumbService.breadcrumbs$ | async; let last = last">
          <a *ngIf="!last" [routerLink]="breadcrumb.url">{{ breadcrumb.label }}</a>
          <span *ngIf="last">{{ breadcrumb.label }}</span>
        </li>
      </ol>
    </nav>
  `,
  styles: [`
    .breadcrumb ol {
      display: flex;
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .breadcrumb li:not(:last-child)::after {
      content: ' > ';
      margin: 0 0.5rem;
    }
    
    .breadcrumb a {
      text-decoration: none;
      color: #007bff;
    }
    
    .breadcrumb span {
      color: #6c757d;
    }
  `]
})
export class BreadcrumbComponent {
  constructor(public breadcrumbService: BreadcrumbService) {}
}
```

**Route Change Detection:**

```typescript
// route-change.service.ts
import { Injectable } from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { filter, distinctUntilChanged, pairwise } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class RouteChangeService {
  private currentRouteSubject = new BehaviorSubject<string>('');
  private previousRouteSubject = new BehaviorSubject<string>('');
  
  currentRoute$ = this.currentRouteSubject.asObservable();
  previousRoute$ = this.previousRouteSubject.asObservable();
  
  constructor(private router: Router) {
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd),
      distinctUntilChanged((prev: NavigationEnd, curr: NavigationEnd) => prev.url === curr.url),
      pairwise()
    ).subscribe(([previous, current]: [NavigationEnd, NavigationEnd]) => {
      this.previousRouteSubject.next(previous.url);
      this.currentRouteSubject.next(current.url);
      
      this.onRouteChange(previous.url, current.url);
    });
  }
  
  private onRouteChange(previousUrl: string, currentUrl: string): void {
    console.log(`Route changed from ${previousUrl} to ${currentUrl}`);
    
    // Perform actions on route change
    this.clearTemporaryData();
    this.updatePageTitle();
    this.trackPageView(currentUrl);
  }
  
  private clearTemporaryData(): void {
    // Clear temporary data, close modals, etc.
  }
  
  private updatePageTitle(): void {
    // Update page title based on current route
  }
  
  private trackPageView(url: string): void {
    // Send page view to analytics
  }
  
  isRouteActive(route: string): boolean {
    return this.currentRouteSubject.value.includes(route);
  }
  
  getPreviousRoute(): string {
    return this.previousRouteSubject.value;
  }
}
```

**Testing Router Events:**

```typescript
// router-events.spec.ts
import { TestBed } from '@angular/core/testing';
import { Router } from '@angular/router';
import { Location } from '@angular/common';
import { Component } from '@angular/core';
import { RouterTestingModule } from '@angular/router/testing';
import { LoadingService } from './loading.service';

@Component({ template: 'Test' })
class TestComponent {}

describe('Router Events', () => {
  let router: Router;
  let location: Location;
  let loadingService: LoadingService;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [
        RouterTestingModule.withRoutes([
          { path: 'test', component: TestComponent }
        ])
      ],
      declarations: [TestComponent],
      providers: [LoadingService]
    }).compileComponents();
    
    router = TestBed.inject(Router);
    location = TestBed.inject(Location);
    loadingService = TestBed.inject(LoadingService);
  });
  
  it('should track loading state during navigation', async () => {
    let loadingStates: boolean[] = [];
    
    loadingService.loading$.subscribe(loading => {
      loadingStates.push(loading);
    });
    
    await router.navigate(['/test']);
    
    expect(loadingStates).toContain(true);
    expect(loadingStates[loadingStates.length - 1]).toBe(false);
  });
});
```

**Best Practices:**
- Use router events for loading indicators and progress tracking
- Implement proper error handling for navigation failures
- Track navigation performance for optimization
- Use breadcrumbs for better user navigation
- Clean up subscriptions to prevent memory leaks
- Handle edge cases like navigation cancellation
- Implement analytics tracking for user behavior insights

[Back to Routing and Navigation](#routing-and-navigation)

### 70. What is the difference between absolute and relative navigation?

**Answer:**
Absolute and relative navigation determine how Angular interprets navigation paths. Understanding the difference is crucial for building maintainable routing systems, especially in complex applications with nested routes.

**Absolute Navigation:**

**1. Definition and Characteristics:**
```typescript
// Absolute navigation always starts from the root of the application
// Paths begin with '/' and are interpreted from the root route

// Examples of absolute navigation:
this.router.navigate(['/users']);              // Goes to /users
this.router.navigate(['/users', '123']);       // Goes to /users/123
this.router.navigate(['/admin', 'dashboard']); // Goes to /admin/dashboard

// Template absolute navigation:
<a routerLink="/products">Products</a>
<a [routerLink]="['/users', userId]">User Details</a>
```

**2. Absolute Navigation Examples:**
```typescript
// navigation.service.ts
import { Injectable } from '@angular/core';
import { Router } from '@angular/router';

@Injectable({ providedIn: 'root' })
export class NavigationService {
  constructor(private router: Router) {}
  
  // Absolute navigation methods
  goToHome(): void {
    this.router.navigate(['/']); // Always goes to root
  }
  
  goToUserProfile(userId: number): void {
    this.router.navigate(['/users', userId, 'profile']); // /users/123/profile
  }
  
  goToAdminDashboard(): void {
    this.router.navigate(['/admin', 'dashboard']); // /admin/dashboard
  }
  
  // Absolute navigation with query params
  searchProducts(query: string): void {
    this.router.navigate(['/products'], {
      queryParams: { search: query }
    }); // /products?search=query
  }
}
```

**Relative Navigation:**

**1. Definition and Characteristics:**
```typescript
// Relative navigation is based on the current route
// Paths don't start with '/' and use relativeTo option
// Uses current ActivatedRoute as the base for navigation

import { ActivatedRoute } from '@angular/router';

// Examples of relative navigation:
this.router.navigate(['details'], { relativeTo: this.route });     // current-path/details
this.router.navigate(['../sibling'], { relativeTo: this.route });  // go up one level, then to sibling
this.router.navigate(['./child'], { relativeTo: this.route });     // current-path/child
this.router.navigate(['../../parent'], { relativeTo: this.route }); // go up two levels
```

**2. Relative Navigation Examples:**
```typescript
// user-detail.component.ts
import { Component } from '@angular/core';
import { Router, ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-user-detail',
  template: `
    <div class="user-detail">
      <h2>User Details</h2>
      
      <!-- Relative navigation in template -->
      <a routerLink="./edit" routerLinkActive="active">Edit</a>
      <a routerLink="./settings" routerLinkActive="active">Settings</a>
      <a routerLink="../" routerLinkActive="active">Back to List</a>
      
      <div class="actions">
        <button (click)="goToEdit()">Edit User</button>
        <button (click)="goToSettings()">User Settings</button>
        <button (click)="goBackToList()">Back to Users</button>
        <button (click)="goToSibling()">Go to Sibling</button>
      </div>
    </div>
  `
})
export class UserDetailComponent {
  constructor(
    private router: Router,
    private route: ActivatedRoute
  ) {}
  
  // Relative navigation methods
  goToEdit(): void {
    // If current route is /users/123, navigates to /users/123/edit
    this.router.navigate(['edit'], { relativeTo: this.route });
  }
  
  goToSettings(): void {
    // If current route is /users/123, navigates to /users/123/settings
    this.router.navigate(['settings'], { relativeTo: this.route });
  }
  
  goBackToList(): void {
    // If current route is /users/123, navigates to /users
    this.router.navigate(['../'], { relativeTo: this.route });
  }
  
  goToSibling(): void {
    // If current route is /users/123, navigates to /users/456
    this.router.navigate(['../456'], { relativeTo: this.route });
  }
  
  goToParentSibling(): void {
    // If current route is /users/123/profile, navigates to /admin
    this.router.navigate(['../../admin'], { relativeTo: this.route });
  }
}
```

**Detailed Comparison:**

| Aspect | Absolute Navigation | Relative Navigation |
|--------|-------------------|--------------------|
| **Path Format** | Starts with `/` | No leading `/` |
| **Base Reference** | Application root | Current route |
| **Dependency** | Independent of current location | Depends on current route |
| **Maintainability** | Less flexible for route changes | More flexible and maintainable |
| **Use Case** | Global navigation, main menu | Local navigation, nested routes |
| **Performance** | Same | Same |
| **URL Predictability** | Always predictable | Depends on current context |

**Complex Navigation Scenarios:**

**1. Nested Route Navigation:**
```typescript
// Route structure:
// /admin/users/123/profile/edit
// /admin/users/123/profile/settings
// /admin/users/123/posts
// /admin/products

@Component({})
export class ProfileEditComponent {
  constructor(
    private router: Router,
    private route: ActivatedRoute
  ) {}
  
  navigateExamples(): void {
    // Current route: /admin/users/123/profile/edit
    
    // Absolute navigation
    this.router.navigate(['/admin', 'products']); // → /admin/products
    
    // Relative navigation examples
    this.router.navigate(['../settings'], { relativeTo: this.route }); // → /admin/users/123/profile/settings
    this.router.navigate(['../../posts'], { relativeTo: this.route }); // → /admin/users/123/posts
    this.router.navigate(['../../../456/profile'], { relativeTo: this.route }); // → /admin/users/456/profile
  }
}
```

**2. Dynamic Relative Navigation:**
```typescript
// dynamic-navigation.service.ts
import { Injectable } from '@angular/core';
import { Router, ActivatedRoute } from '@angular/router';

@Injectable({ providedIn: 'root' })
export class DynamicNavigationService {
  constructor(private router: Router) {}
  
  // Navigate relatively based on current context
  navigateToSiblingTab(tabName: string, currentRoute: ActivatedRoute): void {
    this.router.navigate(['../', tabName], { relativeTo: currentRoute });
  }
  
  // Navigate to child route with parameters
  navigateToChild(childRoute: string, params: any, currentRoute: ActivatedRoute): void {
    this.router.navigate([childRoute, params], { relativeTo: currentRoute });
  }
  
  // Navigate up the hierarchy
  navigateUp(levels: number, currentRoute: ActivatedRoute): void {
    const upPath = '../'.repeat(levels);
    this.router.navigate([upPath], { relativeTo: currentRoute });
  }
  
  // Conditional navigation based on route depth
  smartNavigate(targetRoute: string, currentRoute: ActivatedRoute): void {
    const routeDepth = this.getRouteDepth(currentRoute);
    
    if (routeDepth > 2) {
      // Use relative navigation for deep routes
      this.router.navigate(['../../', targetRoute], { relativeTo: currentRoute });
    } else {
      // Use absolute navigation for shallow routes
      this.router.navigate(['/', targetRoute]);
    }
  }
  
  private getRouteDepth(route: ActivatedRoute): number {
    let depth = 0;
    let currentRoute: ActivatedRoute | null = route;
    
    while (currentRoute?.parent) {
      depth++;
      currentRoute = currentRoute.parent;
    }
    
    return depth;
  }
}
```

**Template Navigation Patterns:**

**1. Mixed Navigation in Templates:**
```typescript
// navigation-menu.component.ts
@Component({
  selector: 'app-navigation-menu',
  template: `
    <nav class="navigation">
      <!-- Absolute navigation for main menu -->
      <div class="main-nav">
        <a routerLink="/" routerLinkActive="active" [routerLinkActiveOptions]="{exact: true}">Home</a>
        <a routerLink="/products" routerLinkActive="active">Products</a>
        <a routerLink="/about" routerLinkActive="active">About</a>
        <a routerLink="/contact" routerLinkActive="active">Contact</a>
      </div>
      
      <!-- Relative navigation for contextual actions -->
      <div class="contextual-nav" *ngIf="showContextualNav">
        <a routerLink="./details" routerLinkActive="active">Details</a>
        <a routerLink="./edit" routerLinkActive="active">Edit</a>
        <a routerLink="../" routerLinkActive="active">Back</a>
      </div>
      
      <!-- Dynamic navigation -->
      <div class="dynamic-nav">
        <a *ngFor="let item of contextualItems" 
           [routerLink]="item.isAbsolute ? ['/', item.path] : ['./', item.path]"
           routerLinkActive="active">
          {{item.label}}
        </a>
      </div>
    </nav>
  `
})
export class NavigationMenuComponent {
  showContextualNav = true;
  
  contextualItems = [
    { label: 'Dashboard', path: 'dashboard', isAbsolute: true },
    { label: 'Settings', path: 'settings', isAbsolute: false },
    { label: 'Profile', path: 'profile', isAbsolute: false }
  ];
}
```

**2. Programmatic Navigation with Context:**
```typescript
// context-aware-navigation.component.ts
@Component({})
export class ContextAwareNavigationComponent {
  constructor(
    private router: Router,
    private route: ActivatedRoute
  ) {}
  
  // Navigation method that chooses between absolute and relative
  navigateSmartly(target: string, useRelative: boolean = false): void {
    if (useRelative) {
      this.router.navigate([target], { relativeTo: this.route });
    } else {
      this.router.navigate([target]);
    }
  }
  
  // Navigation based on current route context
  navigateBasedOnContext(): void {
    const currentUrl = this.router.url;
    
    if (currentUrl.includes('/admin')) {
      // In admin section, use relative navigation
      this.router.navigate(['../dashboard'], { relativeTo: this.route });
    } else {
      // Outside admin, use absolute navigation
      this.router.navigate(['/admin/dashboard']);
    }
  }
}
```

**Query Parameters and Fragments:**

```typescript
// Both absolute and relative navigation support query params and fragments

// Absolute with query params
this.router.navigate(['/products'], {
  queryParams: { category: 'electronics', page: 1 },
  fragment: 'top'
});

// Relative with query params
this.router.navigate(['details'], {
  relativeTo: this.route,
  queryParams: { tab: 'info' },
  fragment: 'summary'
});

// Preserve existing query params
this.router.navigate(['../sibling'], {
  relativeTo: this.route,
  queryParamsHandling: 'preserve'
});
```

**Best Practices:**

**✅ Use Absolute Navigation for:**
- Main application navigation (header, sidebar menus)
- Cross-feature navigation
- Landing pages and entry points
- Global actions (login, logout, home)

**✅ Use Relative Navigation for:**
- Navigation within feature modules
- Parent-child route relationships
- Sibling route navigation
- Contextual actions (edit, view, delete)

**✅ General Guidelines:**
- Use relative navigation for maintainability in nested routes
- Use absolute navigation when the target is independent of current context
- Consider using a navigation service to centralize complex navigation logic
- Test navigation thoroughly, especially when refactoring route structures
- Document navigation patterns for team consistency

**❌ Avoid:**
- Mixing absolute and relative navigation inconsistently
- Hard-coding absolute paths that might change
- Complex relative navigation that's hard to understand
- Forgetting to handle navigation errors

[Back to Routing and Navigation](#routing-and-navigation)

### 71. How do you implement route animations and transitions?

**Answer:**
Route animations and transitions create smooth visual continuity between different views, significantly enhancing user experience through carefully crafted motion design and performance-optimized implementations.

**Advanced Transition Patterns:**

**1. Multi-Stage Transition System:**
```typescript
// advanced-route-transitions.ts
import { 
  trigger, transition, style, query, group, animate, 
  keyframes, stagger, animateChild 
} from '@angular/animations';

export const advancedRouteTransitions = trigger('advancedRouteTransitions', [
  // Multi-phase slide transition with stagger
  transition('* <=> *', [
    // Setup phase
    query(':enter, :leave', [
      style({ 
        position: 'absolute', 
        top: 0, 
        left: 0, 
        width: '100%',
        transform: 'translateZ(0)' // Enable hardware acceleration
      })
    ], { optional: true }),
    
    // Staggered element animations
    query(':leave .animate-item', [
      animate('200ms ease-out', style({ 
        opacity: 0, 
        transform: 'translateY(-20px)' 
      }))
    ], { optional: true }),
    
    // Main transition with multiple elements
    group([
      // Background slide
      query(':leave', [
        animate('400ms cubic-bezier(0.25, 0.46, 0.45, 0.94)', 
          style({ transform: 'translateX(-100%) scale(0.95)' })
        )
      ], { optional: true }),
      
      // Foreground entrance
      query(':enter', [
        style({ transform: 'translateX(100%) scale(1.05)' }),
        animate('400ms cubic-bezier(0.25, 0.46, 0.45, 0.94)', 
          style({ transform: 'translateX(0) scale(1)' })
        )
      ], { optional: true }),
      
      // Staggered item entrance
      query(':enter .animate-item', [
        style({ opacity: 0, transform: 'translateY(30px)' }),
        stagger('50ms', [
          animate('300ms ease-out', 
            style({ opacity: 1, transform: 'translateY(0)' })
          )
        ])
      ], { optional: true })
    ])
  ])
]);
```

**2. Context-Aware Transition System:**
```typescript
// context-aware-transitions.service.ts
import { Injectable } from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { filter, pairwise } from 'rxjs/operators';

interface TransitionContext {
  from: string;
  to: string;
  direction: 'forward' | 'backward' | 'lateral';
  depth: number;
  transitionType: 'slide' | 'fade' | 'zoom' | 'flip';
}

@Injectable({ providedIn: 'root' })
export class TransitionContextService {
  private contextSubject = new BehaviorSubject<TransitionContext | null>(null);
  private routeHierarchy = new Map<string, number>();
  private navigationHistory: string[] = [];
  
  context$ = this.contextSubject.asObservable();
  
  constructor(private router: Router) {
    this.initializeRouteHierarchy();
    this.trackNavigationContext();
  }
  
  private initializeRouteHierarchy(): void {
    // Define route hierarchy for transition direction
    this.routeHierarchy.set('/', 0);
    this.routeHierarchy.set('/home', 1);
    this.routeHierarchy.set('/products', 1);
    this.routeHierarchy.set('/products/:id', 2);
    this.routeHierarchy.set('/checkout', 2);
    this.routeHierarchy.set('/profile', 1);
    this.routeHierarchy.set('/settings', 2);
  }
  
  private trackNavigationContext(): void {
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd),
      pairwise()
    ).subscribe(([prev, curr]: [NavigationEnd, NavigationEnd]) => {
      const context = this.determineTransitionContext(prev.url, curr.url);
      this.contextSubject.next(context);
      this.updateNavigationHistory(curr.url);
    });
  }
  
  private determineTransitionContext(from: string, to: string): TransitionContext {
    const fromDepth = this.getRouteDepth(from);
    const toDepth = this.getRouteDepth(to);
    
    let direction: 'forward' | 'backward' | 'lateral';
    let transitionType: 'slide' | 'fade' | 'zoom' | 'flip';
    
    if (toDepth > fromDepth) {
      direction = 'forward';
      transitionType = 'slide';
    } else if (toDepth < fromDepth) {
      direction = 'backward';
      transitionType = 'slide';
    } else {
      direction = 'lateral';
      transitionType = this.isRelatedRoute(from, to) ? 'fade' : 'flip';
    }
    
    return {
      from,
      to,
      direction,
      depth: Math.abs(toDepth - fromDepth),
      transitionType
    };
  }
  
  private getRouteDepth(route: string): number {
    return this.routeHierarchy.get(route) || 0;
  }
  
  private isRelatedRoute(from: string, to: string): boolean {
    const fromSegments = from.split('/');
    const toSegments = to.split('/');
    return fromSegments[1] === toSegments[1]; // Same top-level route
  }
  
  private updateNavigationHistory(url: string): void {
    this.navigationHistory.push(url);
    if (this.navigationHistory.length > 10) {
      this.navigationHistory.shift();
    }
  }
}
```

**3. Performance-Optimized Transitions:**
```typescript
// optimized-transitions.ts
export const optimizedTransitions = trigger('optimizedTransitions', [
  transition('* <=> *', [
    // Use will-change for performance
    query(':enter, :leave', [
      style({ 
        position: 'absolute',
        width: '100%',
        willChange: 'transform, opacity',
        backfaceVisibility: 'hidden',
        perspective: '1000px'
      })
    ], { optional: true }),
    
    group([
      // GPU-accelerated transforms only
      query(':leave', [
        animate('{{ duration }}ms {{ easing }}', 
          style({ 
            transform: 'translate3d(-100%, 0, 0)',
            opacity: 0
          })
        )
      ], { optional: true }),
      
      query(':enter', [
        style({ 
          transform: 'translate3d(100%, 0, 0)',
          opacity: 0
        }),
        animate('{{ duration }}ms {{ easing }}', 
          style({ 
            transform: 'translate3d(0, 0, 0)',
            opacity: 1
          })
        )
      ], { optional: true })
    ]),
    
    // Clean up will-change after animation
    query(':enter', [
      animate('1ms', style({ willChange: 'auto' }))
    ], { optional: true })
  ], {
    params: {
      duration: 300,
      easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)'
    }
  })
]);
```

**4. Adaptive Animation System:**
```typescript
// adaptive-animation.service.ts
@Injectable({ providedIn: 'root' })
export class AdaptiveAnimationService {
  private performanceObserver?: PerformanceObserver;
  private animationQuality: 'high' | 'medium' | 'low' = 'high';
  private reducedMotion = false;
  
  constructor() {
    this.detectCapabilities();
    this.observePerformance();
  }
  
  private detectCapabilities(): void {
    // Check for reduced motion preference
    this.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    // Detect device capabilities
    const connection = (navigator as any).connection;
    if (connection) {
      if (connection.effectiveType === '4g' && !connection.saveData) {
        this.animationQuality = 'high';
      } else if (connection.effectiveType === '3g') {
        this.animationQuality = 'medium';
      } else {
        this.animationQuality = 'low';
      }
    }
    
    // Detect hardware acceleration support
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
      this.animationQuality = 'low';
    }
  }
  
  private observePerformance(): void {
    if ('PerformanceObserver' in window) {
      this.performanceObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const longTasks = entries.filter(entry => entry.duration > 50);
        
        if (longTasks.length > 0) {
          this.degradeAnimationQuality();
        }
      });
      
      this.performanceObserver.observe({ entryTypes: ['longtask'] });
    }
  }
  
  private degradeAnimationQuality(): void {
    if (this.animationQuality === 'high') {
      this.animationQuality = 'medium';
    } else if (this.animationQuality === 'medium') {
      this.animationQuality = 'low';
    }
  }
  
  getAnimationParams() {
    if (this.reducedMotion) {
      return { duration: 0, easing: 'linear' };
    }
    
    switch (this.animationQuality) {
      case 'high':
        return { duration: 400, easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' };
      case 'medium':
        return { duration: 250, easing: 'ease-out' };
      case 'low':
        return { duration: 150, easing: 'linear' };
      default:
        return { duration: 300, easing: 'ease' };
    }
  }
  
  shouldUseComplexAnimations(): boolean {
    return !this.reducedMotion && this.animationQuality === 'high';
  }
}
```

**Best Practices for Advanced Transitions:**
- **Performance First**: Use GPU-accelerated properties (transform, opacity)
- **Adaptive Quality**: Adjust animation complexity based on device capabilities
- **Accessibility**: Always respect reduced motion preferences
- **Context Awareness**: Choose transitions based on navigation context
- **Monitoring**: Track animation performance and user experience
- **Progressive Enhancement**: Provide fallbacks for older browsers
- **User Control**: Allow users to customize animation preferences

[Back to Routing and Navigation](#routing-and-navigation)

---

## Forms and Validation

### 72. How do you implement `ControlValueAccessor` for reusable form controls?

**Answer:**
`ControlValueAccessor` is an interface that allows custom components to integrate seamlessly with Angular's reactive and template-driven forms, enabling them to work with `ngModel`, `FormControl`, and form validation.

**Basic ControlValueAccessor Implementation:**

**1. Simple Custom Input Component:**
```typescript
// custom-input.component.ts
import { 
  Component, 
  Input, 
  forwardRef, 
  OnDestroy 
} from '@angular/core';
import {
  ControlValueAccessor,
  NG_VALUE_ACCESSOR,
  NG_VALIDATORS,
  Validator,
  AbstractControl,
  ValidationErrors
} from '@angular/forms';

@Component({
  selector: 'app-custom-input',
  template: `
    <div class="custom-input-wrapper">
      <label *ngIf="label">{{label}}</label>
      <input 
        type="text"
        [value]="value"
        [placeholder]="placeholder"
        [disabled]="disabled"
        (input)="onInput($event)"
        (blur)="onBlur()"
        (focus)="onFocus()"
        class="custom-input"
        [class.invalid]="invalid"
        [class.disabled]="disabled" />
      <div class="error-message" *ngIf="invalid && showError">
        {{errorMessage}}
      </div>
    </div>
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => CustomInputComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => CustomInputComponent),
      multi: true
    }
  ],
  styles: [`
    .custom-input-wrapper {
      display: flex;
      flex-direction: column;
      margin-bottom: 1rem;
    }
    
    .custom-input {
      padding: 0.5rem;
      border: 2px solid #ddd;
      border-radius: 4px;
      font-size: 1rem;
      transition: border-color 0.3s;
    }
    
    .custom-input:focus {
      outline: none;
      border-color: #007bff;
    }
    
    .custom-input.invalid {
      border-color: #dc3545;
    }
    
    .custom-input.disabled {
      background-color: #f8f9fa;
      cursor: not-allowed;
    }
    
    .error-message {
      color: #dc3545;
      font-size: 0.875rem;
      margin-top: 0.25rem;
    }
  `]
})
export class CustomInputComponent implements ControlValueAccessor, Validator, OnDestroy {
  @Input() label = '';
  @Input() placeholder = '';
  @Input() errorMessage = 'Invalid input';
  @Input() required = false;
  @Input() minLength = 0;
  @Input() maxLength = 255;
  
  value = '';
  disabled = false;
  invalid = false;
  showError = false;
  
  // ControlValueAccessor callbacks
  private onChange = (value: string) => {};
  private onTouched = () => {};
  
  // ControlValueAccessor implementation
  writeValue(value: string): void {
    this.value = value || '';
  }
  
  registerOnChange(fn: (value: string) => void): void {
    this.onChange = fn;
  }
  
  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }
  
  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
  
  // Validator implementation
  validate(control: AbstractControl): ValidationErrors | null {
    const value = control.value;
    
    if (this.required && (!value || value.trim() === '')) {
      return { required: true };
    }
    
    if (this.minLength > 0 && value && value.length < this.minLength) {
      return { minlength: { requiredLength: this.minLength, actualLength: value.length } };
    }
    
    if (this.maxLength > 0 && value && value.length > this.maxLength) {
      return { maxlength: { requiredLength: this.maxLength, actualLength: value.length } };
    }
    
    return null;
  }
  
  // Event handlers
  onInput(event: Event): void {
    const input = event.target as HTMLInputElement;
    this.value = input.value;
    this.onChange(this.value);
  }
  
  onBlur(): void {
    this.onTouched();
    this.showError = true;
  }
  
  onFocus(): void {
    this.showError = false;
  }
  
  ngOnDestroy(): void {
    // Cleanup if needed
  }
}
```

**2. Advanced Rating Component:**
```typescript
// rating.component.ts
import { Component, Input, forwardRef } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

@Component({
  selector: 'app-rating',
  template: `
    <div class="rating-container">
      <span class="rating-label" *ngIf="label">{{label}}</span>
      <div class="stars">
        <button
          *ngFor="let star of stars; let i = index"
          type="button"
          class="star"
          [class.active]="i < value"
          [class.hover]="i < hoverValue"
          [disabled]="disabled"
          (click)="selectRating(i + 1)"
          (mouseenter)="onHover(i + 1)"
          (mouseleave)="onHoverEnd()"
          [attr.aria-label]="'Rate ' + (i + 1) + ' out of ' + maxRating">
          ★
        </button>
      </div>
      <span class="rating-value" *ngIf="showValue">{{value}}/{{maxRating}}</span>
    </div>
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => RatingComponent),
      multi: true
    }
  ],
  styles: [`
    .rating-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .stars {
      display: flex;
      gap: 0.25rem;
    }
    
    .star {
      background: none;
      border: none;
      font-size: 1.5rem;
      color: #ddd;
      cursor: pointer;
      transition: color 0.2s;
      padding: 0;
    }
    
    .star:hover,
    .star.hover {
      color: #ffc107;
    }
    
    .star.active {
      color: #ff8c00;
    }
    
    .star:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    .rating-value {
      font-size: 0.875rem;
      color: #666;
    }
  `]
})
export class RatingComponent implements ControlValueAccessor {
  @Input() label = '';
  @Input() maxRating = 5;
  @Input() showValue = false;
  
  value = 0;
  hoverValue = 0;
  disabled = false;
  
  get stars(): number[] {
    return Array(this.maxRating).fill(0);
  }
  
  private onChange = (value: number) => {};
  private onTouched = () => {};
  
  // ControlValueAccessor implementation
  writeValue(value: number): void {
    this.value = value || 0;
  }
  
  registerOnChange(fn: (value: number) => void): void {
    this.onChange = fn;
  }
  
  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }
  
  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
  
  // Component methods
  selectRating(rating: number): void {
    if (this.disabled) return;
    
    this.value = rating;
    this.onChange(this.value);
    this.onTouched();
  }
  
  onHover(rating: number): void {
    if (this.disabled) return;
    this.hoverValue = rating;
  }
  
  onHoverEnd(): void {
    this.hoverValue = 0;
  }
}
```

**3. Complex Multi-Select Component:**
```typescript
// multi-select.component.ts
import { Component, Input, forwardRef } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

interface SelectOption {
  value: any;
  label: string;
  disabled?: boolean;
}

@Component({
  selector: 'app-multi-select',
  template: `
    <div class="multi-select-container">
      <div class="multi-select-header" (click)="toggleDropdown()">
        <div class="selected-items">
          <span *ngIf="selectedOptions.length === 0" class="placeholder">
            {{placeholder}}
          </span>
          <div *ngFor="let option of selectedOptions" class="selected-item">
            {{option.label}}
            <button 
              type="button" 
              class="remove-btn"
              (click)="removeOption(option, $event)"
              [disabled]="disabled">
              ×
            </button>
          </div>
        </div>
        <div class="dropdown-arrow" [class.open]="isOpen">▼</div>
      </div>
      
      <div class="dropdown" *ngIf="isOpen">
        <div class="search-box" *ngIf="searchable">
          <input 
            type="text" 
            [(ngModel)]="searchTerm"
            placeholder="Search options..."
            (input)="filterOptions()"
            class="search-input" />
        </div>
        
        <div class="options-list">
          <div 
            *ngFor="let option of filteredOptions" 
            class="option"
            [class.selected]="isSelected(option)"
            [class.disabled]="option.disabled || disabled"
            (click)="toggleOption(option)">
            <input 
              type="checkbox" 
              [checked]="isSelected(option)"
              [disabled]="option.disabled || disabled"
              readonly />
            <span>{{option.label}}</span>
          </div>
          
          <div *ngIf="filteredOptions.length === 0" class="no-options">
            No options found
          </div>
        </div>
      </div>
    </div>
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => MultiSelectComponent),
      multi: true
    }
  ],
  styles: [`
    .multi-select-container {
      position: relative;
      width: 100%;
    }
    
    .multi-select-header {
      border: 2px solid #ddd;
      border-radius: 4px;
      padding: 0.5rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      min-height: 2.5rem;
    }
    
    .selected-items {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      flex: 1;
    }
    
    .selected-item {
      background: #007bff;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.875rem;
    }
    
    .remove-btn {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 1rem;
      padding: 0;
    }
    
    .dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 2px solid #ddd;
      border-top: none;
      border-radius: 0 0 4px 4px;
      z-index: 1000;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .search-input {
      width: 100%;
      padding: 0.5rem;
      border: none;
      border-bottom: 1px solid #eee;
      outline: none;
    }
    
    .option {
      padding: 0.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .option:hover {
      background: #f8f9fa;
    }
    
    .option.selected {
      background: #e3f2fd;
    }
    
    .option.disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  `]
})
export class MultiSelectComponent implements ControlValueAccessor {
  @Input() options: SelectOption[] = [];
  @Input() placeholder = 'Select options...';
  @Input() searchable = false;
  
  selectedValues: any[] = [];
  selectedOptions: SelectOption[] = [];
  filteredOptions: SelectOption[] = [];
  isOpen = false;
  searchTerm = '';
  disabled = false;
  
  private onChange = (value: any[]) => {};
  private onTouched = () => {};
  
  ngOnInit(): void {
    this.filteredOptions = [...this.options];
  }
  
  // ControlValueAccessor implementation
  writeValue(values: any[]): void {
    this.selectedValues = values || [];
    this.updateSelectedOptions();
  }
  
  registerOnChange(fn: (value: any[]) => void): void {
    this.onChange = fn;
  }
  
  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }
  
  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }
  
  // Component methods
  toggleDropdown(): void {
    if (this.disabled) return;
    this.isOpen = !this.isOpen;
    if (this.isOpen) {
      this.onTouched();
    }
  }
  
  toggleOption(option: SelectOption): void {
    if (option.disabled || this.disabled) return;
    
    const index = this.selectedValues.indexOf(option.value);
    if (index > -1) {
      this.selectedValues.splice(index, 1);
    } else {
      this.selectedValues.push(option.value);
    }
    
    this.updateSelectedOptions();
    this.onChange(this.selectedValues);
  }
  
  removeOption(option: SelectOption, event: Event): void {
    event.stopPropagation();
    if (this.disabled) return;
    
    const index = this.selectedValues.indexOf(option.value);
    if (index > -1) {
      this.selectedValues.splice(index, 1);
      this.updateSelectedOptions();
      this.onChange(this.selectedValues);
    }
  }
  
  isSelected(option: SelectOption): boolean {
    return this.selectedValues.includes(option.value);
  }
  
  filterOptions(): void {
    if (!this.searchTerm) {
      this.filteredOptions = [...this.options];
    } else {
      this.filteredOptions = this.options.filter(option =>
        option.label.toLowerCase().includes(this.searchTerm.toLowerCase())
      );
    }
  }
  
  private updateSelectedOptions(): void {
    this.selectedOptions = this.options.filter(option =>
      this.selectedValues.includes(option.value)
    );
  }
}
```

**Usage Examples:**

**1. In Reactive Forms:**
```typescript
// form.component.ts
export class FormComponent {
  form = this.fb.group({
    customInput: ['', [Validators.required, Validators.minLength(3)]],
    rating: [0, [Validators.min(1), Validators.max(5)]],
    tags: [[], Validators.required]
  });
  
  constructor(private fb: FormBuilder) {}
}

// form.component.html
<form [formGroup]="form">
  <app-custom-input
    formControlName="customInput"
    label="Name"
    placeholder="Enter your name"
    [required]="true"
    [minLength]="3">
  </app-custom-input>
  
  <app-rating
    formControlName="rating"
    label="Rate this product"
    [maxRating]="5"
    [showValue]="true">
  </app-rating>
  
  <app-multi-select
    formControlName="tags"
    [options]="tagOptions"
    placeholder="Select tags..."
    [searchable]="true">
  </app-multi-select>
</form>
```

**2. In Template-Driven Forms:**
```typescript
// template-form.component.html
<form #form="ngForm">
  <app-custom-input
    [(ngModel)]="user.name"
    name="name"
    label="Full Name"
    required
    [minLength]="2">
  </app-custom-input>
  
  <app-rating
    [(ngModel)]="user.rating"
    name="rating"
    label="Satisfaction Rating">
  </app-rating>
</form>
```

**Best Practices:**
- Always implement all required `ControlValueAccessor` methods
- Use `forwardRef` to avoid circular dependency issues
- Provide both `NG_VALUE_ACCESSOR` and `NG_VALIDATORS` when needed
- Handle disabled state properly
- Implement proper accessibility attributes
- Support both reactive and template-driven forms
- Clean up subscriptions and event listeners in `ngOnDestroy`
- Provide meaningful validation errors
- Test with different form scenarios

[Back to Forms and Validation](#forms-and-validation)

### 73. What are sync vs async validators?

**Answer:**
Angular supports two types of validators: **synchronous** (immediate validation) and **asynchronous** (validation requiring external operations like HTTP requests). Understanding when and how to use each type is crucial for effective form validation.

**Synchronous Validators:**

**1. Built-in Sync Validators:**
```typescript
// Built-in synchronous validators
import { Validators, FormBuilder } from '@angular/forms';

export class SyncValidatorComponent {
  form = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, Validators.minLength(8), Validators.maxLength(50)]],
    age: ['', [Validators.required, Validators.min(18), Validators.max(120)]],
    website: ['', [Validators.pattern(/^https?:\/\/.+/)]]
  });
  
  constructor(private fb: FormBuilder) {}
}
```

**2. Custom Sync Validators:**
```typescript
// custom-sync-validators.ts
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

// Function-based validator
export function strongPasswordValidator(): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const value = control.value;
    
    if (!value) {
      return null; // Don't validate empty values (use Validators.required for that)
    }
    
    const hasUpperCase = /[A-Z]/.test(value);
    const hasLowerCase = /[a-z]/.test(value);
    const hasNumeric = /[0-9]/.test(value);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(value);
    
    const passwordValid = hasUpperCase && hasLowerCase && hasNumeric && hasSpecialChar;
    
    return passwordValid ? null : {
      strongPassword: {
        hasUpperCase,
        hasLowerCase,
        hasNumeric,
        hasSpecialChar
      }
    };
  };
}

// Parameterized validator
export function forbiddenNameValidator(forbiddenNames: string[]): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const value = control.value?.toLowerCase();
    const isForbidden = forbiddenNames.some(name => 
      value?.includes(name.toLowerCase())
    );
    
    return isForbidden ? { forbiddenName: { value: control.value } } : null;
  };
}

// Date range validator
export function dateRangeValidator(minDate: Date, maxDate: Date): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    if (!control.value) return null;
    
    const inputDate = new Date(control.value);
    
    if (inputDate < minDate) {
      return { dateRange: { min: minDate, actual: inputDate } };
    }
    
    if (inputDate > maxDate) {
      return { dateRange: { max: maxDate, actual: inputDate } };
    }
    
    return null;
  };
}

// Usage
export class CustomSyncValidatorComponent {
  form = this.fb.group({
    username: ['', [
      Validators.required,
      forbiddenNameValidator(['admin', 'root', 'test'])
    ]],
    password: ['', [
      Validators.required,
      strongPasswordValidator()
    ]],
    birthDate: ['', [
      Validators.required,
      dateRangeValidator(new Date('1900-01-01'), new Date())
    ]]
  });
  
  constructor(private fb: FormBuilder) {}
}
```

**Asynchronous Validators:**

**1. Basic Async Validator:**
```typescript
// async-validators.ts
import { Injectable } from '@angular/core';
import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { Observable, of, timer } from 'rxjs';
import { map, catchError, switchMap, debounceTime } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class AsyncValidatorService {
  constructor(private http: HttpClient) {}
  
  // Email availability validator
  emailAvailableValidator(): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value) {
        return of(null);
      }
      
      return timer(500).pipe( // Debounce for 500ms
        switchMap(() => 
          this.http.get<{ available: boolean }>(`/api/check-email/${control.value}`)
        ),
        map(response => 
          response.available ? null : { emailTaken: true }
        ),
        catchError(() => of({ emailCheckError: true }))
      );
    };
  }
  
  // Username availability validator
  usernameAvailableValidator(): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value || control.value.length < 3) {
        return of(null);
      }
      
      return this.http.post<{ exists: boolean }>('/api/check-username', {
        username: control.value
      }).pipe(
        debounceTime(300),
        map(response => 
          response.exists ? { usernameTaken: true } : null
        ),
        catchError(error => {
          console.error('Username validation error:', error);
          return of({ usernameCheckError: true });
        })
      );
    };
  }
  
  // Custom business rule validator
  businessRuleValidator(): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value) {
        return of(null);
      }
      
      return this.http.post<{ valid: boolean; reason?: string }>(
        '/api/validate-business-rule', 
        { data: control.value }
      ).pipe(
        map(response => 
          response.valid 
            ? null 
            : { businessRule: { reason: response.reason } }
        ),
        catchError(() => of({ businessRuleError: true }))
      );
    };
  }
}
```

**2. Advanced Async Validator with Caching:**
```typescript
// cached-async-validator.service.ts
@Injectable({ providedIn: 'root' })
export class CachedAsyncValidatorService {
  private cache = new Map<string, { result: ValidationErrors | null; timestamp: number }>();
  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
  
  constructor(private http: HttpClient) {}
  
  emailValidatorWithCache(): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value) {
        return of(null);
      }
      
      const cacheKey = `email_${control.value}`;
      const cached = this.cache.get(cacheKey);
      
      // Return cached result if valid
      if (cached && (Date.now() - cached.timestamp) < this.CACHE_DURATION) {
        return of(cached.result);
      }
      
      return timer(300).pipe(
        switchMap(() => 
          this.http.get<{ available: boolean }>(`/api/check-email/${control.value}`)
        ),
        map(response => {
          const result = response.available ? null : { emailTaken: true };
          
          // Cache the result
          this.cache.set(cacheKey, {
            result,
            timestamp: Date.now()
          });
          
          return result;
        }),
        catchError(error => {
          console.error('Email validation error:', error);
          return of({ emailValidationError: true });
        })
      );
    };
  }
  
  clearCache(): void {
    this.cache.clear();
  }
  
  clearExpiredCache(): void {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp > this.CACHE_DURATION) {
        this.cache.delete(key);
      }
    }
  }
}
```

**3. Using Async Validators:**
```typescript
// async-form.component.ts
export class AsyncFormComponent {
  form = this.fb.group({
    email: [
      '',
      [Validators.required, Validators.email], // Sync validators
      [this.asyncValidatorService.emailAvailableValidator()] // Async validators
    ],
    username: [
      '',
      [Validators.required, Validators.minLength(3)],
      [this.asyncValidatorService.usernameAvailableValidator()]
    ]
  });
  
  constructor(
    private fb: FormBuilder,
    private asyncValidatorService: AsyncValidatorService
  ) {}
  
  get emailControl() {
    return this.form.get('email');
  }
  
  get usernameControl() {
    return this.form.get('username');
  }
  
  // Check validation status
  isEmailChecking(): boolean {
    return this.emailControl?.pending ?? false;
  }
  
  isUsernameChecking(): boolean {
    return this.usernameControl?.pending ?? false;
  }
}
```

**4. Template with Loading States:**
```html
<!-- async-form.component.html -->
<form [formGroup]="form">
  <div class="form-group">
    <label for="email">Email:</label>
    <input 
      id="email"
      type="email" 
      formControlName="email"
      class="form-control"
      [class.is-invalid]="emailControl?.invalid && emailControl?.touched"
      [class.is-valid]="emailControl?.valid" />
    
    <!-- Loading indicator -->
    <div *ngIf="isEmailChecking()" class="validation-spinner">
      <span class="spinner"></span>
      Checking email availability...
    </div>
    
    <!-- Error messages -->
    <div *ngIf="emailControl?.errors && emailControl?.touched" class="invalid-feedback">
      <div *ngIf="emailControl.errors['required']">Email is required</div>
      <div *ngIf="emailControl.errors['email']">Please enter a valid email</div>
      <div *ngIf="emailControl.errors['emailTaken']">This email is already taken</div>
      <div *ngIf="emailControl.errors['emailCheckError']">Unable to verify email availability</div>
    </div>
    
    <!-- Success message -->
    <div *ngIf="emailControl?.valid" class="valid-feedback">
      ✓ Email is available
    </div>
  </div>
  
  <div class="form-group">
    <label for="username">Username:</label>
    <input 
      id="username"
      type="text" 
      formControlName="username"
      class="form-control" />
    
    <div *ngIf="isUsernameChecking()" class="validation-spinner">
      <span class="spinner"></span>
      Checking username availability...
    </div>
    
    <div *ngIf="usernameControl?.errors && usernameControl?.touched" class="invalid-feedback">
      <div *ngIf="usernameControl.errors['required']">Username is required</div>
      <div *ngIf="usernameControl.errors['minlength']">Username must be at least 3 characters</div>
      <div *ngIf="usernameControl.errors['usernameTaken']">This username is already taken</div>
    </div>
  </div>
  
  <button 
    type="submit" 
    [disabled]="form.invalid || form.pending"
    class="btn btn-primary">
    <span *ngIf="form.pending" class="spinner"></span>
    Submit
  </button>
</form>
```

**Key Differences:**

| Aspect | Synchronous Validators | Asynchronous Validators |
|--------|----------------------|------------------------|
| **Execution** | Immediate | Returns Observable/Promise |
| **Use Cases** | Format validation, required fields | Server-side validation, availability checks |
| **Performance** | Fast | Slower, network dependent |
| **Form State** | `valid`/`invalid` | `pending` during validation |
| **Implementation** | Return `ValidationErrors \| null` | Return `Observable<ValidationErrors \| null>` |
| **Debouncing** | Not needed | Often required |
| **Caching** | Not applicable | Recommended for performance |

**Best Practices:**
- Use sync validators for immediate validation (format, length, etc.)
- Use async validators for server-side validation (uniqueness, business rules)
- Always implement debouncing in async validators
- Handle network errors gracefully
- Show loading states during async validation
- Cache async validation results when appropriate
- Combine both types: sync validators run first, then async
- Clean up subscriptions to prevent memory leaks

[Back to Forms and Validation](#forms-and-validation)

### 74. How do you create custom validators?

**Answer:**
Custom validators in Angular allow you to implement specific validation logic that goes beyond built-in validators. They can be created as functions or classes and can be synchronous or asynchronous.

**Function-Based Custom Validators:**

**1. Simple Custom Validator:**
```typescript
// validators/custom-validators.ts
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

// Basic email domain validator
export function emailDomainValidator(allowedDomains: string[]): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    if (!control.value) {
      return null; // Don't validate empty values
    }
    
    const email = control.value.toLowerCase();
    const domain = email.split('@')[1];
    
    if (!domain || !allowedDomains.includes(domain)) {
      return {
        emailDomain: {
          actualDomain: domain,
          allowedDomains: allowedDomains
        }
      };
    }
    
    return null;
  };
}

// Usage
const emailControl = new FormControl('', [
  Validators.required,
  Validators.email,
  emailDomainValidator(['company.com', 'organization.org'])
]);
```

**2. Advanced Parameterized Validators:**
```typescript
// Age range validator
export function ageRangeValidator(minAge: number, maxAge: number): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    if (!control.value) return null;
    
    const birthDate = new Date(control.value);
    const today = new Date();
    const age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    
    const actualAge = monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate()) 
      ? age - 1 
      : age;
    
    if (actualAge < minAge) {
      return { ageRange: { minAge, actualAge, message: `Minimum age is ${minAge}` } };
    }
    
    if (actualAge > maxAge) {
      return { ageRange: { maxAge, actualAge, message: `Maximum age is ${maxAge}` } };
    }
    
    return null;
  };
}

// Phone number format validator
export function phoneNumberValidator(format: 'US' | 'INTERNATIONAL' = 'US'): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    if (!control.value) return null;
    
    const phoneNumber = control.value.replace(/\D/g, ''); // Remove non-digits
    
    let isValid = false;
    let expectedFormat = '';
    
    switch (format) {
      case 'US':
        isValid = /^\d{10}$/.test(phoneNumber);
        expectedFormat = '(XXX) XXX-XXXX';
        break;
      case 'INTERNATIONAL':
        isValid = /^\d{7,15}$/.test(phoneNumber);
        expectedFormat = '+X XXX XXX XXXX';
        break;
    }
    
    return isValid ? null : {
      phoneNumber: {
        actualValue: control.value,
        expectedFormat
      }
    };
  };
}

// Credit card validator
export function creditCardValidator(): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    if (!control.value) return null;
    
    const cardNumber = control.value.replace(/\s/g, '');
    
    // Luhn algorithm implementation
    const isValidLuhn = (num: string): boolean => {
      let sum = 0;
      let isEven = false;
      
      for (let i = num.length - 1; i >= 0; i--) {
        let digit = parseInt(num.charAt(i), 10);
        
        if (isEven) {
          digit *= 2;
          if (digit > 9) {
            digit -= 9;
          }
        }
        
        sum += digit;
        isEven = !isEven;
      }
      
      return sum % 10 === 0;
    };
    
    // Check card type and length
    const cardTypes = {
      visa: { pattern: /^4/, length: [13, 16, 19] },
      mastercard: { pattern: /^5[1-5]/, length: [16] },
      amex: { pattern: /^3[47]/, length: [15] },
      discover: { pattern: /^6(?:011|5)/, length: [16] }
    };
    
    let cardType = 'unknown';
    let validLength = false;
    
    for (const [type, config] of Object.entries(cardTypes)) {
      if (config.pattern.test(cardNumber)) {
        cardType = type;
        validLength = config.length.includes(cardNumber.length);
        break;
      }
    }
    
    const isValid = validLength && isValidLuhn(cardNumber);
    
    return isValid ? null : {
      creditCard: {
        cardType,
        validLength,
        validChecksum: isValidLuhn(cardNumber)
      }
    };
  };
}
```

**3. Cross-Field Validators:**
```typescript
// Password confirmation validator (for FormGroup)
export function passwordMatchValidator(): ValidatorFn {
  return (formGroup: AbstractControl): ValidationErrors | null => {
    const password = formGroup.get('password');
    const confirmPassword = formGroup.get('confirmPassword');
    
    if (!password || !confirmPassword) {
      return null;
    }
    
    if (password.value !== confirmPassword.value) {
      // Set error on confirmPassword control
      confirmPassword.setErrors({ passwordMismatch: true });
      return { passwordMismatch: true };
    } else {
      // Clear the error if passwords match
      if (confirmPassword.hasError('passwordMismatch')) {
        delete confirmPassword.errors?.['passwordMismatch'];
        if (Object.keys(confirmPassword.errors || {}).length === 0) {
          confirmPassword.setErrors(null);
        }
      }
    }
    
    return null;
  };
}

// Date range validator (start date must be before end date)
export function dateRangeValidator(startDateField: string, endDateField: string): ValidatorFn {
  return (formGroup: AbstractControl): ValidationErrors | null => {
    const startDate = formGroup.get(startDateField);
    const endDate = formGroup.get(endDateField);
    
    if (!startDate?.value || !endDate?.value) {
      return null;
    }
    
    const start = new Date(startDate.value);
    const end = new Date(endDate.value);
    
    if (start >= end) {
      return {
        dateRange: {
          startDate: startDate.value,
          endDate: endDate.value,
          message: 'End date must be after start date'
        }
      };
    }
    
    return null;
  };
}
```

**Class-Based Custom Validators:**

**1. Injectable Validator Service:**
```typescript
// validators/validator.service.ts
import { Injectable } from '@angular/core';
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { map, catchError, debounceTime, switchMap } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class ValidatorService {
  constructor(private http: HttpClient) {}
  
  // Sync validator method
  createUsernameValidator(forbiddenNames: string[]): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      if (!control.value) return null;
      
      const username = control.value.toLowerCase();
      const isForbidden = forbiddenNames.some(name => 
        username.includes(name.toLowerCase())
      );
      
      if (isForbidden) {
        return {
          forbiddenUsername: {
            actualValue: control.value,
            forbiddenNames
          }
        };
      }
      
      // Additional checks
      if (!/^[a-zA-Z0-9_]+$/.test(control.value)) {
        return {
          usernameFormat: {
            message: 'Username can only contain letters, numbers, and underscores'
          }
        };
      }
      
      return null;
    };
  }
  
  // Async validator method
  createAsyncUsernameValidator() {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value || control.value.length < 3) {
        return of(null);
      }
      
      return of(control.value).pipe(
        debounceTime(500),
        switchMap(username => 
          this.http.get<{ exists: boolean }>(`/api/users/check/${username}`)
        ),
        map(response => 
          response.exists ? { usernameExists: true } : null
        ),
        catchError(() => of({ usernameCheckError: true }))
      );
    };
  }
  
  // Complex business logic validator
  createBusinessRuleValidator(rules: any[]) {
    return (control: AbstractControl): ValidationErrors | null => {
      if (!control.value) return null;
      
      const errors: ValidationErrors = {};
      
      for (const rule of rules) {
        const isValid = this.evaluateRule(control.value, rule);
        if (!isValid) {
          errors[rule.name] = {
            message: rule.message,
            rule: rule.condition
          };
        }
      }
      
      return Object.keys(errors).length > 0 ? errors : null;
    };
  }
  
  private evaluateRule(value: any, rule: any): boolean {
    // Implement your business rule evaluation logic
    switch (rule.type) {
      case 'length':
        return value.length >= rule.min && value.length <= rule.max;
      case 'pattern':
        return new RegExp(rule.pattern).test(value);
      case 'custom':
        return rule.validator(value);
      default:
        return true;
    }
  }
}
```

**2. Directive-Based Validator:**
```typescript
// validators/email-domain.directive.ts
import { Directive, Input } from '@angular/core';
import { NG_VALIDATORS, Validator, AbstractControl, ValidationErrors } from '@angular/forms';

@Directive({
  selector: '[appEmailDomain]',
  providers: [
    {
      provide: NG_VALIDATORS,
      useExisting: EmailDomainValidatorDirective,
      multi: true
    }
  ]
})
export class EmailDomainValidatorDirective implements Validator {
  @Input('appEmailDomain') allowedDomains: string[] = [];
  
  validate(control: AbstractControl): ValidationErrors | null {
    if (!control.value || this.allowedDomains.length === 0) {
      return null;
    }
    
    const email = control.value.toLowerCase();
    const domain = email.split('@')[1];
    
    if (!domain || !this.allowedDomains.includes(domain)) {
      return {
        emailDomain: {
          actualDomain: domain,
          allowedDomains: this.allowedDomains
        }
      };
    }
    
    return null;
  }
}

// Usage in template
// <input type="email" [appEmailDomain]="['company.com', 'organization.org']" />
```

**Usage Examples:**

**1. Reactive Forms:**
```typescript
// user-registration.component.ts
export class UserRegistrationComponent {
  registrationForm = this.fb.group({
    email: ['', [
      Validators.required,
      Validators.email,
      emailDomainValidator(['company.com', 'partner.net'])
    ]],
    birthDate: ['', [
      Validators.required,
      ageRangeValidator(18, 65)
    ]],
    phone: ['', [
      Validators.required,
      phoneNumberValidator('US')
    ]],
    creditCard: ['', [
      creditCardValidator()
    ]],
    username: ['', [
      Validators.required,
      Validators.minLength(3),
      this.validatorService.createUsernameValidator(['admin', 'root'])
    ], [
      this.validatorService.createAsyncUsernameValidator()
    ]]
  }, {
    validators: [passwordMatchValidator()]
  });
  
  constructor(
    private fb: FormBuilder,
    private validatorService: ValidatorService
  ) {}
}
```

**2. Template-Driven Forms:**
```html
<!-- user-form.component.html -->
<form #userForm="ngForm">
  <input 
    type="email" 
    name="email"
    [(ngModel)]="user.email"
    required
    email
    [appEmailDomain]="['company.com', 'organization.org']" />
  
  <div *ngIf="userForm.get('email')?.errors?.['emailDomain']" class="error">
    Email must be from allowed domains: 
    {{userForm.get('email')?.errors?.['emailDomain']?.allowedDomains?.join(', ')}}
  </div>
</form>
```

**3. Dynamic Validator Assignment:**
```typescript
// dynamic-validation.component.ts
export class DynamicValidationComponent {
  form = this.fb.group({
    value: [''],
    validationType: ['email']
  });
  
  constructor(private fb: FormBuilder) {
    // Watch for validation type changes
    this.form.get('validationType')?.valueChanges.subscribe(type => {
      this.updateValidators(type);
    });
  }
  
  private updateValidators(type: string): void {
    const valueControl = this.form.get('value');
    if (!valueControl) return;
    
    // Clear existing validators
    valueControl.clearValidators();
    
    // Add new validators based on type
    switch (type) {
      case 'email':
        valueControl.setValidators([
          Validators.required,
          Validators.email,
          emailDomainValidator(['company.com'])
        ]);
        break;
      case 'phone':
        valueControl.setValidators([
          Validators.required,
          phoneNumberValidator('US')
        ]);
        break;
      case 'creditCard':
        valueControl.setValidators([
          Validators.required,
          creditCardValidator()
        ]);
        break;
    }
    
    // Trigger validation
    valueControl.updateValueAndValidity();
  }
}
```

**Testing Custom Validators:**

```typescript
// custom-validators.spec.ts
import { FormControl } from '@angular/forms';
import { emailDomainValidator, phoneNumberValidator, creditCardValidator } from './custom-validators';

describe('Custom Validators', () => {
  describe('emailDomainValidator', () => {
    it('should pass for allowed domain', () => {
      const validator = emailDomainValidator(['company.com']);
      const control = new FormControl('user@company.com');
      
      expect(validator(control)).toBeNull();
    });
    
    it('should fail for disallowed domain', () => {
      const validator = emailDomainValidator(['company.com']);
      const control = new FormControl('user@other.com');
      
      const result = validator(control);
      expect(result).toEqual({
        emailDomain: {
          actualDomain: 'other.com',
          allowedDomains: ['company.com']
        }
      });
    });
  });
  
  describe('phoneNumberValidator', () => {
    it('should validate US phone number format', () => {
      const validator = phoneNumberValidator('US');
      const control = new FormControl('1234567890');
      
      expect(validator(control)).toBeNull();
    });
  });
  
  describe('creditCardValidator', () => {
    it('should validate valid Visa card', () => {
      const validator = creditCardValidator();
      const control = new FormControl('4532015112830366'); // Valid Visa test number
      
      expect(validator(control)).toBeNull();
    });
  });
});
```

**Best Practices:**
- Return `null` for valid values, error object for invalid
- Use descriptive error keys and provide helpful error details
- Don't validate empty values (use `Validators.required` for that)
- Make validators pure functions when possible
- Provide clear error messages for user feedback
- Test validators thoroughly with edge cases
- Use parameterized validators for reusability
- Combine multiple simple validators rather than creating complex ones
- Consider performance implications for complex validation logic

[Back to Forms and Validation](#forms-and-validation)

### 75. How do you handle dynamic forms with `FormArray` and nested `FormGroup`s?

**Answer:**
Dynamic forms with `FormArray` and nested `FormGroup`s allow you to create complex, flexible forms where users can add/remove sections dynamically. This is essential for scenarios like contact lists, skill sets, or any repeating form sections.

**Basic FormArray Implementation:**

**1. Simple Dynamic List:**
```typescript
// dynamic-list.component.ts
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, FormArray, Validators } from '@angular/forms';

@Component({
  selector: 'app-dynamic-list',
  template: `
    <form [formGroup]="form">
      <h3>Skills</h3>
      
      <div `formArrayName`="skills">
        <div *ngFor="let skill of skillsArray.controls; let i = index" 
             [formGroupName]="i" 
             class="skill-item">
          
          <input 
            formControlName="name" 
            placeholder="Skill name"
            class="form-control" />
          
          <select formControlName="level" class="form-control">
            <option value="">Select level</option>
            <option value="beginner">Beginner</option>
            <option value="intermediate">Intermediate</option>
            <option value="advanced">Advanced</option>
            <option value="expert">Expert</option>
          </select>
          
          <input 
            type="number" 
            formControlName="years" 
            placeholder="Years of experience"
            min="0" 
            max="50"
            class="form-control" />
          
          <button 
            type="button" 
            (click)="removeSkill(i)"
            class="btn btn-danger btn-sm">
            Remove
          </button>
        </div>
      </div>
      
      <button 
        type="button" 
        (click)="addSkill()"
        class="btn btn-primary">
        Add Skill
      </button>
      
      <div class="form-actions">
        <button 
          type="submit" 
          [disabled]="form.invalid"
          class="btn btn-success">
          Submit
        </button>
        <button 
          type="button" 
          (click)="loadSampleData()"
          class="btn btn-secondary">
          Load Sample Data
        </button>
      </div>
      
      <pre>{{form.value | json}}</pre>
    </form>
  `,
  styles: [`
    .skill-item {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      align-items: center;
    }
    
    .form-control {
      flex: 1;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .btn-primary { background: #007bff; color: white; }
    .btn-danger { background: #dc3545; color: white; }
    .btn-success { background: #28a745; color: white; }
    .btn-secondary { background: #6c757d; color: white; }
  `]
})
export class DynamicListComponent {
  form: FormGroup;
  
  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      skills: this.fb.array([])
    });
    
    // Add initial skill
    this.addSkill();
  }
  
  get skillsArray(): FormArray {
    return this.form.get('skills') as FormArray;
  }
  
  createSkillGroup(): FormGroup {
    return this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2)]],
      level: ['', Validators.required],
      years: [0, [Validators.required, Validators.min(0), Validators.max(50)]]
    });
  }
  
  addSkill(): void {
    this.skillsArray.push(this.createSkillGroup());
  }
  
  removeSkill(index: number): void {
    if (this.skillsArray.length > 1) {
      this.skillsArray.removeAt(index);
    }
  }
  
  loadSampleData(): void {
    const sampleSkills = [
      { name: 'JavaScript', level: 'advanced', years: 5 },
      { name: 'Angular', level: 'expert', years: 3 },
      { name: 'Node.js', level: 'intermediate', years: 2 }
    ];
    
    // Clear existing skills
    while (this.skillsArray.length > 0) {
      this.skillsArray.removeAt(0);
    }
    
    // Add sample skills
    sampleSkills.forEach(skill => {
      const skillGroup = this.createSkillGroup();
      skillGroup.patchValue(skill);
      this.skillsArray.push(skillGroup);
    });
  }
}
```

**2. Complex Nested Form Structure:**
```typescript
// employee-form.component.ts
interface Address {
  street: string;
  city: string;
  state: string;
  zipCode: string;
  type: 'home' | 'work' | 'other';
}

interface Contact {
  type: 'email' | 'phone' | 'fax';
  value: string;
  isPrimary: boolean;
}

interface Employee {
  personalInfo: {
    firstName: string;
    lastName: string;
    dateOfBirth: string;
  };
  addresses: Address[];
  contacts: Contact[];
  skills: Array<{
    name: string;
    level: string;
    years: number;
  }>;
}

@Component({
  selector: 'app-employee-form',
  template: `
    <form [formGroup]="employeeForm" (ngSubmit)="onSubmit()">
      <!-- Personal Information -->
      <fieldset formGroupName="personalInfo">
        <legend>Personal Information</legend>
        
        <div class="form-row">
          <div class="form-group">
            <label>First Name:</label>
            <input formControlName="firstName" class="form-control" />
            <div *ngIf="getControl('personalInfo.firstName')?.errors?.['required'] && getControl('personalInfo.firstName')?.touched" 
                 class="error">First name is required</div>
          </div>
          
          <div class="form-group">
            <label>Last Name:</label>
            <input formControlName="lastName" class="form-control" />
            <div *ngIf="getControl('personalInfo.lastName')?.errors?.['required'] && getControl('personalInfo.lastName')?.touched" 
                 class="error">Last name is required</div>
          </div>
          
          <div class="form-group">
            <label>Date of Birth:</label>
            <input type="date" formControlName="dateOfBirth" class="form-control" />
          </div>
        </div>
      </fieldset>
      
      <!-- Addresses -->
      <fieldset>
        <legend>Addresses</legend>
        
        <div formArrayName="addresses">
          <div *ngFor="let address of addressesArray.controls; let i = index" 
               [formGroupName]="i" 
               class="address-group">
            
            <h4>Address {{i + 1}}</h4>
            
            <div class="form-row">
              <div class="form-group">
                <label>Type:</label>
                <select formControlName="type" class="form-control">
                  <option value="home">Home</option>
                  <option value="work">Work</option>
                  <option value="other">Other</option>
                </select>
              </div>
            </div>
            
            <div class="form-group">
              <label>Street:</label>
              <input formControlName="street" class="form-control" />
            </div>
            
            <div class="form-row">
              <div class="form-group">
                <label>City:</label>
                <input formControlName="city" class="form-control" />
              </div>
              
              <div class="form-group">
                <label>State:</label>
                <input formControlName="state" class="form-control" />
              </div>
              
              <div class="form-group">
                <label>Zip Code:</label>
                <input formControlName="zipCode" class="form-control" />
              </div>
            </div>
            
            <button type="button" (click)="removeAddress(i)" class="btn btn-danger btn-sm">
              Remove Address
            </button>
          </div>
        </div>
        
        <button type="button" (click)="addAddress()" class="btn btn-primary">
          Add Address
        </button>
      </fieldset>
      
      <!-- Contacts -->
      <fieldset>
        <legend>Contact Information</legend>
        
        <div formArrayName="contacts">
          <div *ngFor="let contact of contactsArray.controls; let i = index" 
               [formGroupName]="i" 
               class="contact-group">
            
            <div class="form-row">
              <div class="form-group">
                <label>Type:</label>
                <select formControlName="type" class="form-control">
                  <option value="email">Email</option>
                  <option value="phone">Phone</option>
                  <option value="fax">Fax</option>
                </select>
              </div>
              
              <div class="form-group">
                <label>Value:</label>
                <input formControlName="value" class="form-control" 
                       [type]="getContactInputType(i)" />
              </div>
              
              <div class="form-group">
                <label>
                  <input type="checkbox" formControlName="isPrimary" />
                  Primary
                </label>
              </div>
              
              <button type="button" (click)="removeContact(i)" class="btn btn-danger btn-sm">
                Remove
              </button>
            </div>
          </div>
        </div>
        
        <button type="button" (click)="addContact()" class="btn btn-primary">
          Add Contact
        </button>
      </fieldset>
      
      <!-- Skills (reuse from previous example) -->
      <fieldset>
        <legend>Skills</legend>
        <!-- Skills form array implementation here -->
      </fieldset>
      
      <div class="form-actions">
        <button type="submit" [disabled]="employeeForm.invalid" class="btn btn-success">
          Save Employee
        </button>
        <button type="button" (click)="resetForm()" class="btn btn-secondary">
          Reset
        </button>
      </div>
      
      <!-- Debug info -->
      <details>
        <summary>Form Debug Info</summary>
        <pre>Form Valid: {{employeeForm.valid}}</pre>
        <pre>Form Value: {{employeeForm.value | json}}</pre>
        <pre>Form Errors: {{getFormErrors() | json}}</pre>
      </details>
    </form>
  `,
  styles: [`
    fieldset {
      margin: 2rem 0;
      padding: 1rem;
      border: 2px solid #ddd;
      border-radius: 8px;
    }
    
    legend {
      font-weight: bold;
      padding: 0 0.5rem;
    }
    
    .form-row {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .form-group {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    
    .address-group, .contact-group {
      border: 1px solid #eee;
      padding: 1rem;
      margin-bottom: 1rem;
      border-radius: 4px;
    }
    
    .error {
      color: #dc3545;
      font-size: 0.875rem;
      margin-top: 0.25rem;
    }
  `]
})
export class EmployeeFormComponent {
  employeeForm: FormGroup;
  
  constructor(private fb: FormBuilder) {
    this.employeeForm = this.createEmployeeForm();
  }
  
  createEmployeeForm(): FormGroup {
    return this.fb.group({
      personalInfo: this.fb.group({
        firstName: ['', [Validators.required, Validators.minLength(2)]],
        lastName: ['', [Validators.required, Validators.minLength(2)]],
        dateOfBirth: ['', Validators.required]
      }),
      addresses: this.fb.array([this.createAddressGroup()]),
      contacts: this.fb.array([this.createContactGroup()]),
      skills: this.fb.array([])
    });
  }
  
  createAddressGroup(): FormGroup {
    return this.fb.group({
      type: ['home', Validators.required],
      street: ['', Validators.required],
      city: ['', Validators.required],
      state: ['', Validators.required],
      zipCode: ['', [Validators.required, Validators.pattern(/^\d{5}(-\d{4})?$/)]]
    });
  }
  
  createContactGroup(): FormGroup {
    return this.fb.group({
      type: ['email', Validators.required],
      value: ['', Validators.required],
      isPrimary: [false]
    });
  }
  
  get addressesArray(): FormArray {
    return this.employeeForm.get('addresses') as FormArray;
  }
  
  get contactsArray(): FormArray {
    return this.employeeForm.get('contacts') as FormArray;
  }
  
  addAddress(): void {
    this.addressesArray.push(this.createAddressGroup());
  }
  
  removeAddress(index: number): void {
    if (this.addressesArray.length > 1) {
      this.addressesArray.removeAt(index);
    }
  }
  
  addContact(): void {
    this.contactsArray.push(this.createContactGroup());
  }
  
  removeContact(index: number): void {
    if (this.contactsArray.length > 1) {
      this.contactsArray.removeAt(index);
    }
  }
  
  getContactInputType(index: number): string {
    const contactType = this.contactsArray.at(index).get('type')?.value;
    return contactType === 'email' ? 'email' : 'tel';
  }
  
  getControl(path: string) {
    return this.employeeForm.get(path);
  }
  
  getFormErrors(): any {
    const errors: any = {};
    
    const collectErrors = (control: any, path: string = '') => {
      if (control instanceof FormGroup) {
        Object.keys(control.controls).forEach(key => {
          const childControl = control.get(key);
          const childPath = path ? `${path}.${key}` : key;
          collectErrors(childControl, childPath);
        });
      } else if (control instanceof FormArray) {
        control.controls.forEach((childControl, index) => {
          const childPath = `${path}[${index}]`;
          collectErrors(childControl, childPath);
        });
      } else if (control?.errors) {
        errors[path] = control.errors;
      }
    };
    
    collectErrors(this.employeeForm);
    return errors;
  }
  
  onSubmit(): void {
    if (this.employeeForm.valid) {
      const employee: Employee = this.employeeForm.value;
      console.log('Submitting employee:', employee);
      // Handle form submission
    } else {
      console.log('Form is invalid:', this.getFormErrors());
      this.markFormGroupTouched();
    }
  }
  
  private markFormGroupTouched(): void {
    const markTouched = (control: any) => {
      if (control instanceof FormGroup || control instanceof FormArray) {
        Object.keys(control.controls).forEach(key => {
          markTouched(control.get(key));
        });
      } else {
        control.markAsTouched();
      }
    };
    
    markTouched(this.employeeForm);
  }
  
  resetForm(): void {
    this.employeeForm = this.createEmployeeForm();
  }
}
```

**3. Advanced Dynamic Form Builder:**
```typescript
// dynamic-form-builder.service.ts
import { Injectable } from '@angular/core';
import { FormBuilder, FormGroup, FormArray, FormControl, Validators } from '@angular/forms';

interface FieldConfig {
  type: 'text' | 'email' | 'number' | 'select' | 'checkbox' | 'date' | 'group' | 'array';
  name: string;
  label: string;
  value?: any;
  required?: boolean;
  options?: Array<{ label: string; value: any }>;
  fields?: FieldConfig[]; // For nested groups
  itemTemplate?: FieldConfig[]; // For arrays
  validators?: any[];
}

@Injectable({ providedIn: 'root' })
export class DynamicFormBuilderService {
  constructor(private fb: FormBuilder) {}
  
  createFormGroup(fields: FieldConfig[]): FormGroup {
    const group: any = {};
    
    fields.forEach(field => {
      if (field.type === 'group' && field.fields) {
        group[field.name] = this.createFormGroup(field.fields);
      } else if (field.type === 'array') {
        group[field.name] = this.fb.array(
          field.value ? field.value.map((item: any) => this.createArrayItem(field, item)) : []
        );
      } else {
        const validators = this.getValidators(field);
        group[field.name] = [field.value || '', validators];
      }
    });
    
    return this.fb.group(group);
  }
  
  createArrayItem(fieldConfig: FieldConfig, value?: any): FormGroup | FormControl {
    if (fieldConfig.itemTemplate) {
      const group = this.createFormGroup(fieldConfig.itemTemplate);
      if (value) {
        group.patchValue(value);
      }
      return group;
    } else {
      return this.fb.control(value || '');
    }
  }
  
  addArrayItem(formArray: FormArray, fieldConfig: FieldConfig): void {
    const newItem = this.createArrayItem(fieldConfig);
    formArray.push(newItem);
  }
  
  removeArrayItem(formArray: FormArray, index: number): void {
    formArray.removeAt(index);
  }
  
  private getValidators(field: FieldConfig): any[] {
    const validators: any[] = [];
    
    if (field.required) {
      validators.push(Validators.required);
    }
    
    if (field.type === 'email') {
      validators.push(Validators.email);
    }
    
    if (field.validators) {
      validators.push(...field.validators);
    }
    
    return validators;
  }
}

// Usage example
@Component({
  selector: 'app-dynamic-form',
  template: `
    <form [formGroup]="dynamicForm">
      <div *ngFor="let field of formConfig" [ngSwitch]="field.type">
        
        <!-- Text/Email/Number inputs -->
        <div *ngSwitchCase="'text'" class="form-group">
          <label>{{field.label}}</label>
          <input [formControlName]="field.name" class="form-control" />
        </div>
        
        <!-- Array fields -->
        <div *ngSwitchCase="'array'" class="array-field">
          <label>{{field.label}}</label>
          <div [formArrayName]="field.name">
            <div *ngFor="let item of getFormArray(field.name).controls; let i = index" 
                 [formGroupName]="i">
              <!-- Render array item fields dynamically -->
              <div *ngFor="let subField of field.itemTemplate" class="form-group">
                <input [formControlName]="subField.name" 
                       [placeholder]="subField.label" 
                       class="form-control" />
              </div>
              <button type="button" (click)="removeArrayItem(field.name, i)">
                Remove
              </button>
            </div>
          </div>
          <button type="button" (click)="addArrayItem(field)">
            Add {{field.label}}
          </button>
        </div>
        
      </div>
    </form>
  `
})
export class DynamicFormComponent {
  dynamicForm: FormGroup;
  
  formConfig: FieldConfig[] = [
    {
      type: 'text',
      name: 'name',
      label: 'Full Name',
      required: true
    },
    {
      type: 'array',
      name: 'addresses',
      label: 'Address',
      itemTemplate: [
        { type: 'text', name: 'street', label: 'Street', required: true },
        { type: 'text', name: 'city', label: 'City', required: true }
      ]
    }
  ];
  
  constructor(private dynamicFormBuilder: DynamicFormBuilderService) {
    this.dynamicForm = this.dynamicFormBuilder.createFormGroup(this.formConfig);
  }
  
  getFormArray(name: string): FormArray {
    return this.dynamicForm.get(name) as FormArray;
  }
  
  addArrayItem(fieldConfig: FieldConfig): void {
    const formArray = this.getFormArray(fieldConfig.name);
    this.dynamicFormBuilder.addArrayItem(formArray, fieldConfig);
  }
  
  removeArrayItem(arrayName: string, index: number): void {
    const formArray = this.getFormArray(arrayName);
    this.dynamicFormBuilder.removeArrayItem(formArray, index);
  }
}
```

**Best Practices:**
- Use TypeScript interfaces to define form structure
- Create reusable methods for adding/removing array items
- Implement proper validation for nested forms
- Handle form state management carefully
- Provide clear user feedback for validation errors
- Use trackBy functions for better performance with large arrays
- Implement proper accessibility for dynamic forms
- Consider using reactive form patterns for complex scenarios
- Test dynamic form behavior thoroughly

[Back to Forms and Validation](#forms-and-validation)

### 76. What is form validation and how to display errors?

**Answer:**
Form validation ensures data integrity and provides user feedback. Angular offers multiple validation approaches and error display strategies for both reactive and template-driven forms.

**Validation Approaches:**

**1. Built-in Validators:**
```typescript
// reactive-form.component.ts
export class ReactiveFormComponent {
  userForm = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, Validators.minLength(8)]],
    age: ['', [Validators.required, Validators.min(18), Validators.max(120)]],
    website: ['', Validators.pattern(/^https?:\/\/.+/)]
  });
  
  constructor(private fb: FormBuilder) {}
}
```

**2. Error Display Strategies:**
```html
<!-- Comprehensive error display -->
<form [formGroup]="userForm">
  <div class="form-group">
    <label for="email">Email *</label>
    <input 
      id="email"
      type="email" 
      formControlName="email"
      class="form-control"
      [class.is-invalid]="isFieldInvalid('email')"
      [class.is-valid]="isFieldValid('email')" />
    
    <!-- Multiple error display approaches -->
    
    <!-- Approach 1: Individual error checks -->
    <div *ngIf="isFieldInvalid('email')" class="invalid-feedback">
      <div *ngIf="userForm.get('email')?.errors?.['required']">Email is required</div>
      <div *ngIf="userForm.get('email')?.errors?.['email']">Please enter a valid email address</div>
    </div>
    
    <!-- Approach 2: Generic error component -->
    <app-field-errors [control]="userForm.get('email')" [fieldName]="'Email'"></app-field-errors>
    
    <!-- Approach 3: Custom error messages -->
    <div *ngIf="getFieldError('email')" class="invalid-feedback">
      {{getFieldError('email')}}
    </div>
  </div>
</form>
```

**3. Error Display Component:**
```typescript
// field-errors.component.ts
@Component({
  selector: 'app-field-errors',
  template: `
    <div *ngIf="hasErrors()" class="field-errors">
      <div *ngFor="let error of getErrorMessages()" class="error-message">
        <i class="error-icon">⚠</i>
        {{error}}
      </div>
    </div>
  `,
  styles: [`
    .field-errors {
      margin-top: 0.25rem;
    }
    
    .error-message {
      color: #dc3545;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin-bottom: 0.125rem;
    }
    
    .error-icon {
      font-size: 0.75rem;
    }
  `]
})
export class FieldErrorsComponent {
  @Input() control: AbstractControl | null = null;
  @Input() fieldName = 'Field';
  @Input() customMessages: { [key: string]: string } = {};
  
  private defaultMessages: { [key: string]: (error: any) => string } = {
    required: () => `${this.fieldName} is required`,
    email: () => 'Please enter a valid email address',
    minlength: (error) => `${this.fieldName} must be at least ${error.requiredLength} characters`,
    maxlength: (error) => `${this.fieldName} cannot exceed ${error.requiredLength} characters`,
    min: (error) => `${this.fieldName} must be at least ${error.min}`,
    max: (error) => `${this.fieldName} cannot exceed ${error.max}`,
    pattern: () => `${this.fieldName} format is invalid`
  };
  
  hasErrors(): boolean {
    return !!(this.control?.errors && this.control?.touched);
  }
  
  getErrorMessages(): string[] {
    if (!this.control?.errors) return [];
    
    return Object.keys(this.control.errors).map(errorKey => {
      const errorValue = this.control!.errors![errorKey];
      
      // Check for custom message first
      if (this.customMessages[errorKey]) {
        return this.customMessages[errorKey];
      }
      
      // Use default message
      const messageFunction = this.defaultMessages[errorKey];
      return messageFunction ? messageFunction(errorValue) : `${this.fieldName} is invalid`;
    });
  }
}
```

**4. Advanced Validation Service:**
```typescript
// validation.service.ts
@Injectable({ providedIn: 'root' })
export class ValidationService {
  private errorMessages: { [key: string]: (error: any, fieldName: string) => string } = {
    required: (error, field) => `${field} is required`,
    email: (error, field) => 'Please enter a valid email address',
    minlength: (error, field) => `${field} must be at least ${error.requiredLength} characters (current: ${error.actualLength})`,
    maxlength: (error, field) => `${field} cannot exceed ${error.requiredLength} characters (current: ${error.actualLength})`,
    min: (error, field) => `${field} must be at least ${error.min} (current: ${error.actual})`,
    max: (error, field) => `${field} cannot exceed ${error.max} (current: ${error.actual})`,
    pattern: (error, field) => `${field} format is invalid`,
    
    // Custom validators
    emailDomain: (error, field) => `Email must be from allowed domains: ${error.allowedDomains.join(', ')}`,
    passwordStrength: (error, field) => this.getPasswordStrengthMessage(error),
    dateRange: (error, field) => `Date must be between ${error.min} and ${error.max}`,
    uniqueEmail: (error, field) => 'This email address is already registered',
    usernameExists: (error, field) => 'This username is already taken'
  };
  
  getFieldErrorMessage(control: AbstractControl, fieldName: string): string | null {
    if (!control.errors || !control.touched) {
      return null;
    }
    
    const firstErrorKey = Object.keys(control.errors)[0];
    const errorValue = control.errors[firstErrorKey];
    const messageFunction = this.errorMessages[firstErrorKey];
    
    return messageFunction ? messageFunction(errorValue, fieldName) : `${fieldName} is invalid`;
  }
  
  getAllFieldErrors(control: AbstractControl, fieldName: string): string[] {
    if (!control.errors || !control.touched) {
      return [];
    }
    
    return Object.keys(control.errors).map(errorKey => {
      const errorValue = control.errors![errorKey];
      const messageFunction = this.errorMessages[errorKey];
      return messageFunction ? messageFunction(errorValue, fieldName) : `${fieldName} is invalid`;
    });
  }
  
  getFormErrors(formGroup: FormGroup): { [key: string]: string[] } {
    const formErrors: { [key: string]: string[] } = {};
    
    const processControl = (control: AbstractControl, path: string) => {
      if (control instanceof FormGroup) {
        Object.keys(control.controls).forEach(key => {
          const childControl = control.get(key)!;
          const childPath = path ? `${path}.${key}` : key;
          processControl(childControl, childPath);
        });
      } else if (control instanceof FormArray) {
        control.controls.forEach((childControl, index) => {
          const childPath = `${path}[${index}]`;
          processControl(childControl, childPath);
        });
      } else {
        const errors = this.getAllFieldErrors(control, path);
        if (errors.length > 0) {
          formErrors[path] = errors;
        }
      }
    };
    
    processControl(formGroup, '');
    return formErrors;
  }
  
  private getPasswordStrengthMessage(error: any): string {
    const requirements = [];
    if (!error.hasUpperCase) requirements.push('uppercase letter');
    if (!error.hasLowerCase) requirements.push('lowercase letter');
    if (!error.hasNumeric) requirements.push('number');
    if (!error.hasSpecialChar) requirements.push('special character');
    
    return `Password must contain: ${requirements.join(', ')}`;
  }
  
  // Method to register custom error messages
  registerErrorMessage(errorKey: string, messageFunction: (error: any, fieldName: string) => string): void {
    this.errorMessages[errorKey] = messageFunction;
  }
}
```

**5. Real-time Validation Component:**
```typescript
// real-time-validation.component.ts
@Component({
  selector: 'app-real-time-validation',
  template: `
    <form [formGroup]="form">
      <div class="form-group">
        <label>Username</label>
        <input 
          formControlName="username"
          class="form-control"
          [class.is-invalid]="isFieldInvalid('username')"
          [class.is-valid]="isFieldValid('username')"
          [class.is-pending]="isFieldPending('username')" />
        
        <!-- Real-time feedback -->
        <div class="field-feedback">
          <div *ngIf="isFieldPending('username')" class="pending-feedback">
            <span class="spinner"></span>
            Checking availability...
          </div>
          
          <div *ngIf="isFieldValid('username')" class="valid-feedback">
            ✓ Username is available
          </div>
          
          <div *ngIf="isFieldInvalid('username')" class="invalid-feedback">
            <div *ngFor="let error of getFieldErrors('username')">
              {{error}}
            </div>
          </div>
        </div>
        
        <!-- Strength indicator for passwords -->
        <div *ngIf="form.get('password')?.value" class="password-strength">
          <div class="strength-bar">
            <div class="strength-fill" 
                 [style.width.%]="getPasswordStrength()"
                 [class]="getPasswordStrengthClass()"></div>
          </div>
          <span class="strength-text">{{getPasswordStrengthText()}}</span>
        </div>
      </div>
      
      <!-- Form summary errors -->
      <div *ngIf="form.invalid && form.touched" class="form-errors">
        <h4>Please fix the following errors:</h4>
        <ul>
          <li *ngFor="let error of getFormErrorList()">{{error}}</li>
        </ul>
      </div>
    </form>
  `,
  styles: [`
    .field-feedback {
      margin-top: 0.25rem;
      min-height: 1.5rem;
    }
    
    .valid-feedback {
      color: #28a745;
      font-size: 0.875rem;
    }
    
    .invalid-feedback {
      color: #dc3545;
      font-size: 0.875rem;
    }
    
    .pending-feedback {
      color: #6c757d;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .password-strength {
      margin-top: 0.5rem;
    }
    
    .strength-bar {
      height: 4px;
      background: #e9ecef;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .strength-fill {
      height: 100%;
      transition: width 0.3s, background-color 0.3s;
    }
    
    .strength-fill.weak { background: #dc3545; }
    .strength-fill.fair { background: #ffc107; }
    .strength-fill.good { background: #17a2b8; }
    .strength-fill.strong { background: #28a745; }
    
    .form-errors {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      padding: 1rem;
      border-radius: 4px;
      margin-top: 1rem;
    }
  `]
})
export class RealTimeValidationComponent {
  form = this.fb.group({
    username: ['', 
      [Validators.required, Validators.minLength(3)],
      [this.asyncUsernameValidator()]
    ],
    password: ['', [Validators.required, this.passwordStrengthValidator()]]
  });
  
  constructor(
    private fb: FormBuilder,
    private validationService: ValidationService
  ) {}
  
  isFieldInvalid(fieldName: string): boolean {
    const field = this.form.get(fieldName);
    return !!(field?.invalid && field?.touched);
  }
  
  isFieldValid(fieldName: string): boolean {
    const field = this.form.get(fieldName);
    return !!(field?.valid && field?.touched);
  }
  
  isFieldPending(fieldName: string): boolean {
    const field = this.form.get(fieldName);
    return !!(field?.pending);
  }
  
  getFieldErrors(fieldName: string): string[] {
    const field = this.form.get(fieldName);
    return field ? this.validationService.getAllFieldErrors(field, fieldName) : [];
  }
  
  getFormErrorList(): string[] {
    const formErrors = this.validationService.getFormErrors(this.form);
    return Object.values(formErrors).flat();
  }
  
  getPasswordStrength(): number {
    const password = this.form.get('password')?.value || '';
    let strength = 0;
    
    if (password.length >= 8) strength += 25;
    if (/[a-z]/.test(password)) strength += 25;
    if (/[A-Z]/.test(password)) strength += 25;
    if (/[0-9]/.test(password)) strength += 25;
    if (/[^A-Za-z0-9]/.test(password)) strength += 25;
    
    return Math.min(strength, 100);
  }
  
  getPasswordStrengthClass(): string {
    const strength = this.getPasswordStrength();
    if (strength < 25) return 'weak';
    if (strength < 50) return 'fair';
    if (strength < 75) return 'good';
    return 'strong';
  }
  
  getPasswordStrengthText(): string {
    const strength = this.getPasswordStrength();
    if (strength < 25) return 'Weak';
    if (strength < 50) return 'Fair';
    if (strength < 75) return 'Good';
    return 'Strong';
  }
  
  private passwordStrengthValidator(): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const value = control.value;
      if (!value) return null;
      
      const hasUpperCase = /[A-Z]/.test(value);
      const hasLowerCase = /[a-z]/.test(value);
      const hasNumeric = /[0-9]/.test(value);
      const hasSpecialChar = /[^A-Za-z0-9]/.test(value);
      
      const isValid = hasUpperCase && hasLowerCase && hasNumeric && hasSpecialChar;
      
      return isValid ? null : {
        passwordStrength: {
          hasUpperCase,
          hasLowerCase,
          hasNumeric,
          hasSpecialChar
        }
      };
    };
  }
  
  private asyncUsernameValidator(): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value) return of(null);
      
      return timer(500).pipe(
        switchMap(() => 
          // Simulate API call
          of(['admin', 'root', 'test'].includes(control.value.toLowerCase()))
        ),
        map(exists => exists ? { usernameExists: true } : null)
      );
    };
  }
}
```

**Best Practices:**
- Show validation errors only after user interaction (touched)
- Provide clear, actionable error messages
- Use real-time validation for better UX
- Implement proper accessibility with ARIA attributes
- Create reusable error display components
- Handle async validation states (pending)
- Provide form-level error summaries
- Use consistent error styling across the application

[Back to Forms and Validation](#forms-and-validation)

### 77. How do you implement conditional validation?

**Answer:**
Conditional validation allows you to apply different validation rules based on form state, user selections, or other dynamic conditions. This is essential for complex forms with interdependent fields.

**Basic Conditional Validation:**

**1. Simple Conditional Validators:**
```typescript
// conditional-form.component.ts
export class ConditionalFormComponent {
  form = this.fb.group({
    accountType: ['personal', Validators.required],
    companyName: [''], // Conditionally required
    taxId: [''], // Conditionally required
    personalId: [''], // Conditionally required
    age: [''],
    parentConsent: [false] // Required if age < 18
  });
  
  constructor(private fb: FormBuilder) {
    this.setupConditionalValidation();
  }
  
  private setupConditionalValidation(): void {
    // Watch account type changes
    this.form.get('accountType')?.valueChanges.subscribe(accountType => {
      this.updateBusinessFieldValidation(accountType);
    });
    
    // Watch age changes
    this.form.get('age')?.valueChanges.subscribe(age => {
      this.updateParentConsentValidation(age);
    });
  }
  
  private updateBusinessFieldValidation(accountType: string): void {
    const companyNameControl = this.form.get('companyName');
    const taxIdControl = this.form.get('taxId');
    const personalIdControl = this.form.get('personalId');
    
    if (accountType === 'business') {
      // Business account: require company fields
      companyNameControl?.setValidators([Validators.required, Validators.minLength(2)]);
      taxIdControl?.setValidators([Validators.required, Validators.pattern(/^\d{9}$/)]);
      personalIdControl?.clearValidators();
    } else {
      // Personal account: require personal ID
      companyNameControl?.clearValidators();
      taxIdControl?.clearValidators();
      personalIdControl?.setValidators([Validators.required, Validators.minLength(5)]);
    }
    
    // Update validation status
    companyNameControl?.updateValueAndValidity();
    taxIdControl?.updateValueAndValidity();
    personalIdControl?.updateValueAndValidity();
  }
  
  private updateParentConsentValidation(age: number): void {
    const parentConsentControl = this.form.get('parentConsent');
    
    if (age < 18) {
      parentConsentControl?.setValidators([Validators.requiredTrue]);
    } else {
      parentConsentControl?.clearValidators();
    }
    
    parentConsentControl?.updateValueAndValidity();
  }
}
```

**2. Advanced Conditional Validation Service:**
```typescript
// conditional-validation.service.ts
interface ValidationRule {
  field: string;
  condition: (formValue: any) => boolean;
  validators: ValidatorFn[];
  clearWhenInactive?: boolean;
}

@Injectable({ providedIn: 'root' })
export class ConditionalValidationService {
  
  setupConditionalValidation(form: FormGroup, rules: ValidationRule[]): void {
    // Watch for form changes
    form.valueChanges.subscribe(formValue => {
      this.applyConditionalRules(form, rules, formValue);
    });
    
    // Apply initial validation
    this.applyConditionalRules(form, rules, form.value);
  }
  
  private applyConditionalRules(form: FormGroup, rules: ValidationRule[], formValue: any): void {
    rules.forEach(rule => {
      const control = form.get(rule.field);
      if (!control) return;
      
      const shouldValidate = rule.condition(formValue);
      
      if (shouldValidate) {
        control.setValidators(rule.validators);
      } else {
        control.clearValidators();
        if (rule.clearWhenInactive) {
          control.setValue('');
        }
      }
      
      control.updateValueAndValidity({ emitEvent: false });
    });
  }
  
  // Helper method to create common conditional validators
  createRequiredIfValidator(conditionField: string, expectedValue: any): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const form = control.parent as FormGroup;
      if (!form) return null;
      
      const conditionControl = form.get(conditionField);
      const shouldBeRequired = conditionControl?.value === expectedValue;
      
      if (shouldBeRequired && (!control.value || control.value.trim() === '')) {
        return { conditionallyRequired: { conditionField, expectedValue } };
      }
      
      return null;
    };
  }
  
  createRequiredIfNotValidator(conditionField: string, excludedValue: any): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const form = control.parent as FormGroup;
      if (!form) return null;
      
      const conditionControl = form.get(conditionField);
      const shouldBeRequired = conditionControl?.value !== excludedValue;
      
      if (shouldBeRequired && (!control.value || control.value.trim() === '')) {
        return { conditionallyRequired: { conditionField, excludedValue } };
      }
      
      return null;
    };
  }
}
```

**3. Complex Multi-Step Form with Conditional Logic:**
```typescript
// multi-step-form.component.ts
interface FormStep {
  id: string;
  title: string;
  fields: string[];
  condition?: (formValue: any) => boolean;
  validationRules?: ValidationRule[];
}

@Component({
  selector: 'app-multi-step-form',
  template: `
    <div class="multi-step-form">
      <!-- Step indicator -->
      <div class="step-indicator">
        <div *ngFor="let step of getVisibleSteps(); let i = index" 
             class="step"
             [class.active]="i === currentStep"
             [class.completed]="i < currentStep">
          {{step.title}}
        </div>
      </div>
      
      <!-- Form content -->
      <form [formGroup]="form">
        <div [ngSwitch]="getCurrentStep()?.id">
          
          <!-- Personal Info Step -->
          <div *ngSwitchCase="'personal'" class="step-content">
            <h3>Personal Information</h3>
            
            <div class="form-group">
              <label>Full Name *</label>
              <input formControlName="fullName" class="form-control" />
              <app-field-errors [control]="form.get('fullName')" fieldName="Full Name"></app-field-errors>
            </div>
            
            <div class="form-group">
              <label>Age *</label>
              <input type="number" formControlName="age" class="form-control" />
              <app-field-errors [control]="form.get('age')" fieldName="Age"></app-field-errors>
            </div>
            
            <div class="form-group">
              <label>Account Type *</label>
              <select formControlName="accountType" class="form-control">
                <option value="personal">Personal</option>
                <option value="business">Business</option>
                <option value="student">Student</option>
              </select>
            </div>
          </div>
          
          <!-- Account Details Step -->
          <div *ngSwitchCase="'account'" class="step-content">
            <h3>Account Details</h3>
            
            <!-- Business-specific fields -->
            <div *ngIf="form.get('accountType')?.value === 'business'">
              <div class="form-group">
                <label>Company Name *</label>
                <input formControlName="companyName" class="form-control" />
                <app-field-errors [control]="form.get('companyName')" fieldName="Company Name"></app-field-errors>
              </div>
              
              <div class="form-group">
                <label>Tax ID *</label>
                <input formControlName="taxId" class="form-control" />
                <app-field-errors [control]="form.get('taxId')" fieldName="Tax ID"></app-field-errors>
              </div>
            </div>
            
            <!-- Student-specific fields -->
            <div *ngIf="form.get('accountType')?.value === 'student'">
              <div class="form-group">
                <label>School Name *</label>
                <input formControlName="schoolName" class="form-control" />
                <app-field-errors [control]="form.get('schoolName')" fieldName="School Name"></app-field-errors>
              </div>
              
              <div class="form-group">
                <label>Student ID *</label>
                <input formControlName="studentId" class="form-control" />
                <app-field-errors [control]="form.get('studentId')" fieldName="Student ID"></app-field-errors>
              </div>
            </div>
            
            <!-- Minor consent (if age < 18) -->
            <div *ngIf="form.get('age')?.value < 18" class="form-group">
              <label>
                <input type="checkbox" formControlName="parentConsent" />
                I have parental consent *
              </label>
              <app-field-errors [control]="form.get('parentConsent')" fieldName="Parental Consent"></app-field-errors>
            </div>
          </div>
          
          <!-- Preferences Step (only for business accounts) -->
          <div *ngSwitchCase="'preferences'" class="step-content">
            <h3>Business Preferences</h3>
            
            <div class="form-group">
              <label>Industry *</label>
              <select formControlName="industry" class="form-control">
                <option value="">Select Industry</option>
                <option value="tech">Technology</option>
                <option value="finance">Finance</option>
                <option value="healthcare">Healthcare</option>
                <option value="retail">Retail</option>
              </select>
              <app-field-errors [control]="form.get('industry')" fieldName="Industry"></app-field-errors>
            </div>
            
            <div class="form-group">
              <label>Company Size *</label>
              <select formControlName="companySize" class="form-control">
                <option value="">Select Size</option>
                <option value="1-10">1-10 employees</option>
                <option value="11-50">11-50 employees</option>
                <option value="51-200">51-200 employees</option>
                <option value="200+">200+ employees</option>
              </select>
              <app-field-errors [control]="form.get('companySize')" fieldName="Company Size"></app-field-errors>
            </div>
          </div>
          
        </div>
      </form>
      
      <!-- Navigation buttons -->
      <div class="form-navigation">
        <button 
          type="button" 
          (click)="previousStep()"
          [disabled]="currentStep === 0"
          class="btn btn-secondary">
          Previous
        </button>
        
        <button 
          type="button" 
          (click)="nextStep()"
          [disabled]="!canProceedToNextStep()"
          class="btn btn-primary"
          *ngIf="!isLastStep()">
          Next
        </button>
        
        <button 
          type="button" 
          (click)="submitForm()"
          [disabled]="!form.valid"
          class="btn btn-success"
          *ngIf="isLastStep()">
          Submit
        </button>
      </div>
      
      <!-- Debug info -->
      <details class="debug-info">
        <summary>Debug Information</summary>
        <pre>Current Step: {{currentStep}}</pre>
        <pre>Visible Steps: {{getVisibleSteps().length}}</pre>
        <pre>Form Valid: {{form.valid}}</pre>
        <pre>Current Step Valid: {{isCurrentStepValid()}}</pre>
        <pre>Form Value: {{form.value | json}}</pre>
      </details>
    </div>
  `
})
export class MultiStepFormComponent implements OnInit {
  currentStep = 0;
  
  form = this.fb.group({
    // Personal info
    fullName: ['', [Validators.required, Validators.minLength(2)]],
    age: ['', [Validators.required, Validators.min(1), Validators.max(120)]],
    accountType: ['personal', Validators.required],
    
    // Conditional fields
    companyName: [''],
    taxId: [''],
    schoolName: [''],
    studentId: [''],
    parentConsent: [false],
    industry: [''],
    companySize: ['']
  });
  
  steps: FormStep[] = [
    {
      id: 'personal',
      title: 'Personal Info',
      fields: ['fullName', 'age', 'accountType']
    },
    {
      id: 'account',
      title: 'Account Details',
      fields: ['companyName', 'taxId', 'schoolName', 'studentId', 'parentConsent']
    },
    {
      id: 'preferences',
      title: 'Preferences',
      fields: ['industry', 'companySize'],
      condition: (formValue) => formValue.accountType === 'business'
    }
  ];
  
  validationRules: ValidationRule[] = [
    {
      field: 'companyName',
      condition: (formValue) => formValue.accountType === 'business',
      validators: [Validators.required, Validators.minLength(2)]
    },
    {
      field: 'taxId',
      condition: (formValue) => formValue.accountType === 'business',
      validators: [Validators.required, Validators.pattern(/^\d{9}$/)]
    },
    {
      field: 'schoolName',
      condition: (formValue) => formValue.accountType === 'student',
      validators: [Validators.required, Validators.minLength(2)]
    },
    {
      field: 'studentId',
      condition: (formValue) => formValue.accountType === 'student',
      validators: [Validators.required, Validators.minLength(3)]
    },
    {
      field: 'parentConsent',
      condition: (formValue) => formValue.age < 18,
      validators: [Validators.requiredTrue]
    },
    {
      field: 'industry',
      condition: (formValue) => formValue.accountType === 'business',
      validators: [Validators.required]
    },
    {
      field: 'companySize',
      condition: (formValue) => formValue.accountType === 'business',
      validators: [Validators.required]
    }
  ];
  
  constructor(
    private fb: FormBuilder,
    private conditionalValidation: ConditionalValidationService
  ) {}
  
  ngOnInit(): void {
    this.conditionalValidation.setupConditionalValidation(this.form, this.validationRules);
  }
  
  getVisibleSteps(): FormStep[] {
    return this.steps.filter(step => 
      !step.condition || step.condition(this.form.value)
    );
  }
  
  getCurrentStep(): FormStep | undefined {
    const visibleSteps = this.getVisibleSteps();
    return visibleSteps[this.currentStep];
  }
  
  isCurrentStepValid(): boolean {
    const currentStep = this.getCurrentStep();
    if (!currentStep) return false;
    
    return currentStep.fields.every(fieldName => {
      const control = this.form.get(fieldName);
      const rule = this.validationRules.find(r => r.field === fieldName);
      
      // If field has conditional validation, check if condition is met
      if (rule && !rule.condition(this.form.value)) {
        return true; // Field is not required in current context
      }
      
      return control?.valid ?? true;
    });
  }
  
  canProceedToNextStep(): boolean {
    return this.isCurrentStepValid();
  }
  
  isLastStep(): boolean {
    const visibleSteps = this.getVisibleSteps();
    return this.currentStep === visibleSteps.length - 1;
  }
  
  nextStep(): void {
    if (this.canProceedToNextStep() && !this.isLastStep()) {
      this.currentStep++;
    }
  }
  
  previousStep(): void {
    if (this.currentStep > 0) {
      this.currentStep--;
    }
  }
  
  submitForm(): void {
    if (this.form.valid) {
      console.log('Form submitted:', this.form.value);
      // Handle form submission
    } else {
      console.log('Form is invalid');
      this.markAllFieldsAsTouched();
    }
  }
  
  private markAllFieldsAsTouched(): void {
    Object.keys(this.form.controls).forEach(key => {
      this.form.get(key)?.markAsTouched();
    });
  }
}
```

**Best Practices:**
- Use reactive approaches with `valueChanges` for dynamic validation
- Clear validators when conditions are not met
- Always call `updateValueAndValidity()` after changing validators
- Create reusable conditional validation services
- Provide clear visual feedback for conditional fields
- Test all conditional paths thoroughly
- Document complex conditional logic
- Consider performance implications of frequent validation updates

[Back to Forms and Validation](#forms-and-validation)

### 78. What are form states (pristine, dirty, valid, invalid)?

**Answer:**
Angular forms have multiple state properties that help track user interaction and validation status. Understanding these states is crucial for creating responsive and user-friendly forms.

**Form State Properties:**

**1. Core State Properties:**
```typescript
// form-states.component.ts
export class FormStatesComponent {
  form = this.fb.group({
    username: ['', [Validators.required, Validators.minLength(3)]],
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, Validators.minLength(8)]]
  });
  
  constructor(private fb: FormBuilder) {}
  
  // Check various form states
  getFormStates() {
    return {
      // Interaction states
      pristine: this.form.pristine,    // No user interaction
      dirty: this.form.dirty,          // User has interacted
      touched: this.form.touched,      // Field has been focused/blurred
      untouched: this.form.untouched,  // Field has never been focused
      
      // Validation states
      valid: this.form.valid,          // All validations pass
      invalid: this.form.invalid,      // At least one validation fails
      pending: this.form.pending,      // Async validation in progress
      
      // Status string
      status: this.form.status,        // 'VALID', 'INVALID', 'PENDING', 'DISABLED'
      
      // Enabled/disabled state
      enabled: this.form.enabled,
      disabled: this.form.disabled
    };
  }
  
  // Check individual field states
  getFieldStates(fieldName: string) {
    const field = this.form.get(fieldName);
    return {
      pristine: field?.pristine,
      dirty: field?.dirty,
      touched: field?.touched,
      untouched: field?.untouched,
      valid: field?.valid,
      invalid: field?.invalid,
      pending: field?.pending,
      status: field?.status,
      enabled: field?.enabled,
      disabled: field?.disabled,
      errors: field?.errors
    };
  }
}
```

**2. State Tracking Template:**
```html
<!-- form-states.component.html -->
<form [formGroup]="form">
  <!-- Form state indicator -->
  <div class="form-status-panel">
    <h3>Form States</h3>
    <div class="state-grid">
      <div class="state-item" [class.active]="form.pristine">
        <span class="state-label">Pristine:</span>
        <span class="state-value">{{form.pristine}}</span>
      </div>
      <div class="state-item" [class.active]="form.dirty">
        <span class="state-label">Dirty:</span>
        <span class="state-value">{{form.dirty}}</span>
      </div>
      <div class="state-item" [class.active]="form.touched">
        <span class="state-label">Touched:</span>
        <span class="state-value">{{form.touched}}</span>
      </div>
      <div class="state-item" [class.active]="form.valid">
        <span class="state-label">Valid:</span>
        <span class="state-value">{{form.valid}}</span>
      </div>
      <div class="state-item" [class.active]="form.pending">
        <span class="state-label">Pending:</span>
        <span class="state-value">{{form.pending}}</span>
      </div>
    </div>
  </div>
  
  <!-- Form fields with state-based styling -->
  <div class="form-group">
    <label for="username">Username</label>
    <input 
      id="username"
      type="text" 
      formControlName="username"
      class="form-control"
      [class.pristine]="form.get('username')?.pristine"
      [class.dirty]="form.get('username')?.dirty"
      [class.valid]="form.get('username')?.valid && form.get('username')?.touched"
      [class.invalid]="form.get('username')?.invalid && form.get('username')?.touched" />
    
    <!-- Field state display -->
    <div class="field-states">
      <small>States: 
        <span *ngIf="form.get('username')?.pristine" class="badge badge-info">pristine</span>
        <span *ngIf="form.get('username')?.dirty" class="badge badge-warning">dirty</span>
        <span *ngIf="form.get('username')?.touched" class="badge badge-secondary">touched</span>
        <span *ngIf="form.get('username')?.valid" class="badge badge-success">valid</span>
        <span *ngIf="form.get('username')?.invalid" class="badge badge-danger">invalid</span>
      </small>
    </div>
    
    <!-- Conditional error display -->
    <div *ngIf="form.get('username')?.invalid && form.get('username')?.touched" class="field-errors">
      <div *ngIf="form.get('username')?.errors?.['required']">Username is required</div>
      <div *ngIf="form.get('username')?.errors?.['minlength']">Username must be at least 3 characters</div>
    </div>
  </div>
  
  <!-- Submit button with state-based behavior -->
  <button 
    type="submit" 
    [disabled]="form.invalid || form.pending"
    class="btn"
    [class.btn-success]="form.valid"
    [class.btn-secondary]="form.invalid">
    
    <span *ngIf="form.pending">Validating...</span>
    <span *ngIf="!form.pending">Submit</span>
  </button>
  
  <!-- Reset button -->
  <button 
    type="button" 
    (click)="resetForm()"
    [disabled]="form.pristine"
    class="btn btn-outline-secondary">
    Reset
  </button>
</form>
```

**3. Advanced State Management Service:**
```typescript
// form-state.service.ts
@Injectable({ providedIn: 'root' })
export class FormStateService {
  
  // Track form state changes
  trackFormStateChanges(form: FormGroup): Observable<any> {
    return merge(
      form.statusChanges,
      form.valueChanges
    ).pipe(
      map(() => this.getFormStateSnapshot(form)),
      distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr))
    );
  }
  
  getFormStateSnapshot(form: FormGroup) {
    return {
      timestamp: new Date(),
      states: {
        pristine: form.pristine,
        dirty: form.dirty,
        touched: form.touched,
        valid: form.valid,
        pending: form.pending,
        status: form.status
      },
      fieldStates: this.getAllFieldStates(form),
      errors: this.getAllErrors(form),
      value: form.value
    };
  }
  
  private getAllFieldStates(form: FormGroup): any {
    const fieldStates: any = {};
    
    Object.keys(form.controls).forEach(key => {
      const control = form.get(key);
      if (control) {
        fieldStates[key] = {
          pristine: control.pristine,
          dirty: control.dirty,
          touched: control.touched,
          valid: control.valid,
          invalid: control.invalid,
          pending: control.pending,
          status: control.status
        };
      }
    });
    
    return fieldStates;
  }
  
  private getAllErrors(form: FormGroup): any {
    const errors: any = {};
    
    Object.keys(form.controls).forEach(key => {
      const control = form.get(key);
      if (control?.errors) {
        errors[key] = control.errors;
      }
    });
    
    return errors;
  }
  
  // Check if form should show validation errors
  shouldShowErrors(control: AbstractControl): boolean {
    return !!(control.invalid && (control.dirty || control.touched));
  }
  
  // Check if form is ready for submission
  isSubmissionReady(form: FormGroup): boolean {
    return form.valid && !form.pending && form.dirty;
  }
  
  // Get user-friendly status message
  getStatusMessage(form: FormGroup): string {
    if (form.pending) {
      return 'Validating form...';
    }
    if (form.invalid && form.touched) {
      return 'Please fix the errors below';
    }
    if (form.valid && form.dirty) {
      return 'Form is ready to submit';
    }
    if (form.pristine) {
      return 'Please fill out the form';
    }
    return 'Form status unknown';
  }
}
```

**4. State-Based Validation Strategy:**
```typescript
// smart-validation.component.ts
@Component({
  selector: 'app-smart-validation',
  template: `
    <form [formGroup]="form" (ngSubmit)="onSubmit()">
      <div *ngFor="let field of formFields" class="form-group">
        <label [for]="field.name">{{field.label}}</label>
        
        <input 
          [id]="field.name"
          [type]="field.type"
          [formControlName]="field.name"
          class="form-control"
          [class.is-invalid]="shouldShowFieldError(field.name)"
          [class.is-valid]="shouldShowFieldSuccess(field.name)"
          (blur)="onFieldBlur(field.name)"
          (focus)="onFieldFocus(field.name)" />
        
        <!-- Smart error display based on interaction -->
        <div *ngIf="shouldShowFieldError(field.name)" class="invalid-feedback">
          {{getFieldErrorMessage(field.name)}}
        </div>
        
        <!-- Success indicator -->
        <div *ngIf="shouldShowFieldSuccess(field.name)" class="valid-feedback">
          ✓ Looks good!
        </div>
        
        <!-- Field interaction hints -->
        <div *ngIf="getFieldHint(field.name)" class="form-hint">
          {{getFieldHint(field.name)}}
        </div>
      </div>
      
      <!-- Smart submit button -->
      <button 
        type="submit"
        class="btn"
        [class.btn-primary]="canSubmit()"
        [class.btn-secondary]="!canSubmit()"
        [disabled]="!canSubmit()">
        
        <span *ngIf="form.pending">Validating...</span>
        <span *ngIf="!form.pending && form.pristine">Fill form to enable</span>
        <span *ngIf="!form.pending && form.dirty && form.invalid">Fix errors to submit</span>
        <span *ngIf="!form.pending && form.valid">Submit Form</span>
      </button>
    </form>
  `
})
export class SmartValidationComponent {
  form = this.fb.group({
    name: ['', [Validators.required, Validators.minLength(2)]],
    email: ['', [Validators.required, Validators.email]],
    phone: ['', [Validators.required, Validators.pattern(/^\d{10}$/)]]
  });
  
  formFields = [
    { name: 'name', label: 'Full Name', type: 'text' },
    { name: 'email', label: 'Email Address', type: 'email' },
    { name: 'phone', label: 'Phone Number', type: 'tel' }
  ];
  
  private fieldInteractionState = new Map<string, { focused: boolean; blurred: boolean }>();
  
  constructor(
    private fb: FormBuilder,
    private formStateService: FormStateService
  ) {
    // Initialize interaction tracking
    this.formFields.forEach(field => {
      this.fieldInteractionState.set(field.name, { focused: false, blurred: false });
    });
  }
  
  shouldShowFieldError(fieldName: string): boolean {
    const control = this.form.get(fieldName);
    const interaction = this.fieldInteractionState.get(fieldName);
    
    if (!control || !interaction) return false;
    
    // Show errors after field has been blurred or form submission attempted
    return control.invalid && (interaction.blurred || this.form.touched);
  }
  
  shouldShowFieldSuccess(fieldName: string): boolean {
    const control = this.form.get(fieldName);
    const interaction = this.fieldInteractionState.get(fieldName);
    
    if (!control || !interaction) return false;
    
    // Show success after field has been interacted with and is valid
    return control.valid && (interaction.blurred || control.dirty);
  }
  
  getFieldErrorMessage(fieldName: string): string {
    const control = this.form.get(fieldName);
    if (!control?.errors) return '';
    
    const errors = control.errors;
    if (errors['required']) return `${this.getFieldLabel(fieldName)} is required`;
    if (errors['email']) return 'Please enter a valid email address';
    if (errors['minlength']) return `Minimum ${errors['minlength'].requiredLength} characters required`;
    if (errors['pattern']) return 'Please enter a valid format';
    
    return 'Invalid input';
  }
  
  getFieldHint(fieldName: string): string | null {
    const control = this.form.get(fieldName);
    const interaction = this.fieldInteractionState.get(fieldName);
    
    if (!control || !interaction) return null;
    
    // Show hints when field is focused but not yet valid
    if (interaction.focused && !control.valid && !interaction.blurred) {
      switch (fieldName) {
        case 'name': return 'Enter your full name (minimum 2 characters)';
        case 'email': return 'Enter a valid email address';
        case 'phone': return 'Enter 10-digit phone number';
        default: return null;
      }
    }
    
    return null;
  }
  
  onFieldFocus(fieldName: string): void {
    const interaction = this.fieldInteractionState.get(fieldName);
    if (interaction) {
      interaction.focused = true;
    }
  }
  
  onFieldBlur(fieldName: string): void {
    const interaction = this.fieldInteractionState.get(fieldName);
    if (interaction) {
      interaction.focused = false;
      interaction.blurred = true;
    }
  }
  
  canSubmit(): boolean {
    return this.formStateService.isSubmissionReady(this.form);
  }
  
  onSubmit(): void {
    if (this.form.valid) {
      console.log('Form submitted:', this.form.value);
    } else {
      // Mark all fields as touched to show errors
      this.markAllFieldsAsTouched();
    }
  }
  
  private getFieldLabel(fieldName: string): string {
    const field = this.formFields.find(f => f.name === fieldName);
    return field?.label || fieldName;
  }
  
  private markAllFieldsAsTouched(): void {
    Object.keys(this.form.controls).forEach(key => {
      this.form.get(key)?.markAsTouched();
      const interaction = this.fieldInteractionState.get(key);
      if (interaction) {
        interaction.blurred = true;
      }
    });
  }
}
```

**State Definitions:**

| State | Description | When It Changes |
|-------|-------------|----------------|
| **pristine** | Form/field hasn't been modified | Changes to `false` when user modifies any value |
| **dirty** | Form/field has been modified | Opposite of pristine |
| **touched** | Field has been focused and blurred | Changes to `true` after blur event |
| **untouched** | Field has never been focused | Opposite of touched |
| **valid** | All validations pass | Changes based on validation results |
| **invalid** | At least one validation fails | Opposite of valid |
| **pending** | Async validation in progress | During async validator execution |
| **disabled** | Form/field is disabled | When `disable()` is called |
| **enabled** | Form/field is enabled | When `enable()` is called |

**Best Practices:**
- Show validation errors only after user interaction (touched/dirty)
- Use pending state to show loading indicators during async validation
- Provide immediate feedback for successful validation
- Use state-based styling for better user experience
- Track form state changes for analytics and debugging
- Implement smart validation strategies based on user behavior

[Back to Forms and Validation](#forms-and-validation)

### 79. How do you reset forms properly?

**Answer:**
Properly resetting forms involves more than just clearing values - it requires resetting validation states, user interaction flags, and handling different reset scenarios based on your application's needs.

**Basic Form Reset Methods:**

**1. Complete Form Reset:**
```typescript
// basic-reset.component.ts
export class BasicResetComponent {
  form = this.fb.group({
    name: ['', Validators.required],
    email: ['', [Validators.required, Validators.email]],
    age: ['', [Validators.required, Validators.min(18)]]
  });
  
  constructor(private fb: FormBuilder) {}
  
  // Method 1: Reset to initial state (empty)
  resetToEmpty(): void {
    this.form.reset();
    // This resets:
    // - All values to null
    // - pristine: true, dirty: false
    // - touched: false, untouched: true
    // - Clears all validation errors
  }
  
  // Method 2: Reset to specific values
  resetToDefaults(): void {
    this.form.reset({
      name: 'John Doe',
      email: 'john@example.com',
      age: 25
    });
  }
  
  // Method 3: Reset only values, keep states
  resetValuesOnly(): void {
    this.form.patchValue({
      name: '',
      email: '',
      age: ''
    });
    // This keeps touched/dirty states
  }
  
  // Method 4: Reset specific fields
  resetField(fieldName: string): void {
    const control = this.form.get(fieldName);
    if (control) {
      control.reset();
    }
  }
}
```

**2. Advanced Reset Strategies:**
```typescript
// advanced-reset.service.ts
@Injectable({ providedIn: 'root' })
export class FormResetService {
  
  // Store original form configuration
  private originalConfigs = new Map<FormGroup, any>();
  
  // Register form for advanced reset capabilities
  registerForm(form: FormGroup, config: any): void {
    this.originalConfigs.set(form, {
      initialValue: form.value,
      validators: this.extractValidators(form),
      ...config
    });
  }
  
  // Reset to original state
  resetToOriginal(form: FormGroup): void {
    const config = this.originalConfigs.get(form);
    if (config) {
      form.reset(config.initialValue);
      this.restoreValidators(form, config.validators);
    }
  }
  
  // Selective reset - reset only dirty fields
  resetDirtyFields(form: FormGroup): void {
    const config = this.originalConfigs.get(form);
    if (!config) return;
    
    Object.keys(form.controls).forEach(key => {
      const control = form.get(key);
      if (control?.dirty) {
        const originalValue = config.initialValue[key];
        control.reset(originalValue);
      }
    });
  }
  
  // Reset with confirmation
  resetWithConfirmation(form: FormGroup, message?: string): Promise<boolean> {
    return new Promise((resolve) => {
      if (form.dirty) {
        const confirmed = confirm(message || 'Are you sure you want to reset the form? All changes will be lost.');
        if (confirmed) {
          this.resetToOriginal(form);
          resolve(true);
        } else {
          resolve(false);
        }
      } else {
        resolve(true); // No changes to lose
      }
    });
  }
  
  // Smart reset - reset invalid fields to last valid state
  resetInvalidFields(form: FormGroup): void {
    const config = this.originalConfigs.get(form);
    if (!config) return;
    
    Object.keys(form.controls).forEach(key => {
      const control = form.get(key);
      if (control?.invalid) {
        const originalValue = config.initialValue[key];
        control.reset(originalValue);
      }
    });
  }
  
  // Partial reset - reset specific fields
  resetFields(form: FormGroup, fieldNames: string[]): void {
    const config = this.originalConfigs.get(form);
    if (!config) return;
    
    fieldNames.forEach(fieldName => {
      const control = form.get(fieldName);
      if (control) {
        const originalValue = config.initialValue[fieldName];
        control.reset(originalValue);
      }
    });
  }
  
  private (form: FormGroup): any {
    const validators: any = {};
    Object.keys(form.controls).forEach(key => {
      const control = form.get(key);
      if (control) {
        validators[key] = {
          sync: control.validator,
          async: control.asyncValidator
        };
      }
    });
    return validators;
  }
  
  private restoreValidators(form: FormGroup, validators: any): void {
    Object.keys(validators).forEach(key => {
      const control = form.get(key);
      if (control && validators[key]) {
        if (validators[key].sync) {
          control.setValidators(validators[key].sync);
        }
        if (validators[key].async) {
          control.setAsyncValidators(validators[key].async);
        }
        control.updateValueAndValidity();
      }
    });
  }
}
```

**3. Dynamic Form Reset:**
```typescript
// dynamic-form-reset.component.ts
@Component({
  selector: 'app-dynamic-form-reset',
  template: `
    <form [formGroup]="form">
      <!-- Dynamic fields -->
      <div formArrayName="skills">
        <div *ngFor="let skill of skillsArray.controls; let i = index" 
             [formGroupName]="i" class="skill-group">
          <input formControlName="name" placeholder="Skill name" />
          <input formControlName="level" placeholder="Level" />
          <button type="button" (click)="removeSkill(i)">Remove</button>
        </div>
      </div>
      
      <button type="button" (click)="addSkill()">Add Skill</button>
      
      <!-- Reset options -->
      <div class="reset-options">
        <button type="button" (click)="resetForm()">Reset All</button>
        <button type="button" (click)="resetToDefaults()">Reset to Defaults</button>
        <button type="button" (click)="resetSkills()">Reset Skills Only</button>
        <button type="button" (click)="clearNewSkills()">Clear New Skills</button>
      </div>
    </form>
  `
})
export class DynamicFormResetComponent implements OnInit {
  form: FormGroup;
  private originalSkillsCount = 0;
  
  constructor(
    private fb: FormBuilder,
    private resetService: FormResetService
  ) {
    this.form = this.fb.group({
      name: ['John Doe', Validators.required],
      email: ['john@example.com', [Validators.required, Validators.email]],
      skills: this.fb.array([
        this.createSkillGroup('JavaScript', 'Advanced'),
        this.createSkillGroup('Angular', 'Expert')
      ])
    });
    
    this.originalSkillsCount = this.skillsArray.length;
  }
  
  ngOnInit(): void {
    // Register form with reset service
    this.resetService.registerForm(this.form, {
      originalSkillsCount: this.originalSkillsCount
    });
  }
  
  get skillsArray(): FormArray {
    return this.form.get('skills') as FormArray;
  }
  
  createSkillGroup(name = '', level = ''): FormGroup {
    return this.fb.group({
      name: [name, Validators.required],
      level: [level, Validators.required]
    });
  }
  
  addSkill(): void {
    this.skillsArray.push(this.createSkillGroup());
  }
  
  removeSkill(index: number): void {
    this.skillsArray.removeAt(index);
  }
  
  // Complete form reset
  resetForm(): void {
    this.resetService.resetToOriginal(this.form);
    this.resetSkillsArray();
  }
  
  // Reset to default values
  resetToDefaults(): void {
    this.form.reset({
      name: 'John Doe',
      email: 'john@example.com',
      skills: [
        { name: 'JavaScript', level: 'Advanced' },
        { name: 'Angular', level: 'Expert' }
      ]
    });
    this.resetSkillsArray();
  }
  
  // Reset only skills
  resetSkills(): void {
    this.resetSkillsArray();
  }
  
  // Clear skills added after original
  clearNewSkills(): void {
    while (this.skillsArray.length > this.originalSkillsCount) {
      this.skillsArray.removeAt(this.skillsArray.length - 1);
    }
  }
  
  private resetSkillsArray(): void {
    // Clear all skills
    while (this.skillsArray.length > 0) {
      this.skillsArray.removeAt(0);
    }
    
    // Add original skills back
    this.skillsArray.push(this.createSkillGroup('JavaScript', 'Advanced'));
    this.skillsArray.push(this.createSkillGroup('Angular', 'Expert'));
  }
}
```

**4. Reset with State Management:**
```typescript
// stateful-form-reset.component.ts
interface FormSnapshot {
  value: any;
  states: {
    pristine: boolean;
    dirty: boolean;
    touched: boolean;
    valid: boolean;
  };
  timestamp: Date;
}

@Component({
  selector: 'app-stateful-form-reset',
  template: `
    <form [formGroup]="form">
      <!-- Form fields -->
      <input formControlName="name" placeholder="Name" />
      <input formControlName="email" placeholder="Email" />
      
      <!-- Reset controls -->
      <div class="reset-controls">
        <button type="button" (click)="saveSnapshot()">Save Current State</button>
        <button type="button" (click)="resetToSnapshot()" [disabled]="!hasSnapshot()">Reset to Saved</button>
        <button type="button" (click)="resetToInitial()">Reset to Initial</button>
        <button type="button" (click)="resetWithHistory()">Reset with Undo</button>
      </div>
      
      <!-- History -->
      <div class="reset-history">
        <h4>Reset History</h4>
        <div *ngFor="let entry of resetHistory; let i = index" class="history-entry">
          <span>{{entry.timestamp | date:'short'}}</span>
          <button type="button" (click)="restoreFromHistory(i)">Restore</button>
        </div>
      </div>
    </form>
  `
})
export class StatefulFormResetComponent {
  form = this.fb.group({
    name: ['', Validators.required],
    email: ['', [Validators.required, Validators.email]]
  });
  
  private initialSnapshot: FormSnapshot;
  private savedSnapshot: FormSnapshot | null = null;
  resetHistory: FormSnapshot[] = [];
  
  constructor(private fb: FormBuilder) {
    // Save initial state
    this.initialSnapshot = this.createSnapshot();
  }
  
  saveSnapshot(): void {
    this.savedSnapshot = this.createSnapshot();
  }
  
  hasSnapshot(): boolean {
    return this.savedSnapshot !== null;
  }
  
  resetToSnapshot(): void {
    if (this.savedSnapshot) {
      this.restoreSnapshot(this.savedSnapshot);
      this.addToHistory(this.savedSnapshot);
    }
  }
  
  resetToInitial(): void {
    this.restoreSnapshot(this.initialSnapshot);
    this.addToHistory(this.initialSnapshot);
  }
  
  resetWithHistory(): void {
    // Save current state to history before reset
    this.addToHistory(this.createSnapshot());
    this.resetToInitial();
  }
  
  restoreFromHistory(index: number): void {
    const snapshot = this.resetHistory[index];
    if (snapshot) {
      this.restoreSnapshot(snapshot);
    }
  }
  
  private createSnapshot(): FormSnapshot {
    return {
      value: this.form.value,
      states: {
        pristine: this.form.pristine,
        dirty: this.form.dirty,
        touched: this.form.touched,
        valid: this.form.valid
      },
      timestamp: new Date()
    };
  }
  
  private restoreSnapshot(snapshot: FormSnapshot): void {
    // Reset form to snapshot values
    this.form.reset(snapshot.value);
    
    // Note: Form states (pristine, dirty, touched) are automatically
    // set by reset(), but we could manually set them if needed
  }
  
  private addToHistory(snapshot: FormSnapshot): void {
    this.resetHistory.unshift(snapshot);
    
    // Limit history size
    if (this.resetHistory.length > 10) {
      this.resetHistory = this.resetHistory.slice(0, 10);
    }
  }
}
```

**5. Reset with Animations:**
```typescript
// animated-reset.component.ts
@Component({
  selector: 'app-animated-reset',
  template: `
    <form [formGroup]="form" [@formState]="formAnimationState">
      <input formControlName="name" placeholder="Name" />
      <input formControlName="email" placeholder="Email" />
      
      <button type="button" (click)="animatedReset()" [disabled]="isResetting">
        {{isResetting ? 'Resetting...' : 'Reset Form'}}
      </button>
    </form>
  `,
  animations: [
    trigger('formState', [
      state('normal', style({ opacity: 1, transform: 'scale(1)' })),
      state('resetting', style({ opacity: 0.5, transform: 'scale(0.95)' })),
      transition('normal => resetting', animate('200ms ease-out')),
      transition('resetting => normal', animate('300ms ease-in'))
    ])
  ]
})
export class AnimatedResetComponent {
  form = this.fb.group({
    name: ['', Validators.required],
    email: ['', Validators.required]
  });
  
  formAnimationState = 'normal';
  isResetting = false;
  
  constructor(private fb: FormBuilder) {}
  
  async animatedReset(): Promise<void> {
    this.isResetting = true;
    this.formAnimationState = 'resetting';
    
    // Wait for animation
    await this.delay(200);
    
    // Reset form
    this.form.reset();
    
    // Return to normal state
    this.formAnimationState = 'normal';
    await this.delay(300);
    
    this.isResetting = false;
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

**Reset Scenarios Comparison:**

| Method | Values | States | Use Case |
|--------|--------|--------|---------|
| `form.reset()` | Clears to null | Resets all | Complete reset |
| `form.reset(value)` | Sets to value | Resets all | Reset to defaults |
| `form.patchValue()` | Updates values | Keeps states | Value-only reset |
| `control.reset()` | Resets single field | Resets field states | Field-specific reset |

**Best Practices:**
- Always consider user experience when resetting forms
- Provide confirmation for destructive resets
- Save form state before major resets
- Use appropriate reset method based on requirements
- Consider animations for better UX
- Handle dynamic form structures properly
- Test reset functionality thoroughly

[Back to Forms and Validation](#forms-and-validation)

### 80. What is the difference between `setValue` and `patchValue`?

**Answer:**
`setValue` and `patchValue` are two methods for updating form values in Angular reactive forms, but they have different behaviors and use cases. Understanding their differences is crucial for proper form management.

**Key Differences:**

| Aspect | `setValue` | `patchValue` |
|--------|------------|-------------|
| **Completeness** | Must provide ALL form fields | Can provide PARTIAL form fields |
| **Validation** | Strict - throws error if fields missing | Flexible - ignores missing fields |
| **Use Case** | Complete form replacement | Partial form updates |
| **Safety** | Type-safe, catches missing fields | Permissive, allows incomplete data |

**Basic Examples:**

**1. setValue - Complete Replacement:**
```typescript
// set-value-example.component.ts
export class SetValueExampleComponent {
  form = this.fb.group({
    firstName: ['', Validators.required],
    lastName: ['', Validators.required],
    email: ['', [Validators.required, Validators.email]],
    phone: ['', Validators.required],
    address: this.fb.group({
      street: [''],
      city: [''],
      zipCode: ['']
    })
  });
  
  constructor(private fb: FormBuilder) {}
  
  // ✅ Correct usage - all fields provided
  setCompleteUser(): void {
    this.form.setValue({
      firstName: 'John',
      lastName: 'Doe',
      email: 'john.doe@example.com',
      phone: '123-456-7890',
      address: {
        street: '123 Main St',
        city: 'Anytown',
        zipCode: '12345'
      }
    });
  }
  
  // ❌ This will throw an error - missing fields
  setIncompleteUser(): void {
    try {
      this.form.setValue({
        firstName: 'John',
        email: 'john@example.com'
        // Missing: lastName, phone, address
      });
    } catch (error) {
      console.error('setValue error:', error);
      // Error: Must supply a value for form control with name: 'lastName'
    }
  }
  
  // ✅ Loading user data from API
  loadUserData(userId: number): void {
    this.userService.getUser(userId).subscribe(user => {
      // setValue ensures we have all required fields
      this.form.setValue({
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        email: user.email || '',
        phone: user.phone || '',
        address: {
          street: user.address?.street || '',
          city: user.address?.city || '',
          zipCode: user.address?.zipCode || ''
        }
      });
    });
  }
}
```

**2. patchValue - Partial Updates:**
```typescript
// patch-value-example.component.ts
export class PatchValueExampleComponent {
  form = this.fb.group({
    firstName: ['', Validators.required],
    lastName: ['', Validators.required],
    email: ['', [Validators.required, Validators.email]],
    phone: ['', Validators.required],
    preferences: this.fb.group({
      newsletter: [false],
      notifications: [true],
      theme: ['light']
    }),
    address: this.fb.group({
      street: [''],
      city: [''],
      zipCode: ['']
    })
  });
  
  constructor(private fb: FormBuilder) {}
  
  // ✅ Update only specific fields
  updateContactInfo(): void {
    this.form.patchValue({
      email: 'newemail@example.com',
      phone: '987-654-3210'
      // Other fields remain unchanged
    });
  }
  
  // ✅ Update nested form groups partially
  updatePreferences(): void {
    this.form.patchValue({
      preferences: {
        newsletter: true,
        theme: 'dark'
        // notifications field remains unchanged
      }
    });
  }
  
  // ✅ Update from user input
  onEmailChange(newEmail: string): void {
    this.form.patchValue({ email: newEmail });
  }
  
  // ✅ Partial update from API response
  updateFromPartialData(partialData: any): void {
    // Only updates fields that exist in partialData
    this.form.patchValue(partialData);
  }
  
  // ✅ Safe update with unknown structure
  safeUpdate(data: any): void {
    // patchValue won't throw errors for extra or missing fields
    this.form.patchValue({
      firstName: data.first_name,  // Different property names
      lastName: data.last_name,
      email: data.email_address,
      unknownField: data.someValue  // This will be ignored silently
    });
  }
}
```

**Advanced Usage Patterns:**

**1. Dynamic Form Updates:**
```typescript
// dynamic-form-updates.component.ts
export class DynamicFormUpdatesComponent {
  form = this.fb.group({
    userType: ['individual'],
    firstName: [''],
    lastName: [''],
    companyName: [''],
    taxId: [''],
    personalId: ['']
  });
  
  constructor(private fb: FormBuilder) {
    this.setupUserTypeWatcher();
  }
  
  private setupUserTypeWatcher(): void {
    this.form.get('userType')?.valueChanges.subscribe(userType => {
      if (userType === 'business') {
        // Clear personal fields, set business defaults
        this.form.patchValue({
          personalId: '',
          companyName: 'New Company',
          taxId: ''
        });
      } else {
        // Clear business fields
        this.form.patchValue({
          companyName: '',
          taxId: '',
          personalId: ''
        });
      }
    });
  }
  
  // Load different data types
  loadIndividualData(data: any): void {
    this.form.setValue({
      userType: 'individual',
      firstName: data.firstName,
      lastName: data.lastName,
      companyName: '',  // Must provide even if empty
      taxId: '',
      personalId: data.personalId
    });
  }
  
  loadBusinessData(data: any): void {
    this.form.setValue({
      userType: 'business',
      firstName: data.contactFirstName,
      lastName: data.contactLastName,
      companyName: data.companyName,
      taxId: data.taxId,
      personalId: ''  // Must provide even if empty
    });
  }
}
```

**2. Form Synchronization:**
```typescript
// form-sync.service.ts
@Injectable({ providedIn: 'root' })
export class FormSyncService {
  
  // Sync two forms - complete synchronization
  syncFormsCompletely(sourceForm: FormGroup, targetForm: FormGroup): void {
    sourceForm.valueChanges.subscribe(value => {
      try {
        targetForm.setValue(value, { emitEvent: false });
      } catch (error) {
        console.warn('Forms have different structures, using patchValue instead');
        targetForm.patchValue(value, { emitEvent: false });
      }
    });
  }
  
  // Sync forms partially - only common fields
  syncFormsPartially(sourceForm: FormGroup, targetForm: FormGroup, fields: string[]): void {
    sourceForm.valueChanges.subscribe(value => {
      const partialValue: any = {};
      fields.forEach(field => {
        if (value.hasOwnProperty(field)) {
          partialValue[field] = value[field];
        }
      });
      targetForm.patchValue(partialValue, { emitEvent: false });
    });
  }
  
  // Smart sync - handles structure differences
  smartSync(sourceForm: FormGroup, targetForm: FormGroup, fieldMapping: {[key: string]: string}): void {
    sourceForm.valueChanges.subscribe(sourceValue => {
      const mappedValue: any = {};
      
      Object.keys(fieldMapping).forEach(sourceField => {
        const targetField = fieldMapping[sourceField];
        if (sourceValue.hasOwnProperty(sourceField)) {
          mappedValue[targetField] = sourceValue[sourceField];
        }
      });
      
      targetForm.patchValue(mappedValue, { emitEvent: false });
    });
  }
}
```

**3. Batch Updates with Validation:**
```typescript
// batch-updates.component.ts
export class BatchUpdatesComponent {
  form = this.fb.group({
    profile: this.fb.group({
      firstName: ['', Validators.required],
      lastName: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]]
    }),
    settings: this.fb.group({
      theme: ['light'],
      language: ['en'],
      notifications: [true]
    }),
    preferences: this.fb.group({
      newsletter: [false],
      marketing: [false]
    })
  });
  
  constructor(private fb: FormBuilder) {}
  
  // Batch update with validation
  batchUpdateWithValidation(updates: any[]): void {
    updates.forEach(update => {
      try {
        if (update.complete) {
          // Use setValue for complete updates
          this.form.get(update.section)?.setValue(update.data);
        } else {
          // Use patchValue for partial updates
          this.form.get(update.section)?.patchValue(update.data);
        }
      } catch (error) {
        console.error(`Failed to update ${update.section}:`, error);
        // Fallback to patchValue
        this.form.get(update.section)?.patchValue(update.data);
      }
    });
  }
  
  // Safe batch update
  safeBatchUpdate(data: any): void {
    // Update profile completely if all fields present
    if (this.hasAllProfileFields(data.profile)) {
      this.form.get('profile')?.setValue(data.profile);
    } else if (data.profile) {
      this.form.get('profile')?.patchValue(data.profile);
    }
    
    // Always use patchValue for settings (optional fields)
    if (data.settings) {
      this.form.get('settings')?.patchValue(data.settings);
    }
    
    if (data.preferences) {
      this.form.get('preferences')?.patchValue(data.preferences);
    }
  }
  
  private hasAllProfileFields(profile: any): boolean {
    return profile && 
           profile.hasOwnProperty('firstName') &&
           profile.hasOwnProperty('lastName') &&
           profile.hasOwnProperty('email');
  }
  
  // Update with options
  updateWithOptions(data: any, options: { emitEvent?: boolean; onlySelf?: boolean } = {}): void {
    const updateOptions = {
      emitEvent: options.emitEvent ?? true,
      onlySelf: options.onlySelf ?? false
    };
    
    // Both setValue and patchValue accept options
    this.form.patchValue(data, updateOptions);
  }
}
```

**4. Form State Management:**
```typescript
// form-state-manager.service.ts
@Injectable({ providedIn: 'root' })
export class FormStateManagerService {
  
  // Save form state
  saveFormState(formName: string, form: FormGroup): void {
    const state = {
      value: form.value,
      timestamp: new Date().toISOString()
    };
    localStorage.setItem(`form_${formName}`, JSON.stringify(state));
  }
  
  // Restore form state
  restoreFormState(formName: string, form: FormGroup, useSetValue = false): boolean {
    const savedState = localStorage.getItem(`form_${formName}`);
    if (!savedState) return false;
    
    try {
      const state = JSON.parse(savedState);
      
      if (useSetValue) {
        // Strict restoration - all fields must match
        form.setValue(state.value);
      } else {
        // Flexible restoration - only restore existing fields
        form.patchValue(state.value);
      }
      
      return true;
    } catch (error) {
      console.error('Failed to restore form state:', error);
      return false;
    }
  }
  
  // Merge form states
  mergeFormStates(targetForm: FormGroup, ...sourceForms: FormGroup[]): void {
    const mergedValue = sourceForms.reduce((acc, form) => {
      return { ...acc, ...form.value };
    }, {});
    
    // Use patchValue for merging (more flexible)
    targetForm.patchValue(mergedValue);
  }
}
```

**When to Use Each:**

**Use `setValue` when:**
- Loading complete data from API
- Replacing entire form content
- You want strict validation of data structure
- Working with strongly typed forms
- Ensuring all required fields are provided

**Use `patchValue` when:**
- Updating specific fields only
- Working with partial data
- Handling user input changes
- Merging data from multiple sources
- Dealing with optional or dynamic fields
- Need flexibility with data structure

**Best Practices:**
- Use `setValue` for complete data replacement
- Use `patchValue` for incremental updates
- Handle errors gracefully with try-catch for `setValue`
- Consider using both methods together for different scenarios
- Always validate data before updating forms
- Use appropriate options (`emitEvent`, `onlySelf`) when needed

[Back to Forms and Validation](#forms-and-validation)

### 81. How do you handle file uploads in forms?

**Answer:**
File uploads in Angular forms require special handling since file inputs don't work with standard form controls. Here are comprehensive approaches for handling file uploads with proper validation, progress tracking, and user experience.

**Basic File Upload Implementation:**

**1. Simple File Upload Component:**
```typescript
// file-upload.component.ts
import { Component, Input, Output, EventEmitter, forwardRef } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

@Component({
  selector: 'app-file-upload',
  template: `
    <div class="file-upload-container">
      <input 
        #fileInput
        type="file"
        [accept]="acceptedTypes"
        [multiple]="multiple"
        (change)="onFileSelected($event)"
        class="file-input" />
      
      <div class="upload-area" 
           (click)="fileInput.click()"
           (dragover)="onDragOver($event)"
           (dragleave)="onDragLeave($event)"
           (drop)="onDrop($event)"
           [class.drag-over]="isDragOver">
        
        <div *ngIf="!selectedFiles.length" class="upload-prompt">
          <i class="upload-icon">📁</i>
          <p>Click to select files or drag and drop</p>
          <small>{{acceptedTypes || 'All file types'}} - Max {{maxSize | fileSize}}</small>
        </div>
        
        <div *ngIf="selectedFiles.length" class="selected-files">
          <div *ngFor="let file of selectedFiles; let i = index" class="file-item">
            <div class="file-info">
              <span class="file-name">{{file.name}}</span>
              <span class="file-size">{{file.size | fileSize}}</span>
            </div>
            <button type="button" (click)="removeFile(i)" class="remove-btn">×</button>
          </div>
        </div>
      </div>
      
      <div *ngIf="errors.length" class="upload-errors">
        <div *ngFor="let error of errors" class="error-message">
          {{error}}
        </div>
      </div>
    </div>
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => FileUploadComponent),
      multi: true
    }
  ],
  styles: [`
    .file-upload-container {
      width: 100%;
    }
    
    .file-input {
      display: none;
    }
    
    .upload-area {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .upload-area:hover,
    .upload-area.drag-over {
      border-color: #007bff;
      background-color: #f8f9fa;
    }
    
    .upload-prompt {
      color: #666;
    }
    
    .upload-icon {
      font-size: 3rem;
      display: block;
      margin-bottom: 1rem;
    }
    
    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 0.5rem;
    }
    
    .file-info {
      display: flex;
      flex-direction: column;
      text-align: left;
    }
    
    .file-name {
      font-weight: bold;
    }
    
    .file-size {
      font-size: 0.875rem;
      color: #666;
    }
    
    .remove-btn {
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      cursor: pointer;
    }
    
    .upload-errors {
      margin-top: 0.5rem;
    }
    
    .error-message {
      color: #dc3545;
      font-size: 0.875rem;
      margin-bottom: 0.25rem;
    }
  `]
})
export class FileUploadComponent implements ControlValueAccessor {
  @Input() acceptedTypes = '';
  @Input() maxSize = 10 * 1024 * 1024; // 10MB
  @Input() maxFiles = 5;
  @Input() multiple = false;
  
  selectedFiles: File[] = [];
  errors: string[] = [];
  isDragOver = false;
  
  private onChange = (files: File[]) => {};
  private onTouched = () => {};
  
  // ControlValueAccessor implementation
  writeValue(files: File[]): void {
    this.selectedFiles = files || [];
  }
  
  registerOnChange(fn: (files: File[]) => void): void {
    this.onChange = fn;
  }
  
  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }
  
  onFileSelected(event: Event): void {
    const input = event.target as HTMLInputElement;
    if (input.files) {
      this.handleFiles(Array.from(input.files));
    }
  }
  
  onDragOver(event: DragEvent): void {
    event.preventDefault();
    this.isDragOver = true;
  }
  
  onDragLeave(event: DragEvent): void {
    event.preventDefault();
    this.isDragOver = false;
  }
  
  onDrop(event: DragEvent): void {
    event.preventDefault();
    this.isDragOver = false;
    
    if (event.dataTransfer?.files) {
      this.handleFiles(Array.from(event.dataTransfer.files));
    }
  }
  
  private handleFiles(files: File[]): void {
    this.errors = [];
    const validFiles: File[] = [];
    
    files.forEach(file => {
      if (this.validateFile(file)) {
        validFiles.push(file);
      }
    });
    
    if (this.multiple) {
      this.selectedFiles = [...this.selectedFiles, ...validFiles];
      
      // Check total file count
      if (this.selectedFiles.length > this.maxFiles) {
        this.errors.push(`Maximum ${this.maxFiles} files allowed`);
        this.selectedFiles = this.selectedFiles.slice(0, this.maxFiles);
      }
    } else {
      this.selectedFiles = validFiles.slice(0, 1);
    }
    
    this.onChange(this.selectedFiles);
    this.onTouched();
  }
  
  private validateFile(file: File): boolean {
    // Size validation
    if (file.size > this.maxSize) {
      this.errors.push(`${file.name}: File size exceeds ${this.formatFileSize(this.maxSize)}`);
      return false;
    }
    
    // Type validation
    if (this.acceptedTypes) {
      const acceptedTypesArray = this.acceptedTypes.split(',').map(type => type.trim());
      const isAccepted = acceptedTypesArray.some(type => {
        if (type.startsWith('.')) {
          return file.name.toLowerCase().endsWith(type.toLowerCase());
        } else {
          return file.type.includes(type.replace('*', ''));
        }
      });
      
      if (!isAccepted) {
        this.errors.push(`${file.name}: File type not accepted`);
        return false;
      }
    }
    
    return true;
  }
  
  removeFile(index: number): void {
    this.selectedFiles.splice(index, 1);
    this.onChange(this.selectedFiles);
  }
  
  private formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}
```

**2. File Upload Service:**
```typescript
// file-upload.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpEventType, HttpRequest } from '@angular/common/http';
import { Observable, Subject, BehaviorSubject } from 'rxjs';
import { map, catchError } from 'rxjs/operators';

interface UploadProgress {
  file: File;
  progress: number;
  status: 'pending' | 'uploading' | 'completed' | 'error';
  response?: any;
  error?: string;
}

@Injectable({ providedIn: 'root' })
export class FileUploadService {
  private uploadProgress$ = new BehaviorSubject<UploadProgress[]>([]);
  
  constructor(private http: HttpClient) {}
  
  // Upload single file with progress
  uploadFile(file: File, url: string, additionalData?: any): Observable<UploadProgress> {
    const formData = new FormData();
    formData.append('file', file);
    
    if (additionalData) {
      Object.keys(additionalData).forEach(key => {
        formData.append(key, additionalData[key]);
      });
    }
    
    const request = new HttpRequest('POST', url, formData, {
      reportProgress: true
    });
    
    const progressSubject = new Subject<UploadProgress>();
    
    this.http.request(request).subscribe({
      next: (event) => {
        let progress: UploadProgress = {
          file,
          progress: 0,
          status: 'pending'
        };
        
        if (event.type === HttpEventType.UploadProgress) {
          progress = {
            file,
            progress: Math.round(100 * event.loaded / (event.total || 1)),
            status: 'uploading'
          };
        } else if (event.type === HttpEventType.Response) {
          progress = {
            file,
            progress: 100,
            status: 'completed',
            response: event.body
          };
        }
        
        progressSubject.next(progress);
      },
      error: (error) => {
        progressSubject.next({
          file,
          progress: 0,
          status: 'error',
          error: error.message || 'Upload failed'
        });
      },
      complete: () => {
        progressSubject.complete();
      }
    });
    
    return progressSubject.asObservable();
  }
  
  // Upload multiple files
  uploadMultipleFiles(files: File[], url: string, additionalData?: any): Observable<UploadProgress[]> {
    const progressList: UploadProgress[] = files.map(file => ({
      file,
      progress: 0,
      status: 'pending' as const
    }));
    
    this.uploadProgress$.next(progressList);
    
    files.forEach((file, index) => {
      this.uploadFile(file, url, additionalData).subscribe(progress => {
        progressList[index] = progress;
        this.uploadProgress$.next([...progressList]);
      });
    });
    
    return this.uploadProgress$.asObservable();
  }
  
  // Upload with retry logic
  uploadWithRetry(file: File, url: string, maxRetries = 3): Observable<UploadProgress> {
    return new Observable(observer => {
      let retryCount = 0;
      
      const attemptUpload = () => {
        this.uploadFile(file, url).subscribe({
          next: (progress) => {
            observer.next(progress);
            if (progress.status === 'completed') {
              observer.complete();
            }
          },
          error: (error) => {
            if (retryCount < maxRetries) {
              retryCount++;
              console.log(`Retrying upload (${retryCount}/${maxRetries})`);
              setTimeout(attemptUpload, 1000 * retryCount); // Exponential backoff
            } else {
              observer.next({
                file,
                progress: 0,
                status: 'error',
                error: `Upload failed after ${maxRetries} retries`
              });
              observer.complete();
            }
          }
        });
      };
      
      attemptUpload();
    });
  }
  
  // Chunked upload for large files
  uploadLargeFile(file: File, url: string, chunkSize = 1024 * 1024): Observable<UploadProgress> {
    return new Observable(observer => {
      const totalChunks = Math.ceil(file.size / chunkSize);
      let currentChunk = 0;
      
      const uploadChunk = () => {
        const start = currentChunk * chunkSize;
        const end = Math.min(start + chunkSize, file.size);
        const chunk = file.slice(start, end);
        
        const formData = new FormData();
        formData.append('chunk', chunk);
        formData.append('chunkIndex', currentChunk.toString());
        formData.append('totalChunks', totalChunks.toString());
        formData.append('fileName', file.name);
        
        this.http.post(url, formData).subscribe({
          next: (response) => {
            currentChunk++;
            const progress = Math.round((currentChunk / totalChunks) * 100);
            
            observer.next({
              file,
              progress,
              status: currentChunk < totalChunks ? 'uploading' : 'completed',
              response: currentChunk === totalChunks ? response : undefined
            });
            
            if (currentChunk < totalChunks) {
              uploadChunk();
            } else {
              observer.complete();
            }
          },
          error: (error) => {
            observer.next({
              file,
              progress: 0,
              status: 'error',
              error: error.message
            });
            observer.complete();
          }
        });
      };
      
      uploadChunk();
    });
  }
}
```

**3. Form Integration:**
```typescript
// file-form.component.ts
@Component({
  selector: 'app-file-form',
  template: `
    <form [formGroup]="form" (ngSubmit)="onSubmit()">
      <div class="form-group">
        <label>Document Title *</label>
        <input formControlName="title" class="form-control" />
        <div *ngIf="form.get('title')?.errors?.['required'] && form.get('title')?.touched" 
             class="error">Title is required</div>
      </div>
      
      <div class="form-group">
        <label>Description</label>
        <textarea formControlName="description" class="form-control"></textarea>
      </div>
      
      <div class="form-group">
        <label>Files *</label>
        <app-file-upload 
          formControlName="files"
          [multiple]="true"
          [maxFiles]="5"
          [maxSize]="10485760"
          acceptedTypes=".pdf,.doc,.docx,image/*">
        </app-file-upload>
        <div *ngIf="form.get('files')?.errors?.['required'] && form.get('files')?.touched" 
             class="error">At least one file is required</div>
      </div>
      
      <!-- Upload progress -->
      <div *ngIf="uploadProgress.length" class="upload-progress">
        <h4>Upload Progress</h4>
        <div *ngFor="let progress of uploadProgress" class="progress-item">
          <div class="progress-info">
            <span>{{progress.file.name}}</span>
            <span class="status" [class]="progress.status">{{progress.status}}</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" [style.width.%]="progress.progress"></div>
          </div>
          <div *ngIf="progress.error" class="error">{{progress.error}}</div>
        </div>
      </div>
      
      <button type="submit" [disabled]="form.invalid || isUploading" class="btn btn-primary">
        {{isUploading ? 'Uploading...' : 'Submit'}}
      </button>
    </form>
  `
})
export class FileFormComponent {
  form = this.fb.group({
    title: ['', Validators.required],
    description: [''],
    files: [[], this.filesRequiredValidator]
  });
  
  uploadProgress: UploadProgress[] = [];
  isUploading = false;
  
  constructor(
    private fb: FormBuilder,
    private fileUploadService: FileUploadService
  ) {}
  
  filesRequiredValidator(control: AbstractControl): ValidationErrors | null {
    const files = control.value as File[];
    return files && files.length > 0 ? null : { required: true };
  }
  
  onSubmit(): void {
    if (this.form.valid) {
      this.isUploading = true;
      const formValue = this.form.value;
      const files = formValue.files as File[];
      
      this.fileUploadService.uploadMultipleFiles(
        files, 
        '/api/upload',
        {
          title: formValue.title,
          description: formValue.description
        }
      ).subscribe(progressList => {
        this.uploadProgress = progressList;
        
        // Check if all uploads completed
        const allCompleted = progressList.every(p => 
          p.status === 'completed' || p.status === 'error'
        );
        
        if (allCompleted) {
          this.isUploading = false;
          const hasErrors = progressList.some(p => p.status === 'error');
          
          if (!hasErrors) {
            console.log('All files uploaded successfully');
            this.form.reset();
            this.uploadProgress = [];
          }
        }
      });
    }
  }
}
```

**4. Advanced File Validation:**
```typescript
// file-validators.ts
export class FileValidators {
  
  static fileSize(maxSize: number): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const files = control.value as File[];
      if (!files || files.length === 0) return null;
      
      const oversizedFiles = files.filter(file => file.size > maxSize);
      return oversizedFiles.length > 0 
        ? { fileSize: { maxSize, oversizedFiles: oversizedFiles.map(f => f.name) } }
        : null;
    };
  }
  
  static fileType(allowedTypes: string[]): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const files = control.value as File[];
      if (!files || files.length === 0) return null;
      
      const invalidFiles = files.filter(file => {
        return !allowedTypes.some(type => {
          if (type.startsWith('.')) {
            return file.name.toLowerCase().endsWith(type.toLowerCase());
          } else {
            return file.type.includes(type.replace('*', ''));
          }
        });
      });
      
      return invalidFiles.length > 0 
        ? { fileType: { allowedTypes, invalidFiles: invalidFiles.map(f => f.name) } }
        : null;
    };
  }
  
  static maxFiles(maxCount: number): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const files = control.value as File[];
      if (!files || files.length <= maxCount) return null;
      
      return { maxFiles: { maxCount, actualCount: files.length } };
    };
  }
  
  static minFiles(minCount: number): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const files = control.value as File[];
      const actualCount = files ? files.length : 0;
      
      return actualCount < minCount 
        ? { minFiles: { minCount, actualCount } }
        : null;
    };
  }
  
  static imageOnly(): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const files = control.value as File[];
      if (!files || files.length === 0) return null;
      
      const nonImageFiles = files.filter(file => !file.type.startsWith('image/'));
      return nonImageFiles.length > 0 
        ? { imageOnly: { nonImageFiles: nonImageFiles.map(f => f.name) } }
        : null;
    };
  }
}

// Usage
this.form = this.fb.group({
  documents: [[], [
    FileValidators.minFiles(1),
    FileValidators.maxFiles(5),
    FileValidators.fileSize(10 * 1024 * 1024), // 10MB
    FileValidators.fileType(['.pdf', '.doc', '.docx'])
  ]],
  images: [[], [
    FileValidators.imageOnly(),
    FileValidators.maxFiles(3)
  ]]
});
```

**Best Practices:**
- Implement proper file validation (size, type, count)
- Show upload progress for better user experience
- Handle errors gracefully with retry mechanisms
- Use chunked uploads for large files
- Implement drag-and-drop functionality
- Validate files on both client and server
- Provide clear feedback about file requirements
- Clean up file references to prevent memory leaks

[Back to Forms and Validation](#forms-and-validation)

### 82. What are form builders and how to use them?

**Answer:**
FormBuilder is a service that provides convenient methods for creating FormControl, FormGroup, and FormArray instances. It simplifies reactive form creation and provides a more readable, maintainable way to build complex forms.

**Basic FormBuilder Usage:**

**1. Simple Form Creation:**
```typescript
// Without FormBuilder (verbose)
export class WithoutFormBuilderComponent {
  form = new FormGroup({
    name: new FormControl('', [Validators.required, Validators.minLength(2)]),
    email: new FormControl('', [Validators.required, Validators.email]),
    age: new FormControl('', [Validators.required, Validators.min(18)]),
    address: new FormGroup({
      street: new FormControl(''),
      city: new FormControl('', Validators.required),
      zipCode: new FormControl('', [Validators.required, Validators.pattern(/^\d{5}$/)])
    })
  });
}

// With FormBuilder (clean and readable)
export class WithFormBuilderComponent {
  form = this.fb.group({
    name: ['', [Validators.required, Validators.minLength(2)]],
    email: ['', [Validators.required, Validators.email]],
    age: ['', [Validators.required, Validators.min(18)]],
    address: this.fb.group({
      street: [''],
      city: ['', Validators.required],
      zipCode: ['', [Validators.required, Validators.pattern(/^\d{5}$/)]]
    })
  });
  
  constructor(private fb: FormBuilder) {}
}
```

**2. Advanced FormBuilder Patterns:**
```typescript
// advanced-form-builder.service.ts
@Injectable({ providedIn: 'root' })
export class AdvancedFormBuilderService {
  
  constructor(private fb: FormBuilder) {}
  
  // Create user registration form
  createUserRegistrationForm(): FormGroup {
    return this.fb.group({
      // Personal information
      personalInfo: this.fb.group({
        firstName: ['', [Validators.required, Validators.minLength(2)]],
        lastName: ['', [Validators.required, Validators.minLength(2)]],
        dateOfBirth: ['', [Validators.required, this.ageValidator(18)]],
        gender: ['', Validators.required]
      }),
      
      // Account details
      account: this.fb.group({
        username: ['', [Validators.required, Validators.minLength(3)], [this.usernameAsyncValidator()]],
        email: ['', [Validators.required, Validators.email], [this.emailAsyncValidator()]],
        password: ['', [Validators.required, this.strongPasswordValidator()]],
        confirmPassword: ['', Validators.required]
      }, { validators: this.passwordMatchValidator }),
      
      // Contact information
      contacts: this.fb.array([
        this.createContactGroup()
      ]),
      
      // Preferences
      preferences: this.fb.group({
        newsletter: [false],
        notifications: this.fb.group({
          email: [true],
          sms: [false],
          push: [true]
        }),
        privacy: this.fb.group({
          profileVisible: [true],
          dataSharing: [false]
        })
      }),
      
      // Terms and conditions
      agreements: this.fb.group({
        termsAccepted: [false, Validators.requiredTrue],
        privacyAccepted: [false, Validators.requiredTrue],
        marketingConsent: [false]
      })
    });
  }
  
  // Create contact group for FormArray
  createContactGroup(contact?: any): FormGroup {
    return this.fb.group({
      type: [contact?.type || 'email', Validators.required],
      value: [contact?.value || '', [Validators.required, this.contactValidator()]],
      isPrimary: [contact?.isPrimary || false]
    });
  }
  
  // Create dynamic form based on configuration
  createDynamicForm(config: FormFieldConfig[]): FormGroup {
    const group: any = {};
    
    config.forEach(field => {
      if (field.type === 'group') {
        group[field.name] = this.createDynamicForm(field.children || []);
      } else if (field.type === 'array') {
        group[field.name] = this.fb.array(
          field.defaultItems?.map(item => this.createDynamicForm(field.itemConfig || [])) || []
        );
      } else {
        group[field.name] = [
          field.defaultValue || '',
          this.buildValidators(field.validations || []),
          this.buildAsyncValidators(field.asyncValidations || [])
        ];
      }
    });
    
    return this.fb.group(group);
  }
  
  // Build form with conditional fields
  createConditionalForm(): FormGroup {
    const form = this.fb.group({
      userType: ['individual', Validators.required],
      
      // Individual fields
      firstName: [''],
      lastName: [''],
      personalId: [''],
      
      // Business fields
      companyName: [''],
      taxId: [''],
      businessType: [''],
      
      // Common fields
      email: ['', [Validators.required, Validators.email]],
      phone: ['', Validators.required]
    });
    
    // Set up conditional validation
    form.get('userType')?.valueChanges.subscribe(userType => {
      this.updateConditionalValidation(form, userType);
    });
    
    return form;
  }
  
  private updateConditionalValidation(form: FormGroup, userType: string): void {
    const individualFields = ['firstName', 'lastName', 'personalId'];
    const businessFields = ['companyName', 'taxId', 'businessType'];
    
    if (userType === 'individual') {
      this.setFieldsValidation(form, individualFields, [Validators.required]);
      this.clearFieldsValidation(form, businessFields);
    } else if (userType === 'business') {
      this.setFieldsValidation(form, businessFields, [Validators.required]);
      this.clearFieldsValidation(form, individualFields);
    }
  }
  
  private setFieldsValidation(form: FormGroup, fields: string[], validators: ValidatorFn[]): void {
    fields.forEach(field => {
      const control = form.get(field);
      control?.setValidators(validators);
      control?.updateValueAndValidity();
    });
  }
  
  private clearFieldsValidation(form: FormGroup, fields: string[]): void {
    fields.forEach(field => {
      const control = form.get(field);
      control?.clearValidators();
      control?.setValue('');
      control?.updateValueAndValidity();
    });
  }
  
  // Custom validators
  private ageValidator(minAge: number): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      if (!control.value) return null;
      
      const birthDate = new Date(control.value);
      const today = new Date();
      const age = today.getFullYear() - birthDate.getFullYear();
      
      return age >= minAge ? null : { minAge: { requiredAge: minAge, actualAge: age } };
    };
  }
  
  private strongPasswordValidator(): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      if (!control.value) return null;
      
      const value = control.value;
      const hasUpperCase = /[A-Z]/.test(value);
      const hasLowerCase = /[a-z]/.test(value);
      const hasNumeric = /[0-9]/.test(value);
      const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(value);
      const isLongEnough = value.length >= 8;
      
      const isValid = hasUpperCase && hasLowerCase && hasNumeric && hasSpecialChar && isLongEnough;
      
      return isValid ? null : {
        strongPassword: {
          hasUpperCase,
          hasLowerCase,
          hasNumeric,
          hasSpecialChar,
          isLongEnough
        }
      };
    };
  }
  
  private passwordMatchValidator(group: AbstractControl): ValidationErrors | null {
    const password = group.get('password');
    const confirmPassword = group.get('confirmPassword');
    
    if (!password || !confirmPassword) return null;
    
    return password.value === confirmPassword.value ? null : { passwordMismatch: true };
  }
  
  private contactValidator(): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      if (!control.value) return null;
      
      const parent = control.parent;
      const type = parent?.get('type')?.value;
      
      if (type === 'email') {
        return Validators.email(control);
      } else if (type === 'phone') {
        const phonePattern = /^\+?[\d\s-()]+$/;
        return phonePattern.test(control.value) ? null : { invalidPhone: true };
      }
      
      return null;
    };
  }
  
  private usernameAsyncValidator(): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value) return of(null);
      
      return timer(500).pipe(
        switchMap(() => 
          // Simulate API call
          of(['admin', 'root', 'test'].includes(control.value.toLowerCase()))
        ),
        map(exists => exists ? { usernameExists: true } : null)
      );
    };
  }
  
  private emailAsyncValidator(): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value) return of(null);
      
      return timer(300).pipe(
        switchMap(() => 
          // Simulate API call
          of(Math.random() > 0.7) // 30% chance of email being taken
        ),
        map(exists => exists ? { emailTaken: true } : null)
      );
    };
  }
  
  private buildValidators(validations: any[]): ValidatorFn[] {
    const validators: ValidatorFn[] = [];
    
    validations.forEach(validation => {
      switch (validation.type) {
        case 'required':
          validators.push(Validators.required);
          break;
        case 'minLength':
          validators.push(Validators.minLength(validation.value));
          break;
        case 'maxLength':
          validators.push(Validators.maxLength(validation.value));
          break;
        case 'pattern':
          validators.push(Validators.pattern(validation.value));
          break;
        case 'email':
          validators.push(Validators.email);
          break;
        case 'min':
          validators.push(Validators.min(validation.value));
          break;
        case 'max':
          validators.push(Validators.max(validation.value));
          break;
      }
    });
    
    return validators;
  }
  
  private buildAsyncValidators(asyncValidations: any[]): AsyncValidatorFn[] {
    // Implementation for async validators
    return [];
  }
}

// Configuration interface for dynamic forms
interface FormFieldConfig {
  name: string;
  type: 'text' | 'email' | 'number' | 'select' | 'checkbox' | 'group' | 'array';
  label?: string;
  defaultValue?: any;
  validations?: any[];
  asyncValidations?: any[];
  children?: FormFieldConfig[];
  itemConfig?: FormFieldConfig[];
  defaultItems?: any[];
}
```

**3. FormBuilder with Complex Nested Structures:**
```typescript
// nested-form-builder.component.ts
@Component({
  selector: 'app-nested-form-builder',
  template: `
    <form [formGroup]="companyForm" (ngSubmit)="onSubmit()">
      <!-- Company Information -->
      <fieldset formGroupName="companyInfo">
        <legend>Company Information</legend>
        <input formControlName="name" placeholder="Company Name" />
        <input formControlName="taxId" placeholder="Tax ID" />
        <input formControlName="industry" placeholder="Industry" />
      </fieldset>
      
      <!-- Departments -->
      <fieldset>
        <legend>Departments</legend>
        <div formArrayName="departments">
          <div *ngFor="let dept of departmentsArray.controls; let i = index" 
               [formGroupName]="i" class="department-group">
            <h4>Department {{i + 1}}</h4>
            <input formControlName="name" placeholder="Department Name" />
            <input formControlName="budget" type="number" placeholder="Budget" />
            
            <!-- Employees in department -->
            <div formArrayName="employees">
              <div *ngFor="let emp of getDepartmentEmployees(i).controls; let j = index"
                   [formGroupName]="j" class="employee-group">
                <input formControlName="firstName" placeholder="First Name" />
                <input formControlName="lastName" placeholder="Last Name" />
                <input formControlName="position" placeholder="Position" />
                <input formControlName="salary" type="number" placeholder="Salary" />
                <button type="button" (click)="removeEmployee(i, j)">Remove Employee</button>
              </div>
            </div>
            <button type="button" (click)="addEmployee(i)">Add Employee</button>
            <button type="button" (click)="removeDepartment(i)">Remove Department</button>
          </div>
        </div>
        <button type="button" (click)="addDepartment()">Add Department</button>
      </fieldset>
      
      <button type="submit" [disabled]="companyForm.invalid">Submit</button>
    </form>
  `
})
export class NestedFormBuilderComponent {
  companyForm: FormGroup;
  
  constructor(private fb: FormBuilder) {
    this.companyForm = this.createCompanyForm();
  }
  
  private createCompanyForm(): FormGroup {
    return this.fb.group({
      companyInfo: this.fb.group({
        name: ['', [Validators.required, Validators.minLength(2)]],
        taxId: ['', [Validators.required, Validators.pattern(/^\d{9}$/)]],
        industry: ['', Validators.required]
      }),
      departments: this.fb.array([
        this.createDepartmentGroup()
      ])
    });
  }
  
  private createDepartmentGroup(): FormGroup {
    return this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2)]],
      budget: ['', [Validators.required, Validators.min(0)]],
      employees: this.fb.array([
        this.createEmployeeGroup()
      ])
    });
  }
  
  private createEmployeeGroup(): FormGroup {
    return this.fb.group({
      firstName: ['', [Validators.required, Validators.minLength(2)]],
      lastName: ['', [Validators.required, Validators.minLength(2)]],
      position: ['', Validators.required],
      salary: ['', [Validators.required, Validators.min(0)]]
    });
  }
  
  get departmentsArray(): FormArray {
    return this.companyForm.get('departments') as FormArray;
  }
  
  getDepartmentEmployees(departmentIndex: number): FormArray {
    return this.departmentsArray.at(departmentIndex).get('employees') as FormArray;
  }
  
  addDepartment(): void {
    this.departmentsArray.push(this.createDepartmentGroup());
  }
  
  removeDepartment(index: number): void {
    this.departmentsArray.removeAt(index);
  }
  
  addEmployee(departmentIndex: number): void {
    const employeesArray = this.getDepartmentEmployees(departmentIndex);
    employeesArray.push(this.createEmployeeGroup());
  }
  
  removeEmployee(departmentIndex: number, employeeIndex: number): void {
    const employeesArray = this.getDepartmentEmployees(departmentIndex);
    employeesArray.removeAt(employeeIndex);
  }
  
  onSubmit(): void {
    if (this.companyForm.valid) {
      console.log('Form submitted:', this.companyForm.value);
    }
  }
}
```

**4. FormBuilder Best Practices:**
```typescript
// form-builder-best-practices.service.ts
@Injectable({ providedIn: 'root' })
export class FormBuilderBestPracticesService {
  
  constructor(private fb: FormBuilder) {}
  
  // 1. Use factory methods for reusable form structures
  createAddressForm(): FormGroup {
    return this.fb.group({
      street: ['', Validators.required],
      city: ['', Validators.required],
      state: ['', Validators.required],
      zipCode: ['', [Validators.required, Validators.pattern(/^\d{5}(-\d{4})?$/)]]
    });
  }
  
  // 2. Use configuration objects for complex forms
  createFormFromConfig(config: any): FormGroup {
    const formConfig: any = {};
    
    Object.keys(config).forEach(key => {
      const fieldConfig = config[key];
      
      if (fieldConfig.type === 'group') {
        formConfig[key] = this.createFormFromConfig(fieldConfig.fields);
      } else if (fieldConfig.type === 'array') {
        formConfig[key] = this.fb.array([]);
      } else {
        formConfig[key] = [
          fieldConfig.defaultValue || '',
          fieldConfig.validators || [],
          fieldConfig.asyncValidators || []
        ];
      }
    });
    
    return this.fb.group(formConfig);
  }
  
  // 3. Use typed form groups
  createTypedUserForm(): FormGroup<UserFormControls> {
    return this.fb.group<UserFormControls>({
      name: this.fb.control('', { validators: [Validators.required] }),
      email: this.fb.control('', { 
        validators: [Validators.required, Validators.email] 
      }),
      age: this.fb.control(null, { 
        validators: [Validators.required, Validators.min(18)] 
      })
    });
  }
  
  // 4. Create forms with default data
  createFormWithDefaults(defaultData: any): FormGroup {
    return this.fb.group({
      name: [defaultData.name || '', Validators.required],
      email: [defaultData.email || '', [Validators.required, Validators.email]],
      preferences: this.fb.group({
        theme: [defaultData.preferences?.theme || 'light'],
        notifications: [defaultData.preferences?.notifications ?? true]
      })
    });
  }
  
  // 5. Form cloning and copying
  cloneForm(originalForm: FormGroup): FormGroup {
    const clonedForm = this.fb.group({});
    
    Object.keys(originalForm.controls).forEach(key => {
      const control = originalForm.get(key);
      if (control instanceof FormGroup) {
        clonedForm.addControl(key, this.cloneForm(control));
      } else if (control instanceof FormArray) {
        clonedForm.addControl(key, this.cloneFormArray(control));
      } else {
        clonedForm.addControl(key, this.fb.control(
          control?.value,
          control?.validator,
          control?.asyncValidator
        ));
      }
    });
    
    return clonedForm;
  }
  
  private cloneFormArray(originalArray: FormArray): FormArray {
    const clonedArray = this.fb.array([]);
    
    originalArray.controls.forEach(control => {
      if (control instanceof FormGroup) {
        clonedArray.push(this.cloneForm(control));
      } else {
        clonedArray.push(this.fb.control(
          control.value,
          control.validator,
          control.asyncValidator
        ));
      }
    });
    
    return clonedArray;
  }
}

// Type definitions for better type safety
interface UserFormControls {
  name: FormControl<string>;
  email: FormControl<string>;
  age: FormControl<number | null>;
}
```

**FormBuilder Methods Summary:**

| Method | Purpose | Example |
|--------|---------|---------|
| `fb.control()` | Create FormControl | `fb.control('', Validators.required)` |
| `fb.group()` | Create FormGroup | `fb.group({ name: [''] })` |
| `fb.array()` | Create FormArray | `fb.array([fb.control('')])` |
| `fb.record()` | Create FormRecord | `fb.record({ key: fb.control('') })` |

**Advantages of FormBuilder:**
- **Cleaner syntax** - Less verbose than manual construction
- **Better readability** - Form structure is more apparent
- **Consistent patterns** - Standardized way to build forms
- **Less boilerplate** - Reduces repetitive code
- **Better maintainability** - Easier to modify and extend

**Best Practices:**
- Always inject FormBuilder in constructor
- Use factory methods for reusable form structures
- Leverage TypeScript for better type safety
- Create configuration-driven forms for dynamic scenarios
- Use meaningful names for form controls
- Group related fields logically
- Document complex form structures

[Back to Forms and Validation](#forms-and-validation)

### 83. How do you implement cross-field validation?

**Answer:**
Cross-field validation involves validating one field based on the value of another field or validating multiple fields together. This is essential for scenarios like password confirmation, date ranges, or conditional required fields.

**1. Password Confirmation Validator:**
```typescript
// password-match.validator.ts
export function passwordMatchValidator(group: AbstractControl): ValidationErrors | null {
  const password = group.get('password');
  const confirmPassword = group.get('confirmPassword');
  
  if (!password || !confirmPassword) {
    return null;
  }
  
  if (password.value !== confirmPassword.value) {
    // Set error on confirmPassword field
    confirmPassword.setErrors({ passwordMismatch: true });
    return { passwordMismatch: true };
  } else {
    // Clear the error if passwords match
    if (confirmPassword.hasError('passwordMismatch')) {
      delete confirmPassword.errors?.['passwordMismatch'];
      if (Object.keys(confirmPassword.errors || {}).length === 0) {
        confirmPassword.setErrors(null);
      }
    }
  }
  
  return null;
}

// Usage in form
export class PasswordFormComponent {
  form = this.fb.group({
    password: ['', [Validators.required, Validators.minLength(8)]],
    confirmPassword: ['', Validators.required]
  }, { validators: passwordMatchValidator });
  
  constructor(private fb: FormBuilder) {}
}
```

**2. Date Range Validator:**
```typescript
// date-range.validator.ts
export function dateRangeValidator(startDateField: string, endDateField: string): ValidatorFn {
  return (group: AbstractControl): ValidationErrors | null => {
    const startDate = group.get(startDateField);
    const endDate = group.get(endDateField);
    
    if (!startDate?.value || !endDate?.value) {
      return null;
    }
    
    const start = new Date(startDate.value);
    const end = new Date(endDate.value);
    
    if (start >= end) {
      return {
        dateRange: {
          startDate: startDate.value,
          endDate: endDate.value,
          message: 'End date must be after start date'
        }
      };
    }
    
    return null;
  };
}

// Advanced date range with business rules
export function businessDateRangeValidator(): ValidatorFn {
  return (group: AbstractControl): ValidationErrors | null => {
    const startDate = group.get('startDate');
    const endDate = group.get('endDate');
    const duration = group.get('duration');
    
    if (!startDate?.value || !endDate?.value) {
      return null;
    }
    
    const start = new Date(startDate.value);
    const end = new Date(endDate.value);
    const today = new Date();
    
    const errors: ValidationErrors = {};
    
    // End date must be after start date
    if (start >= end) {
      errors['dateOrder'] = { message: 'End date must be after start date' };
    }
    
    // Start date cannot be in the past
    if (start < today) {
      errors['pastStartDate'] = { message: 'Start date cannot be in the past' };
    }
    
    // Maximum duration check
    const daysDifference = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
    if (daysDifference > 365) {
      errors['maxDuration'] = { message: 'Duration cannot exceed 365 days' };
    }
    
    // Update duration field if provided
    if (duration) {
      duration.setValue(daysDifference, { emitEvent: false });
    }
    
    return Object.keys(errors).length > 0 ? errors : null;
  };
}

// Usage
export class BookingFormComponent {
  form = this.fb.group({
    startDate: ['', Validators.required],
    endDate: ['', Validators.required],
    duration: [{ value: 0, disabled: true }]
  }, { validators: businessDateRangeValidator() });
  
  constructor(private fb: FormBuilder) {}
}
```

**3. Conditional Required Validator:**
```typescript
// conditional-required.validator.ts
export function conditionalRequiredValidator(
  conditionalField: string, 
  conditionalValue: any, 
  requiredFields: string[]
): ValidatorFn {
  return (group: AbstractControl): ValidationErrors | null => {
    const conditionalControl = group.get(conditionalField);
    
    if (!conditionalControl) {
      return null;
    }
    
    const shouldRequire = conditionalControl.value === conditionalValue;
    const errors: ValidationErrors = {};
    
    requiredFields.forEach(fieldName => {
      const control = group.get(fieldName);
      if (!control) return;
      
      if (shouldRequire && (!control.value || control.value.trim() === '')) {
        errors[fieldName] = { conditionallyRequired: true };
        
        // Set error on individual control
        const currentErrors = control.errors || {};
        currentErrors['conditionallyRequired'] = true;
        control.setErrors(currentErrors);
      } else if (!shouldRequire && control.hasError('conditionallyRequired')) {
        // Clear conditional required error
        const currentErrors = control.errors || {};
        delete currentErrors['conditionallyRequired'];
        control.setErrors(Object.keys(currentErrors).length > 0 ? currentErrors : null);
      }
    });
    
    return Object.keys(errors).length > 0 ? errors : null;
  };
}

// Usage
export class ShippingFormComponent {
  form = this.fb.group({
    sameAsBilling: [false],
    billingAddress: ['', Validators.required],
    shippingAddress: [''],
    shippingCity: [''],
    shippingZip: ['']
  }, { 
    validators: conditionalRequiredValidator(
      'sameAsBilling', 
      false, 
      ['shippingAddress', 'shippingCity', 'shippingZip']
    )
  });
  
  constructor(private fb: FormBuilder) {}
}
```

**4. Complex Cross-Field Validation Service:**
```typescript
// cross-field-validation.service.ts
@Injectable({ providedIn: 'root' })
export class CrossFieldValidationService {
  
  // Email and phone validator - at least one required
  createContactValidator(): ValidatorFn {
    return (group: AbstractControl): ValidationErrors | null => {
      const email = group.get('email');
      const phone = group.get('phone');
      
      if (!email || !phone) {
        return null;
      }
      
      const hasEmail = email.value && email.value.trim() !== '';
      const hasPhone = phone.value && phone.value.trim() !== '';
      
      if (!hasEmail && !hasPhone) {
        return { contactRequired: { message: 'Either email or phone is required' } };
      }
      
      return null;
    };
  }
  
  // Budget allocation validator
  createBudgetAllocationValidator(totalBudgetField: string): ValidatorFn {
    return (group: AbstractControl): ValidationErrors | null => {
      const totalBudget = group.get(totalBudgetField);
      if (!totalBudget?.value) return null;
      
      const total = parseFloat(totalBudget.value);
      let allocatedSum = 0;
      
      // Calculate sum of all allocation fields
      Object.keys(group.controls).forEach(key => {
        if (key.startsWith('allocation_') && key !== totalBudgetField) {
          const control = group.get(key);
          if (control?.value) {
            allocatedSum += parseFloat(control.value) || 0;
          }
        }
      });
      
      if (allocatedSum > total) {
        return {
          budgetExceeded: {
            total,
            allocated: allocatedSum,
            excess: allocatedSum - total
          }
        };
      }
      
      if (Math.abs(allocatedSum - total) > 0.01) { // Allow small floating point differences
        return {
          budgetIncomplete: {
            total,
            allocated: allocatedSum,
            remaining: total - allocatedSum
          }
        };
      }
      
      return null;
    };
  }
  
  // Age-dependent validation
  createAgeDependentValidator(): ValidatorFn {
    return (group: AbstractControl): ValidationErrors | null => {
      const birthDate = group.get('birthDate');
      const parentConsent = group.get('parentConsent');
      const emergencyContact = group.get('emergencyContact');
      
      if (!birthDate?.value) return null;
      
      const age = this.calculateAge(new Date(birthDate.value));
      const errors: ValidationErrors = {};
      
      // Under 18 requires parent consent
      if (age < 18) {
        if (!parentConsent?.value) {
          errors['parentConsentRequired'] = { age, message: 'Parent consent required for minors' };
        }
        
        if (!emergencyContact?.value || emergencyContact.value.trim() === '') {
          errors['emergencyContactRequired'] = { age, message: 'Emergency contact required for minors' };
        }
      }
      
      // Over 65 requires additional health information
      if (age > 65) {
        const healthInfo = group.get('healthInformation');
        if (!healthInfo?.value || healthInfo.value.trim() === '') {
          errors['healthInfoRequired'] = { age, message: 'Health information required for seniors' };
        }
      }
      
      return Object.keys(errors).length > 0 ? errors : null;
    };
  }
  
  // Credit card validation with expiry date
  createCreditCardValidator(): ValidatorFn {
    return (group: AbstractControl): ValidationErrors | null => {
      const cardNumber = group.get('cardNumber');
      const expiryMonth = group.get('expiryMonth');
      const expiryYear = group.get('expiryYear');
      const cvv = group.get('cvv');
      
      if (!cardNumber?.value) return null;
      
      const errors: ValidationErrors = {};\n      
      // Validate expiry date
      if (expiryMonth?.value && expiryYear?.value) {
        const expiry = new Date(parseInt(expiryYear.value), parseInt(expiryMonth.value) - 1);
        const now = new Date();
        
        if (expiry < now) {
          errors['cardExpired'] = { message: 'Credit card has expired' };
        }
      }
      
      // Validate CVV length based on card type
      const cardType = this.detectCardType(cardNumber.value);
      if (cvv?.value && cardType) {
        const expectedCvvLength = cardType === 'amex' ? 4 : 3;
        if (cvv.value.length !== expectedCvvLength) {
          errors['invalidCvv'] = { 
            expectedLength: expectedCvvLength, 
            actualLength: cvv.value.length,
            cardType 
          };
        }
      }
      
      return Object.keys(errors).length > 0 ? errors : null;
    };
  }
  
  private calculateAge(birthDate: Date): number {
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }
    
    return age;
  }
  
  private detectCardType(cardNumber: string): string | null {
    const number = cardNumber.replace(/\s/g, '');
    
    if (/^4/.test(number)) return 'visa';
    if (/^5[1-5]/.test(number)) return 'mastercard';
    if (/^3[47]/.test(number)) return 'amex';
    if (/^6(?:011|5)/.test(number)) return 'discover';
    
    return null;
  }
}
```

**5. Real-world Cross-Field Validation Example:**
```typescript
// registration-form.component.ts
@Component({
  selector: 'app-registration-form',
  template: `
    <form [formGroup]="registrationForm" (ngSubmit)="onSubmit()">
      <!-- Personal Information -->
      <fieldset>
        <legend>Personal Information</legend>
        
        <input formControlName="firstName" placeholder="First Name" />
        <input formControlName="lastName" placeholder="Last Name" />
        <input type="date" formControlName="birthDate" placeholder="Birth Date" />
        
        <!-- Age-dependent fields -->
        <div *ngIf="isMinor()">
          <label>
            <input type="checkbox" formControlName="parentConsent" />
            I have parental consent
          </label>
          <input formControlName="emergencyContact" placeholder="Emergency Contact" />
        </div>
        
        <div *ngIf="isSenior()">
          <textarea formControlName="healthInformation" 
                   placeholder="Health Information (required for 65+)"></textarea>
        </div>
      </fieldset>
      
      <!-- Contact Information -->
      <fieldset>
        <legend>Contact Information</legend>
        
        <input type="email" formControlName="email" placeholder="Email" />
        <input type="tel" formControlName="phone" placeholder="Phone" />
        
        <div *ngIf="registrationForm.errors?.['contactRequired']" class="error">
          Either email or phone number is required
        </div>
      </fieldset>
      
      <!-- Account Security -->
      <fieldset>
        <legend>Account Security</legend>
        
        <input type="password" formControlName="password" placeholder="Password" />
        <input type="password" formControlName="confirmPassword" placeholder="Confirm Password" />
        
        <div *ngIf="registrationForm.get('confirmPassword')?.errors?.['passwordMismatch']" class="error">
          Passwords do not match
        </div>
      </fieldset>
      
      <!-- Shipping Information -->
      <fieldset>
        <legend>Shipping Information</legend>
        
        <label>
          <input type="checkbox" formControlName="sameAsBilling" />
          Same as billing address
        </label>
        
        <div *ngIf="!registrationForm.get('sameAsBilling')?.value">
          <input formControlName="shippingAddress" placeholder="Shipping Address" />
          <input formControlName="shippingCity" placeholder="Shipping City" />
          <input formControlName="shippingZip" placeholder="Shipping ZIP" />
        </div>
      </fieldset>
      
      <!-- Form-level errors -->
      <div *ngIf="registrationForm.errors" class="form-errors">
        <div *ngFor="let error of getFormErrors()" class="error">
          {{error}}
        </div>
      </div>
      
      <button type="submit" [disabled]="registrationForm.invalid">
        Register
      </button>
    </form>
  `
})
export class RegistrationFormComponent {
  registrationForm: FormGroup;
  
  constructor(
    private fb: FormBuilder,
    private crossFieldValidation: CrossFieldValidationService
  ) {
    this.registrationForm = this.createRegistrationForm();
    this.setupDynamicValidation();
  }
  
  private createRegistrationForm(): FormGroup {
    return this.fb.group({
      // Personal info
      firstName: ['', [Validators.required, Validators.minLength(2)]],
      lastName: ['', [Validators.required, Validators.minLength(2)]],
      birthDate: ['', Validators.required],
      parentConsent: [false],
      emergencyContact: [''],
      healthInformation: [''],
      
      // Contact info
      email: [''],
      phone: [''],
      
      // Security
      password: ['', [Validators.required, Validators.minLength(8)]],
      confirmPassword: ['', Validators.required],
      
      // Shipping
      sameAsBilling: [true],
      shippingAddress: [''],
      shippingCity: [''],
      shippingZip: ['']
    }, {
      validators: [
        passwordMatchValidator,
        this.crossFieldValidation.createContactValidator(),
        this.crossFieldValidation.createAgeDependentValidator(),
        conditionalRequiredValidator('sameAsBilling', false, [
          'shippingAddress', 'shippingCity', 'shippingZip'
        ])
      ]
    });
  }
  
  private setupDynamicValidation(): void {
    // Update validation when birth date changes
    this.registrationForm.get('birthDate')?.valueChanges.subscribe(() => {
      this.registrationForm.updateValueAndValidity();
    });
    
    // Update validation when same as billing changes
    this.registrationForm.get('sameAsBilling')?.valueChanges.subscribe(() => {
      this.registrationForm.updateValueAndValidity();
    });
  }
  
  isMinor(): boolean {
    const birthDate = this.registrationForm.get('birthDate')?.value;
    if (!birthDate) return false;
    
    const age = this.calculateAge(new Date(birthDate));
    return age < 18;
  }
  
  isSenior(): boolean {
    const birthDate = this.registrationForm.get('birthDate')?.value;
    if (!birthDate) return false;
    
    const age = this.calculateAge(new Date(birthDate));
    return age > 65;
  }
  
  private calculateAge(birthDate: Date): number {
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }
    
    return age;
  }
  
  getFormErrors(): string[] {
    const errors = this.registrationForm.errors || {};
    const errorMessages: string[] = [];
    
    Object.keys(errors).forEach(key => {
      const error = errors[key];
      if (error.message) {
        errorMessages.push(error.message);
      } else {
        errorMessages.push(`Validation error: ${key}`);
      }
    });
    
    return errorMessages;
  }
  
  onSubmit(): void {
    if (this.registrationForm.valid) {
      console.log('Form submitted:', this.registrationForm.value);
    } else {
      console.log('Form errors:', this.registrationForm.errors);
      this.markFormGroupTouched();
    }
  }
  
  private markFormGroupTouched(): void {
    Object.keys(this.registrationForm.controls).forEach(key => {
      this.registrationForm.get(key)?.markAsTouched();
    });
  }
}
```

**Best Practices for Cross-Field Validation:**
- Apply validators at the FormGroup level for cross-field logic
- Set specific errors on individual fields when appropriate
- Clear conditional errors when conditions change
- Use descriptive error messages with context
- Handle dynamic validation updates properly
- Test all validation scenarios thoroughly
- Consider performance implications of complex validators
- Provide clear user feedback for validation errors

[Back to Forms and Validation](#forms-and-validation)

### 84. What is debouncing in form validation?

**Answer:**
Debouncing in form validation delays validation execution until after the user has stopped typing for a specified period. This improves performance by reducing unnecessary validation calls and provides better user experience by avoiding constant error messages while typing.

**Basic Debouncing Implementation:**

```typescript
// debounced-validation.component.ts
export class DebouncedValidationComponent implements OnInit, OnDestroy {
  form = this.fb.group({
    username: ['', [Validators.required, Validators.minLength(3)]],
    email: ['', [Validators.required, Validators.email]]
  });
  
  private destroy$ = new Subject<void>();
  
  constructor(private fb: FormBuilder) {}
  
  ngOnInit(): void {
    // Debounce username validation
    this.form.get('username')?.valueChanges.pipe(
      debounceTime(500), // Wait 500ms after user stops typing
      distinctUntilChanged(),
      takeUntil(this.destroy$)
    ).subscribe(value => {
      if (value && value.length >= 3) {
        this.validateUsername(value);
      }
    });
    
    // Debounce email validation
    this.form.get('email')?.valueChanges.pipe(
      debounceTime(800),
      distinctUntilChanged(),
      filter(value => value && value.includes('@')),
      takeUntil(this.destroy$)
    ).subscribe(value => {
      this.validateEmail(value);
    });
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  private validateUsername(username: string): void {
    // Simulate async validation
    console.log('Validating username:', username);
  }
  
  private validateEmail(email: string): void {
    // Simulate async validation
    console.log('Validating email:', email);
  }
}
```

**Advanced Debouncing Service:**

```typescript
// debounce-validation.service.ts
@Injectable({ providedIn: 'root' })
export class DebounceValidationService {
  
  constructor(private http: HttpClient) {}
  
  createDebouncedAsyncValidator(
    validationFn: (value: any) => Observable<ValidationErrors | null>,
    debounceMs: number = 500
  ): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      if (!control.value) {
        return of(null);
      }
      
      return timer(debounceMs).pipe(
        switchMap(() => validationFn(control.value)),
        catchError(() => of({ validationError: true }))
      );
    };
  }
  
  // Username availability with debouncing
  validateUsernameAvailability = (username: string): Observable<ValidationErrors | null> => {
    return this.http.get<{ available: boolean }>(`/api/check-username/${username}`).pipe(
      map(response => response.available ? null : { usernameTaken: true })
    );
  };
}
```

**Benefits:**
- **Performance**: Reduces API calls and validation overhead
- **User Experience**: Prevents constant error messages while typing
- **Server Load**: Minimizes unnecessary server requests

[Back to Forms and Validation](#forms-and-validation)

### 85. How do you handle form arrays dynamically?

**Answer:**
Dynamic form arrays allow users to add, remove, and modify form sections dynamically. This is essential for scenarios like adding multiple addresses, skills, or any repeating form sections. Angular's FormArray provides the foundation for building these dynamic interfaces.

**Basic Dynamic Form Array:**

**1. Simple Dynamic List:**
```typescript
// dynamic-skills.component.ts
@Component({
  selector: 'app-dynamic-skills',
  template: `
    <form [formGroup]="form" (ngSubmit)="onSubmit()">
      <h3>Skills</h3>
      
      <div formArrayName="skills">
        <div *ngFor="let skill of skillsArray.controls; let i = index" 
             [formGroupName]="i" 
             class="skill-item">
          
          <div class="skill-fields">
            <input 
              formControlName="name" 
              placeholder="Skill name"
              class="form-control" />
            
            <select formControlName="level" class="form-control">
              <option value="">Select level</option>
              <option value="beginner">Beginner</option>
              <option value="intermediate">Intermediate</option>
              <option value="advanced">Advanced</option>
              <option value="expert">Expert</option>
            </select>
            
            <input 
              type="number" 
              formControlName="years" 
              placeholder="Years"
              min="0" 
              max="50"
              class="form-control" />
          </div>
          
          <div class="skill-actions">
            <button 
              type="button" 
              (click)="removeSkill(i)"
              [disabled]="skillsArray.length <= 1"
              class="btn btn-danger btn-sm">
              Remove
            </button>
            
            <button 
              type="button" 
              (click)="moveSkillUp(i)"
              [disabled]="i === 0"
              class="btn btn-secondary btn-sm">
              ↑
            </button>
            
            <button 
              type="button" 
              (click)="moveSkillDown(i)"
              [disabled]="i === skillsArray.length - 1"
              class="btn btn-secondary btn-sm">
              ↓
            </button>
          </div>
          
          <!-- Validation errors -->
          <div class="field-errors">
            <div *ngIf="getSkillControl(i, 'name')?.errors?.['required'] && getSkillControl(i, 'name')?.touched" 
                 class="error">Skill name is required</div>
            <div *ngIf="getSkillControl(i, 'level')?.errors?.['required'] && getSkillControl(i, 'level')?.touched" 
                 class="error">Skill level is required</div>
          </div>
        </div>
      </div>
      
      <div class="array-actions">
        <button type="button" (click)="addSkill()" class="btn btn-primary">
          Add Skill
        </button>
        <button type="button" (click)="clearAllSkills()" class="btn btn-warning">
          Clear All
        </button>
      </div>
      
      <button type="submit" [disabled]="form.invalid" class="btn btn-success">
        Submit ({{getValidSkillsCount()}}/{{skillsArray.length}} valid)
      </button>
    </form>
  `
})
export class DynamicSkillsComponent {
  form: FormGroup;
  
  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      name: ['', Validators.required],
      skills: this.fb.array([this.createSkillGroup()])
    });
  }
  
  get skillsArray(): FormArray {
    return this.form.get('skills') as FormArray;
  }
  
  createSkillGroup(skill?: any): FormGroup {
    return this.fb.group({
      name: [skill?.name || '', [Validators.required, Validators.minLength(2)]],
      level: [skill?.level || '', Validators.required],
      years: [skill?.years || 0, [Validators.required, Validators.min(0)]]
    });
  }
  
  addSkill(): void {
    this.skillsArray.push(this.createSkillGroup());
  }
  
  removeSkill(index: number): void {
    if (this.skillsArray.length > 1) {
      this.skillsArray.removeAt(index);
    }
  }
  
  moveSkillUp(index: number): void {
    if (index > 0) {
      const skill = this.skillsArray.at(index);
      this.skillsArray.removeAt(index);
      this.skillsArray.insert(index - 1, skill);
    }
  }
  
  moveSkillDown(index: number): void {
    if (index < this.skillsArray.length - 1) {
      const skill = this.skillsArray.at(index);
      this.skillsArray.removeAt(index);
      this.skillsArray.insert(index + 1, skill);
    }
  }
  
  clearAllSkills(): void {
    while (this.skillsArray.length > 0) {
      this.skillsArray.removeAt(0);
    }
    this.addSkill(); // Add one empty skill
  }
  
  getSkillControl(index: number, field: string): AbstractControl | null {
    return this.skillsArray.at(index)?.get(field) || null;
  }
  
  getValidSkillsCount(): number {
    return this.skillsArray.controls.filter(control => control.valid).length;
  }
  
  onSubmit(): void {
    if (this.form.valid) {
      console.log('Form submitted:', this.form.value);
    }
  }
}
```

**2. Advanced Dynamic Array Service:**
```typescript
// dynamic-array.service.ts
@Injectable({ providedIn: 'root' })
export class DynamicArrayService {
  
  constructor(private fb: FormBuilder) {}
  
  // Create array with validation constraints
  createConstrainedArray(
    itemFactory: () => FormGroup,
    constraints: ArrayConstraints = {}
  ): FormArray {
    const array = this.fb.array([], this.createArrayValidator(constraints));
    
    // Add minimum required items
    const minItems = constraints.minItems || 1;
    for (let i = 0; i < minItems; i++) {
      array.push(itemFactory());
    }
    
    return array;
  }
  
  private createArrayValidator(constraints: ArrayConstraints): ValidatorFn {
    return (array: AbstractControl): ValidationErrors | null => {
      const formArray = array as FormArray;
      const errors: ValidationErrors = {};
      
      // Check minimum items
      if (constraints.minItems && formArray.length < constraints.minItems) {
        errors['minItems'] = {
          required: constraints.minItems,
          actual: formArray.length
        };
      }
      
      // Check maximum items
      if (constraints.maxItems && formArray.length > constraints.maxItems) {
        errors['maxItems'] = {
          maximum: constraints.maxItems,
          actual: formArray.length
        };
      }
      
      // Check unique values
      if (constraints.uniqueField) {
        const values = formArray.controls
          .map(control => control.get(constraints.uniqueField!)?.value)
          .filter(value => value);
        
        const duplicates = values.filter((value, index) => 
          values.indexOf(value) !== index
        );
        
        if (duplicates.length > 0) {
          errors['duplicateValues'] = { field: constraints.uniqueField, duplicates };
        }
      }
      
      return Object.keys(errors).length > 0 ? errors : null;
    };
  }
  
  // Safe add item with constraints
  addItem(
    array: FormArray, 
    itemFactory: () => FormGroup,
    constraints: ArrayConstraints = {}
  ): boolean {
    if (constraints.maxItems && array.length >= constraints.maxItems) {
      return false;
    }
    
    array.push(itemFactory());
    return true;
  }
  
  // Safe remove item with constraints
  removeItem(
    array: FormArray, 
    index: number,
    constraints: ArrayConstraints = {}
  ): boolean {
    const minItems = constraints.minItems || 1;
    if (array.length <= minItems) {
      return false;
    }
    
    array.removeAt(index);
    return true;
  }
}

interface ArrayConstraints {
  minItems?: number;
  maxItems?: number;
  uniqueField?: string;
}
```

**3. Nested Dynamic Arrays:**
```typescript
// nested-arrays.component.ts
@Component({
  selector: 'app-nested-arrays',
  template: `
    <form [formGroup]="form">
      <!-- Departments -->
      <div formArrayName="departments">
        <div *ngFor="let dept of departmentsArray.controls; let i = index" 
             [formGroupName]="i" class="department">
          <h3>Department {{i + 1}}</h3>
          <input formControlName="name" placeholder="Department Name" />
          
          <!-- Employees in department -->
          <div formArrayName="employees">
            <div *ngFor="let emp of getEmployeesArray(i).controls; let j = index"
                 [formGroupName]="j" class="employee">
              <input formControlName="name" placeholder="Employee Name" />
              <input formControlName="position" placeholder="Position" />
              <button type="button" (click)="removeEmployee(i, j)">Remove</button>
            </div>
          </div>
          
          <button type="button" (click)="addEmployee(i)">Add Employee</button>
          <button type="button" (click)="removeDepartment(i)">Remove Department</button>
        </div>
      </div>
      
      <button type="button" (click)="addDepartment()">Add Department</button>
    </form>
  `
})
export class NestedArraysComponent {
  form = this.fb.group({
    departments: this.fb.array([this.createDepartmentGroup()])
  });
  
  constructor(private fb: FormBuilder) {}
  
  get departmentsArray(): FormArray {
    return this.form.get('departments') as FormArray;
  }
  
  getEmployeesArray(deptIndex: number): FormArray {
    return this.departmentsArray.at(deptIndex).get('employees') as FormArray;
  }
  
  createDepartmentGroup(): FormGroup {
    return this.fb.group({
      name: ['', Validators.required],
      employees: this.fb.array([this.createEmployeeGroup()])
    });
  }
  
  createEmployeeGroup(): FormGroup {
    return this.fb.group({
      name: ['', Validators.required],
      position: ['', Validators.required]
    });
  }
  
  addDepartment(): void {
    this.departmentsArray.push(this.createDepartmentGroup());
  }
  
  removeDepartment(index: number): void {
    this.departmentsArray.removeAt(index);
  }
  
  addEmployee(deptIndex: number): void {
    this.getEmployeesArray(deptIndex).push(this.createEmployeeGroup());
  }
  
  removeEmployee(deptIndex: number, empIndex: number): void {
    this.getEmployeesArray(deptIndex).removeAt(empIndex);
  }
}
```

**Best Practices:**
- Always provide at least one item in arrays
- Implement proper validation constraints
- Use trackBy functions for performance
- Handle array state changes properly
- Provide clear user feedback
- Test edge cases thoroughly
- Consider accessibility for dynamic content

[Back to Forms and Validation](#forms-and-validation)

### 86. What are DI tokens (`InjectionToken`) and multi providers?

**Answer:**
DI tokens are unique identifiers used by Angular's dependency injection system to register and retrieve dependencies. `InjectionToken` is used for non-class dependencies, while multi providers allow multiple values to be associated with a single token.

**InjectionToken Basics:**

**1. Creating and Using InjectionToken:**
```typescript
// config.token.ts
export const API_CONFIG = new InjectionToken<ApiConfig>('API_CONFIG');
export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');
export const FEATURE_FLAGS = new InjectionToken<FeatureFlags>('FEATURE_FLAGS');

// Type definitions
interface ApiConfig {
  baseUrl: string;
  timeout: number;
  retries: number;
}

interface FeatureFlags {
  enableNewFeature: boolean;
  enableBetaFeatures: boolean;
  debugMode: boolean;
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    // Simple string token
    { provide: API_BASE_URL, useValue: 'https://api.example.com' },
    
    // Complex object token
    { 
      provide: API_CONFIG, 
      useValue: {
        baseUrl: 'https://api.example.com',
        timeout: 5000,
        retries: 3
      }
    },
    
    // Factory-based token
    {
      provide: FEATURE_FLAGS,
      useFactory: (env: Environment) => ({
        enableNewFeature: env.production,
        enableBetaFeatures: !env.production,
        debugMode: !env.production
      }),
      deps: [Environment]
    }
  ]
};
```

**2. Using InjectionToken in Services:**
```typescript
// api.service.ts
@Injectable({ providedIn: 'root' })
export class ApiService {
  constructor(
    private http: HttpClient,
    @Inject(API_CONFIG) private config: ApiConfig,
    @Inject(API_BASE_URL) private baseUrl: string,
    @Inject(FEATURE_FLAGS) private featureFlags: FeatureFlags
  ) {}
  
  getData(): Observable<any> {
    const url = `${this.config.baseUrl}/data`;
    
    return this.http.get(url, {
      timeout: this.config.timeout
    }).pipe(
      retry(this.config.retries),
      tap(data => {
        if (this.featureFlags.debugMode) {
          console.log('API Response:', data);
        }
      })
    );
  }
  
  // Using inject() function (Angular 14+)
  private logger = inject(LOGGER_TOKEN);
  
  logRequest(url: string): void {
    this.logger.log(`Making request to: ${url}`);
  }
}
```

**Multi Providers:**

**3. Basic Multi Provider Setup:**
```typescript
// logger.token.ts
export const LOGGER_TOKEN = new InjectionToken<Logger[]>('LOGGER_TOKEN');

interface Logger {
  log(message: string): void;
}

// logger implementations
export class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(`[CONSOLE]: ${message}`);
  }
}

export class FileLogger implements Logger {
  log(message: string): void {
    // Simulate file logging
    console.log(`[FILE]: Writing to file: ${message}`);
  }
}

export class RemoteLogger implements Logger {
  constructor(private http: HttpClient) {}
  
  log(message: string): void {
    this.http.post('/api/logs', { message, timestamp: Date.now() })
      .subscribe();
  }
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    // Multi providers - all will be available as an array
    { provide: LOGGER_TOKEN, useClass: ConsoleLogger, multi: true },
    { provide: LOGGER_TOKEN, useClass: FileLogger, multi: true },
    { provide: LOGGER_TOKEN, useClass: RemoteLogger, multi: true },
    
    // Alternative syntax with useExisting
    { provide: LOGGER_TOKEN, useExisting: ConsoleLogger, multi: true },
  ]
};
```

**4. Advanced Multi Provider Service:**
```typescript
// logging.service.ts
@Injectable({ providedIn: 'root' })
export class LoggingService {
  constructor(
    @Inject(LOGGER_TOKEN) private loggers: Logger[]
  ) {}
  
  log(message: string, level: 'info' | 'warn' | 'error' = 'info'): void {
    const formattedMessage = `[${level.toUpperCase()}] ${message}`;
    
    // Log to all registered loggers
    this.loggers.forEach(logger => logger.log(formattedMessage));
  }
  
  logToSpecificLogger(message: string, loggerType: string): void {
    const logger = this.loggers.find(l => l.constructor.name === loggerType);
    if (logger) {
      logger.log(message);
    }
  }
  
  getAvailableLoggers(): string[] {
    return this.loggers.map(logger => logger.constructor.name);
  }
}
```

**5. HTTP Interceptor Multi Providers:**
```typescript
// interceptors/auth.interceptor.ts
@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  constructor(private authService: AuthService) {}
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = this.authService.getToken();
    
    if (token) {
      const authReq = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${token}`)
      });
      return next.handle(authReq);
    }
    
    return next.handle(req);
  }
}

// interceptors/logging.interceptor.ts
@Injectable()
export class LoggingInterceptor implements HttpInterceptor {
  constructor(@Inject(LOGGER_TOKEN) private loggers: Logger[]) {}
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const started = Date.now();
    
    this.loggers.forEach(logger => 
      logger.log(`HTTP ${req.method} ${req.url} - Started`)
    );
    
    return next.handle(req).pipe(
      tap(event => {
        if (event.type === HttpEventType.Response) {
          const elapsed = Date.now() - started;
          this.loggers.forEach(logger => 
            logger.log(`HTTP ${req.method} ${req.url} - Completed in ${elapsed}ms`)
          );
        }
      })
    );
  }
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    // Multi provider for HTTP interceptors
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true },
  ]
};
```

**6. Plugin System with Multi Providers:**
```typescript
// plugin.system.ts
export const PLUGIN_TOKEN = new InjectionToken<Plugin[]>('PLUGIN_TOKEN');

interface Plugin {
  name: string;
  version: string;
  initialize(): void;
  execute(data: any): any;
}

// plugin implementations
@Injectable()
export class ValidationPlugin implements Plugin {
  name = 'ValidationPlugin';
  version = '1.0.0';
  
  initialize(): void {
    console.log('ValidationPlugin initialized');
  }
  
  execute(data: any): any {
    // Validate data
    return { ...data, validated: true };
  }
}

@Injectable()
export class TransformPlugin implements Plugin {
  name = 'TransformPlugin';
  version = '1.0.0';
  
  initialize(): void {
    console.log('TransformPlugin initialized');
  }
  
  execute(data: any): any {
    // Transform data
    return { ...data, transformed: true };
  }
}

// plugin.service.ts
@Injectable({ providedIn: 'root' })
export class PluginService {
  private plugins: Map<string, Plugin> = new Map();
  
  constructor(
    @Inject(PLUGIN_TOKEN) plugins: Plugin[]
  ) {
    plugins.forEach(plugin => {
      plugin.initialize();
      this.plugins.set(plugin.name, plugin);
    });
  }
  
  executePlugin(pluginName: string, data: any): any {
    const plugin = this.plugins.get(pluginName);
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} not found`);
    }
    return plugin.execute(data);
  }
  
  executeAllPlugins(data: any): any {
    let result = data;
    this.plugins.forEach(plugin => {
      result = plugin.execute(result);
    });
    return result;
  }
  
  getAvailablePlugins(): string[] {
    return Array.from(this.plugins.keys());
  }
}

// Register plugins
export const appConfig: ApplicationConfig = {
  providers: [
    { provide: PLUGIN_TOKEN, useClass: ValidationPlugin, multi: true },
    { provide: PLUGIN_TOKEN, useClass: TransformPlugin, multi: true },
  ]
};
```

**7. Configuration Multi Providers:**
```typescript
// config.system.ts
export const CONFIG_TOKEN = new InjectionToken<ConfigProvider[]>('CONFIG_TOKEN');

interface ConfigProvider {
  provide(): Record<string, any>;
  priority: number;
}

@Injectable()
export class DefaultConfigProvider implements ConfigProvider {
  priority = 0;
  
  provide(): Record<string, any> {
    return {
      theme: 'light',
      language: 'en',
      timeout: 5000
    };
  }
}

@Injectable()
export class EnvironmentConfigProvider implements ConfigProvider {
  priority = 10;
  
  provide(): Record<string, any> {
    return {
      apiUrl: environment.production ? 'https://prod-api.com' : 'http://localhost:3000',
      debugMode: !environment.production
    };
  }
}

@Injectable()
export class UserConfigProvider implements ConfigProvider {
  priority = 20;
  
  constructor(private userService: UserService) {}
  
  provide(): Record<string, any> {
    const userPrefs = this.userService.getUserPreferences();
    return {
      theme: userPrefs.theme || 'light',
      language: userPrefs.language || 'en'
    };
  }
}

// config.service.ts
@Injectable({ providedIn: 'root' })
export class ConfigService {
  private config: Record<string, any> = {};
  
  constructor(
    @Inject(CONFIG_TOKEN) private configProviders: ConfigProvider[]
  ) {
    this.loadConfiguration();
  }
  
  private loadConfiguration(): void {
    // Sort by priority (higher priority overrides lower priority)
    const sortedProviders = this.configProviders
      .sort((a, b) => a.priority - b.priority);
    
    // Merge configurations
    sortedProviders.forEach(provider => {
      const config = provider.provide();
      this.config = { ...this.config, ...config };
    });
  }
  
  get<T>(key: string, defaultValue?: T): T {
    return this.config[key] ?? defaultValue;
  }
  
  set(key: string, value: any): void {
    this.config[key] = value;
  }
  
  getAll(): Record<string, any> {
    return { ...this.config };
  }
}
```

**8. Testing with InjectionToken and Multi Providers:**
```typescript
// config.service.spec.ts
describe('ConfigService with Multi Providers', () => {
  let service: ConfigService;
  
  beforeEach(() => {
    const mockConfigProvider1: ConfigProvider = {
      priority: 0,
      provide: () => ({ setting1: 'default', setting2: 'default' })
    };
    
    const mockConfigProvider2: ConfigProvider = {
      priority: 10,
      provide: () => ({ setting1: 'override', setting3: 'new' })
    };
    
    TestBed.configureTestingModule({
      providers: [
        { provide: CONFIG_TOKEN, useValue: mockConfigProvider1, multi: true },
        { provide: CONFIG_TOKEN, useValue: mockConfigProvider2, multi: true },
        ConfigService
      ]
    });
    
    service = TestBed.inject(ConfigService);
  });
  
  it('should merge configurations with priority', () => {
    expect(service.get('setting1')).toBe('override'); // Higher priority wins
    expect(service.get('setting2')).toBe('default');  // Only in provider 1
    expect(service.get('setting3')).toBe('new');      // Only in provider 2
  });
});
```

**Key Benefits:**

**InjectionToken:**
- Type-safe dependency injection for non-class dependencies
- Prevents naming conflicts with string-based tokens
- Better IDE support and refactoring capabilities
- Clear dependency documentation

**Multi Providers:**
- Plugin architecture support
- Flexible configuration systems
- Extensible interceptor chains
- Modular service composition

**Best Practices:**
- Use descriptive token names and provide type information
- Document token purposes and expected values
- Use factory providers for complex initialization
- Test multi provider configurations thoroughly
- Consider provider order and priority when applicable

[Back to Dependency Injection](#dependency-injection)

### 87. Explain injector hierarchy in Angular

**Answer:**
Angular's injector hierarchy is a tree-like structure that determines how dependencies are resolved and shared across different parts of an application. Each injector can provide services and delegates to parent injectors when it cannot resolve a dependency.

**Injector Hierarchy Levels:**

**1. Platform Injector (Root of the Tree):**
```typescript
// Platform-level services (shared across multiple applications)
// Created when Angular starts up

// main.ts
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

// Platform injector is created here
platformBrowserDynamic([
  // Platform-level providers
  { provide: PLATFORM_ID, useValue: 'browser' },
  { provide: DOCUMENT, useFactory: () => document }
]).bootstrapModule(AppModule);

// Or with standalone bootstrap
bootstrapApplication(AppComponent, {
  providers: [
    // These go to the root application injector
    provideRouter(routes),
    provideHttpClient()
  ]
});
```

**2. Application Injector (Root Application Level):**
```typescript
// app.config.ts - Modern standalone approach
export const appConfig: ApplicationConfig = {
  providers: [
    // Root application providers
    provideRouter(routes),
    provideHttpClient(),
    
    // Global services
    { provide: 'API_URL', useValue: 'https://api.example.com' },
    
    // Singleton services
    UserService,
    AuthService,
    
    // Services with providedIn: 'root' are also registered here
  ]
};

// Or traditional NgModule approach
@NgModule({
  providers: [
    UserService,
    AuthService,
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ]
})
export class AppModule {}
```

**3. Module Injector (Feature Module Level):**
```typescript
// feature.module.ts
@NgModule({
  providers: [
    // Module-specific services
    FeatureService,
    { provide: 'FEATURE_CONFIG', useValue: { enabled: true } }
  ],
  declarations: [FeatureComponent],
  imports: [CommonModule]
})
export class FeatureModule {}

// Lazy-loaded module with its own injector
const routes: Routes = [
  {
    path: 'feature',
    loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)
  }
];
```

**4. Component Injector (Component Level):**
```typescript
// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <h1>Parent Component</h1>
    <app-child></app-child>
    <app-child></app-child>
  `,
  providers: [
    // Component-level providers
    // Each component instance gets its own injector
    ComponentLevelService,
    { provide: 'COMPONENT_ID', useValue: 'parent-comp' }
  ]
})
export class ParentComponent {
  constructor(
    private service: ComponentLevelService,
    @Inject('COMPONENT_ID') private componentId: string
  ) {
    console.log('Parent component ID:', componentId);
  }
}

// child.component.ts
@Component({
  selector: 'app-child',
  template: `<p>Child Component: {{childId}}</p>`,
  providers: [
    // Child component providers override parent providers
    { provide: 'COMPONENT_ID', useValue: 'child-comp' }
  ]
})
export class ChildComponent {
  constructor(
    @Inject('COMPONENT_ID') public childId: string,
    private service: ComponentLevelService // Inherited from parent
  ) {}
}
```

**Advanced Injector Hierarchy Examples:**

**5. Hierarchical Service Resolution:**
```typescript
// services/counter.service.ts
@Injectable()
export class CounterService {
  private count = 0;
  
  increment(): void {
    this.count++;
  }
  
  getCount(): number {
    return this.count;
  }
}

// root.component.ts
@Component({
  selector: 'app-root',
  template: `
    <h1>Root Component</h1>
    <p>Root Counter: {{rootCounter.getCount()}}</p>
    <button (click)="rootCounter.increment()">Increment Root</button>
    
    <app-section></app-section>
    <app-section></app-section>
  `,
  providers: [CounterService] // Root component provides CounterService
})
export class RootComponent {
  constructor(public rootCounter: CounterService) {}
}

// section.component.ts
@Component({
  selector: 'app-section',
  template: `
    <div class="section">
      <h2>Section Component</h2>
      <p>Section Counter: {{sectionCounter.getCount()}}</p>
      <button (click)="sectionCounter.increment()">Increment Section</button>
      
      <app-item></app-item>
      <app-item></app-item>
    </div>
  `,
  providers: [CounterService] // Each section has its own CounterService instance
})
export class SectionComponent {
  constructor(public sectionCounter: CounterService) {}
}

// item.component.ts
@Component({
  selector: 'app-item',
  template: `
    <div class="item">
      <p>Item - Section Counter: {{counter.getCount()}}</p>
      <button (click)="counter.increment()">Increment from Item</button>
    </div>
  `
  // No providers - inherits CounterService from parent (SectionComponent)
})
export class ItemComponent {
  constructor(public counter: CounterService) {}
}
```

**6. Injector Tree with @SkipSelf and @Self:**
```typescript
// logger.service.ts
@Injectable()
export class LoggerService {
  constructor(private context: string = 'default') {}
  
  log(message: string): void {
    console.log(`[${this.context}] ${message}`);
  }
}

// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <h2>Parent Component</h2>
    <app-child></app-child>
  `,
  providers: [
    { provide: LoggerService, useValue: new LoggerService('PARENT') }
  ]
})
export class ParentComponent {
  constructor(private logger: LoggerService) {
    this.logger.log('Parent component initialized');
  }
}

// child.component.ts
@Component({
  selector: 'app-child',
  template: `<p>Child Component</p>`,
  providers: [
    { provide: LoggerService, useValue: new LoggerService('CHILD') }
  ]
})
export class ChildComponent {
  constructor(
    // Gets the child's own logger
    @Self() private selfLogger: LoggerService,
    
    // Gets the parent's logger (skips child's logger)
    @SkipSelf() private parentLogger: LoggerService,
    
    // Gets the first available logger (child's logger in this case)
    private defaultLogger: LoggerService
  ) {
    this.selfLogger.log('From self logger');        // [CHILD]
    this.parentLogger.log('From parent logger');    // [PARENT]
    this.defaultLogger.log('From default logger');  // [CHILD]
  }
}
```

**7. Optional Dependencies and Injector Resolution:**
```typescript
// config.service.ts
@Injectable()
export class ConfigService {
  constructor(private config: any) {}
  
  get(key: string): any {
    return this.config[key];
  }
}

// feature.component.ts
@Component({
  selector: 'app-feature',
  template: `<p>Feature Component</p>`
})
export class FeatureComponent {
  constructor(
    // Required dependency - will throw error if not found
    private userService: UserService,
    
    // Optional dependency - will be null if not found
    @Optional() private configService: ConfigService,
    
    // Optional with default value
    @Optional() @Inject('FEATURE_FLAG') private featureFlag: boolean = false,
    
    // Host dependency - looks only in the component's injector
    @Host() @Optional() private hostService: HostService
  ) {
    if (this.configService) {
      console.log('Config service available');
    } else {
      console.log('Config service not available');
    }
  }
}
```

**8. Dynamic Injector Creation:**
```typescript
// dynamic-injector.service.ts
@Injectable({ providedIn: 'root' })
export class DynamicInjectorService {
  constructor(private parentInjector: Injector) {}
  
  createChildInjector(providers: StaticProvider[]): Injector {
    return Injector.create({
      providers: providers,
      parent: this.parentInjector
    });
  }
  
  createIsolatedComponent(componentType: Type<any>, providers: StaticProvider[] = []): ComponentRef<any> {
    // Create a child injector with specific providers
    const childInjector = this.createChildInjector(providers);
    
    // Create component factory resolver
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(componentType);
    
    // Create component with custom injector
    return componentFactory.create(childInjector);
  }
}

// Usage example
@Component({
  selector: 'app-dynamic-host',
  template: `<div #container></div>`
})
export class DynamicHostComponent {
  @ViewChild('container', { read: ViewContainerRef }) container!: ViewContainerRef;
  
  constructor(private dynamicService: DynamicInjectorService) {}
  
  createDynamicComponent(): void {
    // Create component with custom providers
    const providers: StaticProvider[] = [
      { provide: 'DYNAMIC_CONFIG', useValue: { id: Math.random() } },
      { provide: LoggerService, useValue: new LoggerService('DYNAMIC') }
    ];
    
    const componentRef = this.dynamicService.createIsolatedComponent(
      DynamicComponent, 
      providers
    );
    
    this.container.insert(componentRef.hostView);
  }
}
```

**9. Injector Resolution Strategy:**
```typescript
// resolution-demo.service.ts
@Injectable({ providedIn: 'root' })
export class InjectorResolutionDemo {
  constructor(private injector: Injector) {}
  
  demonstrateResolution(): void {
    // Get service from current injector
    const userService = this.injector.get(UserService);
    
    // Get service with fallback
    const optionalService = this.injector.get(OptionalService, null);
    
    // Get token with default value
    const config = this.injector.get('APP_CONFIG', { default: true });
    
    // Check if service exists without creating it
    const hasService = this.injector.get(SomeService, undefined, InjectFlags.Optional);
    
    // Get service only from self (don't check parent)
    const selfOnlyService = this.injector.get(
      LocalService, 
      null, 
      InjectFlags.Self
    );
    
    // Skip self and check parent injectors
    const parentService = this.injector.get(
      ParentService, 
      null, 
      InjectFlags.SkipSelf
    );
  }
}
```

**10. Testing with Injector Hierarchy:**
```typescript
// injector-hierarchy.spec.ts
describe('Injector Hierarchy', () => {
  let fixture: ComponentFixture<TestComponent>;
  let component: TestComponent;
  
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [TestComponent, ChildComponent],
      providers: [
        // Root level provider
        { provide: 'ROOT_SERVICE', useValue: 'root-value' }
      ]
    });
    
    fixture = TestBed.createComponent(TestComponent);
    component = fixture.componentInstance;
  });
  
  it('should resolve dependencies from correct injector level', () => {
    // Test component gets root service
    const rootService = TestBed.inject('ROOT_SERVICE');
    expect(rootService).toBe('root-value');
    
    // Test child component providers override parent
    const childFixture = TestBed.createComponent(ChildComponent);
    const childInjector = childFixture.debugElement.injector;
    
    // If child has its own provider, it should use that
    const childService = childInjector.get('CHILD_SERVICE', null);
    expect(childService).toBeTruthy();
  });
  
  it('should create isolated injector for testing', () => {
    const isolatedInjector = Injector.create({
      providers: [
        { provide: 'TEST_VALUE', useValue: 'isolated' }
      ]
    });
    
    const testValue = isolatedInjector.get('TEST_VALUE');
    expect(testValue).toBe('isolated');
    
    // Should not have access to TestBed providers
    const rootService = isolatedInjector.get('ROOT_SERVICE', null);
    expect(rootService).toBeNull();
  });
});
```

**Injector Resolution Rules:**

1. **Self First**: Check the current injector
2. **Parent Chain**: Walk up the injector tree
3. **Platform Injector**: Final fallback
4. **Error**: Throw if not found (unless optional)

**Key Benefits:**
- **Encapsulation**: Services can be scoped to specific components
- **Flexibility**: Different parts of the app can have different service implementations
- **Performance**: Services are created only when needed
- **Testing**: Easy to override services at different levels

**Best Practices:**
- Use `providedIn: 'root'` for singleton services
- Provide services at the lowest common ancestor level
- Use component providers for component-specific state
- Be careful with service lifecycle and memory management
- Use `@Optional()` for truly optional dependencies

[Back to Dependency Injection](#dependency-injection)

### 88. `providedIn: root` vs `any` vs `platform`

**Answer:**
The `providedIn` property in Angular's `@Injectable` decorator determines where and how a service is registered in the dependency injection system, affecting its scope, lifecycle, and availability across the application.

**1. `providedIn: 'root'` (Application Singleton):**

```typescript
// user.service.ts
@Injectable({ providedIn: 'root' })
export class UserService {
  private currentUser: User | null = null;
  
  constructor(private http: HttpClient) {
    console.log('UserService instance created');
  }
  
  setUser(user: User): void {
    this.currentUser = user;
  }
  
  getUser(): User | null {
    return this.currentUser;
  }
}

// Usage across components
@Component({
  selector: 'app-header',
  template: `<p>Welcome {{userService.getUser()?.name}}</p>`
})
export class HeaderComponent {
  constructor(public userService: UserService) {}
}

@Component({
  selector: 'app-profile',
  template: `<p>Profile: {{userService.getUser()?.email}}</p>`
})
export class ProfileComponent {
  constructor(public userService: UserService) {}
  // Same UserService instance as HeaderComponent
}
```

**Characteristics of `providedIn: 'root'`:**
- Single instance across the entire application
- Registered in the root injector
- Available everywhere without explicit provider configuration
- Tree-shakable (removed if not used)
- Most common choice for application-wide services

**2. `providedIn: 'any'` (Multiple Instances):**

```typescript
// analytics.service.ts
@Injectable({ providedIn: 'any' })
export class AnalyticsService {
  private events: string[] = [];
  
  constructor() {
    console.log('AnalyticsService instance created');
  }
  
  trackEvent(event: string): void {
    this.events.push(event);
    console.log(`Events in this instance: ${this.events.length}`);
  }
  
  getEvents(): string[] {
    return [...this.events];
  }
}

// main.module.ts
@NgModule({
  providers: [AnalyticsService] // Creates instance A
})
export class AppModule {}

// feature.module.ts
@NgModule({
  providers: [AnalyticsService] // Creates instance B (different from A)
})
export class FeatureModule {}

// lazy-loaded.module.ts
@NgModule({
  providers: [AnalyticsService] // Creates instance C (different from A & B)
})
export class LazyLoadedModule {}

// component.ts
@Component({
  selector: 'app-component',
  providers: [AnalyticsService] // Creates instance D (component-scoped)
})
export class MyComponent {
  constructor(private analytics: AnalyticsService) {
    // Gets the closest available instance
  }
}
```

**Characteristics of `providedIn: 'any'`:**
- Multiple instances can exist
- Each injector can have its own instance
- Useful when you want different instances in different modules
- Not tree-shakable
- Less commonly used

**3. `providedIn: 'platform'` (Cross-Application Singleton):**

```typescript
// platform-config.service.ts
@Injectable({ providedIn: 'platform' })
export class PlatformConfigService {
  private config: PlatformConfig;
  
  constructor(@Inject(DOCUMENT) private document: Document) {
    console.log('PlatformConfigService instance created');
    this.config = {
      userAgent: navigator.userAgent,
      language: navigator.language,
      platform: navigator.platform,
      cookieEnabled: navigator.cookieEnabled
    };
  }
  
  getConfig(): PlatformConfig {
    return this.config;
  }
  
  isMobile(): boolean {
    return /Mobile|Android|iPhone|iPad/.test(this.config.userAgent);
  }
}

interface PlatformConfig {
  userAgent: string;
  language: string;
  platform: string;
  cookieEnabled: boolean;
}

// Multiple applications sharing the same platform service
// app1.module.ts
@NgModule({})
export class App1Module {}

// app2.module.ts  
@NgModule({})
export class App2Module {}

// Both apps share the same PlatformConfigService instance
```

**Characteristics of `providedIn: 'platform'`:**
- Single instance across all applications on the same platform
- Registered in the platform injector (highest level)
- Shared between multiple Angular applications
- Useful for platform-specific utilities
- Rarely used in typical applications

**Advanced Examples and Comparisons:**

**4. Comparison with State Management:**

```typescript
// Different scoping strategies for state management

// Global application state
@Injectable({ providedIn: 'root' })
export class GlobalStateService {
  private state = new BehaviorSubject({});
  state$ = this.state.asObservable();
  
  updateState(newState: any): void {
    this.state.next(newState);
  }
}

// Feature-specific state (multiple instances allowed)
@Injectable({ providedIn: 'any' })
export class FeatureStateService {
  private featureState = new BehaviorSubject({});
  state$ = this.featureState.asObservable();
  
  constructor() {
    console.log('New feature state instance created');
  }
}

// Platform-wide configuration
@Injectable({ providedIn: 'platform' })
export class PlatformStateService {
  private platformInfo = {
    startTime: Date.now(),
    sessionId: Math.random().toString(36)
  };
  
  getPlatformInfo() {
    return this.platformInfo;
  }
}
```

**5. Testing Implications:**

```typescript
// Testing services with different providedIn values

describe('Service Scoping', () => {
  describe('providedIn: root', () => {
    let service: GlobalStateService;
    
    beforeEach(() => {
      TestBed.configureTestingModule({});
      service = TestBed.inject(GlobalStateService);
    });
    
    it('should be singleton across tests', () => {
      const service2 = TestBed.inject(GlobalStateService);
      expect(service).toBe(service2);
    });
  });
  
  describe('providedIn: any', () => {
    beforeEach(() => {
      TestBed.configureTestingModule({
        providers: [FeatureStateService]
      });
    });
    
    it('should create new instances', () => {
      const service1 = TestBed.inject(FeatureStateService);
      
      // Create new TestBed module
      TestBed.resetTestingModule();
      TestBed.configureTestingModule({
        providers: [FeatureStateService]
      });
      
      const service2 = TestBed.inject(FeatureStateService);
      expect(service1).not.toBe(service2);
    });
  });
});
```

**6. Migration and Best Practices:**

```typescript
// Migration from providers array to providedIn

// Old way (NgModule providers)
@NgModule({
  providers: [
    UserService,
    { provide: ConfigService, useClass: ConfigService },
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ]
})
export class AppModule {}

// New way (providedIn)
@Injectable({ providedIn: 'root' })
export class UserService {}

@Injectable({ providedIn: 'root' })
export class ConfigService {}

// Interceptors still need to be provided in module/config
export const appConfig: ApplicationConfig = {
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ]
};
```

**7. Dynamic Service Registration:**

```typescript
// Conditional service registration based on environment

// Development logging service
@Injectable({ providedIn: 'any' })
export class DevLoggingService {
  log(message: string): void {
    console.log(`[DEV] ${message}`);
  }
}

// Production logging service  
@Injectable({ providedIn: 'any' })
export class ProdLoggingService {
  log(message: string): void {
    // Send to remote logging service
  }
}

// Factory function for conditional registration
export function loggingServiceFactory(): any {
  return environment.production ? ProdLoggingService : DevLoggingService;
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    {
      provide: 'LoggingService',
      useFactory: loggingServiceFactory
    }
  ]
};
```

**8. Memory Management Considerations:**

```typescript
// Service with cleanup for different scopes

@Injectable({ providedIn: 'root' })
export class WebSocketService implements OnDestroy {
  private connection: WebSocket | null = null;
  
  constructor() {
    this.connect();
  }
  
  private connect(): void {
    this.connection = new WebSocket('ws://localhost:8080');
  }
  
  ngOnDestroy(): void {
    // For root services, this is only called when app shuts down
    if (this.connection) {
      this.connection.close();
    }
  }
}

@Injectable({ providedIn: 'any' })
export class ComponentScopedService implements OnDestroy {
  private subscription: Subscription = new Subscription();
  
  constructor() {
    // Component-scoped services are destroyed with their injector
  }
  
  ngOnDestroy(): void {
    // This will be called when the component is destroyed
    this.subscription.unsubscribe();
  }
}
```

**Summary Table:**

| Scope | Instance Count | Availability | Tree-shakable | Use Case |
|-------|---------------|--------------|---------------|-----------|
| `'root'` | Single (app-wide) | Entire application | Yes | Global services, state management |
| `'any'` | Multiple (per injector) | Where explicitly provided | No | Feature-specific services |
| `'platform'` | Single (platform-wide) | Across all apps | Yes | Platform utilities, shared config |

**Best Practices:**
- Use `'root'` for most application services (90% of cases)
- Use `'any'` when you need different instances in different modules
- Use `'platform'` only for truly platform-wide utilities
- Prefer `providedIn` over module providers for better tree-shaking
- Consider service lifecycle and cleanup requirements
- Test service scoping behavior explicitly

[Back to Dependency Injection](#dependency-injection)

### 89. What is the difference between singleton and transient services?

**Answer:**
Singleton and transient services represent different lifecycle patterns in Angular's dependency injection system. Singletons have one instance shared across the application, while transient services create new instances each time they're requested.

**Singleton Services:**

**1. Basic Singleton Implementation:**
```typescript
// Automatic singleton with providedIn: 'root'
@Injectable({ providedIn: 'root' })
export class SingletonUserService {
  private currentUser: User | null = null;
  private loginCount = 0;
  
  constructor() {
    console.log('SingletonUserService created - this should only appear once');
  }
  
  login(user: User): void {
    this.currentUser = user;
    this.loginCount++;
    console.log(`Login count: ${this.loginCount}`);
  }
  
  getCurrentUser(): User | null {
    return this.currentUser;
  }
  
  getLoginCount(): number {
    return this.loginCount;
  }
}

// Usage across multiple components
@Component({
  selector: 'app-header',
  template: `<p>Welcome {{user?.name}} (Logins: {{loginCount}})</p>`
})
export class HeaderComponent {
  user: User | null;
  loginCount: number;
  
  constructor(private userService: SingletonUserService) {
    this.user = this.userService.getCurrentUser();
    this.loginCount = this.userService.getLoginCount();
  }
}

@Component({
  selector: 'app-profile',
  template: `<p>Profile for {{user?.name}} (Total logins: {{loginCount}})</p>`
})
export class ProfileComponent {
  user: User | null;
  loginCount: number;
  
  constructor(private userService: SingletonUserService) {
    // Same instance as HeaderComponent
    this.user = this.userService.getCurrentUser();
    this.loginCount = this.userService.getLoginCount(); // Same count
  }
}
```

**2. Manual Singleton Pattern:**
```typescript
// Traditional singleton pattern (not recommended in Angular)
export class ManualSingletonService {
  private static instance: ManualSingletonService;
  private data: any[] = [];
  
  private constructor() {
    console.log('ManualSingletonService created');
  }
  
  static getInstance(): ManualSingletonService {
    if (!ManualSingletonService.instance) {
      ManualSingletonService.instance = new ManualSingletonService();
    }
    return ManualSingletonService.instance;
  }
  
  addData(item: any): void {
    this.data.push(item);
  }
  
  getData(): any[] {
    return [...this.data];
  }
}

// Usage (not recommended - use Angular DI instead)
export class SomeComponent {
  private singleton = ManualSingletonService.getInstance();
  
  addItem(item: any): void {
    this.singleton.addData(item);
  }
}
```

**Transient Services:**

**3. Component-Scoped Transient Services:**
```typescript
// Transient service - new instance per component
@Injectable()
export class TransientCounterService {
  private count = 0;
  private instanceId = Math.random().toString(36).substr(2, 9);
  
  constructor() {
    console.log(`TransientCounterService created with ID: ${this.instanceId}`);
  }
  
  increment(): void {
    this.count++;
  }
  
  getCount(): number {
    return this.count;
  }
  
  getInstanceId(): string {
    return this.instanceId;
  }
}

// Each component gets its own instance
@Component({
  selector: 'app-counter-a',
  template: `
    <div>
      <h3>Counter A (ID: {{instanceId}})</h3>
      <p>Count: {{count}}</p>
      <button (click)="increment()">Increment</button>
    </div>
  `,
  providers: [TransientCounterService] // New instance for this component
})
export class CounterAComponent {
  count = 0;
  instanceId: string;
  
  constructor(private counterService: TransientCounterService) {
    this.instanceId = this.counterService.getInstanceId();
  }
  
  increment(): void {
    this.counterService.increment();
    this.count = this.counterService.getCount();
  }
}

@Component({
  selector: 'app-counter-b',
  template: `
    <div>
      <h3>Counter B (ID: {{instanceId}})</h3>
      <p>Count: {{count}}</p>
      <button (click)="increment()">Increment</button>
    </div>
  `,
  providers: [TransientCounterService] // Different instance from Counter A
})
export class CounterBComponent {
  count = 0;
  instanceId: string;
  
  constructor(private counterService: TransientCounterService) {
    this.instanceId = this.counterService.getInstanceId();
  }
  
  increment(): void {
    this.counterService.increment();
    this.count = this.counterService.getCount();
  }
}
```

**4. Factory-Based Transient Services:**
```typescript
// Factory that creates new instances
@Injectable({ providedIn: 'root' })
export class TransientServiceFactory {
  createLogger(context: string): LoggerService {
    return new LoggerService(context);
  }
  
  createHttpClient(baseUrl: string): HttpClientWrapper {
    return new HttpClientWrapper(baseUrl);
  }
}

export class LoggerService {
  private logs: string[] = [];
  
  constructor(private context: string) {
    console.log(`Logger created for context: ${context}`);
  }
  
  log(message: string): void {
    const logEntry = `[${this.context}] ${new Date().toISOString()}: ${message}`;
    this.logs.push(logEntry);
    console.log(logEntry);
  }
  
  getLogs(): string[] {
    return [...this.logs];
  }
}

// Usage
@Component({
  selector: 'app-feature',
  template: `<p>Feature Component</p>`
})
export class FeatureComponent {
  private logger: LoggerService;
  
  constructor(private factory: TransientServiceFactory) {
    // Create new logger instance for this component
    this.logger = this.factory.createLogger('FeatureComponent');
    this.logger.log('Component initialized');
  }
}
```

**Advanced Patterns:**

**5. Singleton with State Management:**
```typescript
@Injectable({ providedIn: 'root' })
export class SingletonStateService {
  private state$ = new BehaviorSubject<AppState>(initialState);
  private subscribers = new Set<string>();
  
  constructor() {
    console.log('SingletonStateService: Managing global state');
  }
  
  getState(): Observable<AppState> {
    return this.state$.asObservable();
  }
  
  updateState(newState: Partial<AppState>): void {
    const currentState = this.state$.value;
    this.state$.next({ ...currentState, ...newState });
    console.log(`State updated, ${this.subscribers.size} subscribers notified`);
  }
  
  subscribe(subscriberId: string): void {
    this.subscribers.add(subscriberId);
  }
  
  unsubscribe(subscriberId: string): void {
    this.subscribers.delete(subscriberId);
  }
}

interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  notifications: Notification[];
}

const initialState: AppState = {
  user: null,
  theme: 'light',
  notifications: []
};
```

**6. Transient with Cleanup:**
```typescript
@Injectable()
export class TransientResourceService implements OnDestroy {
  private resources: Resource[] = [];
  private timers: NodeJS.Timeout[] = [];
  private instanceId = Math.random().toString(36);
  
  constructor() {
    console.log(`TransientResourceService created: ${this.instanceId}`);
  }
  
  allocateResource(type: string): Resource {
    const resource = new Resource(type, this.instanceId);
    this.resources.push(resource);
    
    // Auto-cleanup after 5 minutes
    const timer = setTimeout(() => {
      this.releaseResource(resource.id);
    }, 5 * 60 * 1000);
    
    this.timers.push(timer);
    return resource;
  }
  
  releaseResource(resourceId: string): void {
    const index = this.resources.findIndex(r => r.id === resourceId);
    if (index !== -1) {
      const resource = this.resources[index];
      resource.cleanup();
      this.resources.splice(index, 1);
      console.log(`Resource ${resourceId} released from ${this.instanceId}`);
    }
  }
  
  ngOnDestroy(): void {
    console.log(`Cleaning up TransientResourceService: ${this.instanceId}`);
    
    // Clear all timers
    this.timers.forEach(timer => clearTimeout(timer));
    
    // Release all resources
    this.resources.forEach(resource => resource.cleanup());
    this.resources = [];
  }
}

class Resource {
  id = Math.random().toString(36);
  
  constructor(
    public type: string,
    public ownerId: string
  ) {}
  
  cleanup(): void {
    console.log(`Cleaning up ${this.type} resource ${this.id}`);
  }
}
```

**7. Hybrid Pattern - Singleton Factory for Transients:**
```typescript
// Singleton factory that manages transient instances
@Injectable({ providedIn: 'root' })
export class ConnectionPoolService {
  private connections = new Map<string, DatabaseConnection>();
  private maxConnections = 10;
  
  constructor() {
    console.log('ConnectionPoolService (Singleton) created');
  }
  
  getConnection(database: string): DatabaseConnection {
    const existingConnection = this.connections.get(database);
    
    if (existingConnection && existingConnection.isActive()) {
      return existingConnection;
    }
    
    if (this.connections.size >= this.maxConnections) {
      this.cleanupInactiveConnections();
    }
    
    // Create new transient connection
    const newConnection = new DatabaseConnection(database);
    this.connections.set(database, newConnection);
    
    console.log(`New connection created for ${database}. Total: ${this.connections.size}`);
    return newConnection;
  }
  
  private cleanupInactiveConnections(): void {
    for (const [key, connection] of this.connections) {
      if (!connection.isActive()) {
        connection.close();
        this.connections.delete(key);
      }
    }
  }
  
  getConnectionStats(): { total: number; active: number } {
    const active = Array.from(this.connections.values())
      .filter(conn => conn.isActive()).length;
    
    return {
      total: this.connections.size,
      active
    };
  }
}

class DatabaseConnection {
  private active = true;
  private lastUsed = Date.now();
  
  constructor(private database: string) {
    console.log(`DatabaseConnection created for ${database}`);
  }
  
  query(sql: string): any[] {
    this.lastUsed = Date.now();
    // Simulate database query
    return [];
  }
  
  isActive(): boolean {
    // Connection is inactive after 5 minutes of no use
    return this.active && (Date.now() - this.lastUsed) < 5 * 60 * 1000;
  }
  
  close(): void {
    this.active = false;
    console.log(`Connection to ${this.database} closed`);
  }
}
```

**8. Testing Singleton vs Transient:**
```typescript
describe('Singleton vs Transient Services', () => {
  describe('Singleton Service', () => {
    let service1: SingletonUserService;
    let service2: SingletonUserService;
    
    beforeEach(() => {
      TestBed.configureTestingModule({});
      service1 = TestBed.inject(SingletonUserService);
      service2 = TestBed.inject(SingletonUserService);
    });
    
    it('should return the same instance', () => {
      expect(service1).toBe(service2);
    });
    
    it('should maintain state across injections', () => {
      service1.login({ name: 'John' } as User);
      expect(service2.getCurrentUser()?.name).toBe('John');
    });
  });
  
  describe('Transient Service', () => {
    let fixture1: ComponentFixture<CounterAComponent>;
    let fixture2: ComponentFixture<CounterBComponent>;
    
    beforeEach(() => {
      TestBed.configureTestingModule({
        declarations: [CounterAComponent, CounterBComponent]
      });
      
      fixture1 = TestBed.createComponent(CounterAComponent);
      fixture2 = TestBed.createComponent(CounterBComponent);
    });
    
    it('should create separate instances per component', () => {
      const service1 = fixture1.debugElement.injector.get(TransientCounterService);
      const service2 = fixture2.debugElement.injector.get(TransientCounterService);
      
      expect(service1).not.toBe(service2);
      expect(service1.getInstanceId()).not.toBe(service2.getInstanceId());
    });
    
    it('should maintain separate state per instance', () => {
      const component1 = fixture1.componentInstance;
      const component2 = fixture2.componentInstance;
      
      component1.increment();
      component1.increment();
      component2.increment();
      
      expect(component1.count).toBe(2);
      expect(component2.count).toBe(1);
    });
  });
});
```

**Comparison Summary:**

| Aspect | Singleton | Transient |
|--------|-----------|----------|
| **Instance Count** | One per application | Multiple instances |
| **State Sharing** | Shared across all consumers | Isolated per instance |
| **Memory Usage** | Lower (single instance) | Higher (multiple instances) |
| **Performance** | Better (no creation overhead) | Overhead per creation |
| **Use Cases** | Global state, shared resources | Component-specific logic |
| **Angular Implementation** | `providedIn: 'root'` | Component/module providers |
| **Lifecycle** | Lives for application lifetime | Lives with injector scope |
| **Testing** | Easier to mock globally | Need to mock per component |

**When to Use:**

**Singleton Services:**
- Global application state
- Shared resources (HTTP client, caching)
- Configuration services
- Authentication services
- Logging services

**Transient Services:**
- Component-specific logic
- Stateful UI components
- Resource management per feature
- Isolated data processing
- When you need different configurations per context

[Back to Dependency Injection](#dependency-injection)

### 90. How do you inject dependencies in standalone components?

**Answer:**
Standalone components in Angular can inject dependencies using the same mechanisms as traditional components, but with more flexibility in how providers are configured. They support constructor injection, the `inject()` function, and can define their own providers.

**Basic Dependency Injection in Standalone Components:**

**1. Constructor Injection:**
```typescript
// user.service.ts
@Injectable({ providedIn: 'root' })
export class UserService {
  getUsers(): Observable<User[]> {
    return of([
      { id: 1, name: 'John Doe' },
      { id: 2, name: 'Jane Smith' }
    ]);
  }
}

// standalone-user-list.component.ts
@Component({
  selector: 'app-user-list',
  standalone: true,
  imports: [CommonModule],
  template: `
    <h2>Users</h2>
    <ul>
      <li *ngFor="let user of users$ | async">{{user.name}}</li>
    </ul>
  `
})
export class UserListComponent {
  users$: Observable<User[]>;
  
  constructor(
    private userService: UserService,
    private http: HttpClient,
    private router: Router
  ) {
    this.users$ = this.userService.getUsers();
  }
}
```

**2. Using the `inject()` Function (Angular 14+):**
```typescript
// modern-standalone.component.ts
@Component({
  selector: 'app-modern',
  standalone: true,
  imports: [CommonModule, RouterOutlet],
  template: `
    <h1>Modern Standalone Component</h1>
    <p>Current route: {{currentRoute}}</p>
    <button (click)="loadData()">Load Data</button>
    <div *ngIf="loading">Loading...</div>
    <div *ngFor="let item of data">{{item.name}}</div>
  `
})
export class ModernStandaloneComponent implements OnInit {
  // Inject services using the inject() function
  private userService = inject(UserService);
  private http = inject(HttpClient);
  private router = inject(Router);
  private activatedRoute = inject(ActivatedRoute);
  private destroyRef = inject(DestroyRef);
  
  // Can also inject with options
  private optionalService = inject(OptionalService, { optional: true });
  private logger = inject(LOGGER_TOKEN, { skipSelf: true });
  
  data: any[] = [];
  loading = false;
  currentRoute = '';
  
  ngOnInit(): void {
    this.currentRoute = this.router.url;
    
    // Use takeUntilDestroyed with DestroyRef
    this.activatedRoute.params
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe(params => {
        console.log('Route params changed:', params);
      });
  }
  
  loadData(): void {
    this.loading = true;
    this.userService.getUsers()
      .pipe(
        takeUntilDestroyed(this.destroyRef),
        finalize(() => this.loading = false)
      )
      .subscribe(data => {
        this.data = data;
      });
  }
}
```

**3. Component-Level Providers:**
```typescript
// component-providers.component.ts
@Component({
  selector: 'app-component-providers',
  standalone: true,
  imports: [CommonModule],
  providers: [
    // Component-specific providers
    ComponentScopedService,
    { provide: 'COMPONENT_CONFIG', useValue: { theme: 'dark' } },
    { 
      provide: ApiService, 
      useFactory: () => new ApiService('https://component-api.com') 
    }
  ],
  template: `
    <div class="component-container">
      <h3>Component with Providers</h3>
      <p>Service ID: {{serviceId}}</p>
      <p>Config: {{config | json}}</p>
      <button (click)="makeApiCall()">Call API</button>
    </div>
  `
})
export class ComponentProvidersComponent {
  serviceId: string;
  config: any;
  
  constructor(
    private componentService: ComponentScopedService,
    @Inject('COMPONENT_CONFIG') config: any,
    private apiService: ApiService
  ) {
    this.serviceId = this.componentService.getId();
    this.config = config;
  }
  
  makeApiCall(): void {
    this.apiService.getData().subscribe(data => {
      console.log('API data:', data);
    });
  }
}

@Injectable()
export class ComponentScopedService {
  private id = Math.random().toString(36).substr(2, 9);
  
  getId(): string {
    return this.id;
  }
}
```

**4. Importing Providers from Other Sources:**
```typescript
// feature.providers.ts
export const FEATURE_PROVIDERS = [
  FeatureService,
  { provide: 'FEATURE_CONFIG', useValue: { enabled: true } },
  { provide: HTTP_INTERCEPTORS, useClass: FeatureInterceptor, multi: true }
];

// standalone-with-imports.component.ts
@Component({
  selector: 'app-standalone-with-imports',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    // Import other standalone components
    UserListComponent,
    ModernStandaloneComponent
  ],
  providers: [
    // Import providers from external sources
    ...FEATURE_PROVIDERS,
    // Add component-specific providers
    LocalStorageService
  ],
  template: `
    <div class="feature-container">
      <h2>Feature Component</h2>
      <app-user-list></app-user-list>
      <app-modern></app-modern>
      
      <form [formGroup]="form" (ngSubmit)="onSubmit()">
        <input formControlName="name" placeholder="Name" />
        <button type="submit">Submit</button>
      </form>
    </div>
  `
})
export class StandaloneWithImportsComponent {
  form: FormGroup;
  
  constructor(
    private fb: FormBuilder,
    private featureService: FeatureService,
    private localStorage: LocalStorageService,
    @Inject('FEATURE_CONFIG') private config: any
  ) {
    this.form = this.fb.group({
      name: ['', Validators.required]
    });
  }
  
  onSubmit(): void {
    if (this.form.valid) {
      const data = this.form.value;
      this.featureService.saveData(data);
      this.localStorage.setItem('lastSubmission', JSON.stringify(data));
    }
  }
}
```

**5. Advanced Injection Patterns:**
```typescript
// advanced-injection.component.ts
@Component({
  selector: 'app-advanced-injection',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div>
      <h3>Advanced Injection Patterns</h3>
      <p>Environment: {{environment}}</p>
      <p>Platform: {{platformInfo}}</p>
      <p>Optional service available: {{hasOptionalService}}</p>
      <div *ngFor="let logger of loggers">
        Logger: {{logger.constructor.name}}
      </div>
    </div>
  `
})
export class AdvancedInjectionComponent {
  environment: string;
  platformInfo: string;
  hasOptionalService: boolean;
  loggers: Logger[];
  
  constructor(
    // Inject with different options
    @Inject(ENVIRONMENT) environment: Environment,
    @Inject(PLATFORM_ID) platformId: string,
    @Optional() optionalService: OptionalService | null,
    @Inject(LOGGER_TOKEN) loggers: Logger[],
    
    // Skip self and get from parent
    @SkipSelf() @Optional() parentService: ParentService | null,
    
    // Host injection
    @Host() @Optional() hostService: HostService | null
  ) {
    this.environment = environment.production ? 'production' : 'development';
    this.platformInfo = isPlatformBrowser(platformId) ? 'browser' : 'server';
    this.hasOptionalService = optionalService !== null;
    this.loggers = loggers;
  }
}
```

**6. Functional Injection with `inject()`:**
```typescript
// functional-injection.component.ts
@Component({
  selector: 'app-functional-injection',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div>
      <h3>Functional Injection</h3>
      <button (click)="performAction()">Perform Action</button>
      <div>{{result}}</div>
    </div>
  `
})
export class FunctionalInjectionComponent {
  result = '';
  
  // Create action functions with injected dependencies
  private performApiCall = this.createApiCall();
  private logAction = this.createLogger();
  private validateData = this.createValidator();
  
  performAction(): void {
    const data = { id: 1, name: 'Test' };
    
    if (this.validateData(data)) {
      this.performApiCall(data).subscribe(result => {
        this.result = result;
        this.logAction('Action completed successfully');
      });
    }
  }
  
  private createApiCall(): (data: any) => Observable<string> {
    const http = inject(HttpClient);
    const config = inject('API_CONFIG', { optional: true }) || { baseUrl: '/api' };
    
    return (data: any) => {
      return http.post<string>(`${config.baseUrl}/action`, data);
    };
  }
  
  private createLogger(): (message: string) => void {
    const loggers = inject(LOGGER_TOKEN, { optional: true }) || [];
    
    return (message: string) => {
      loggers.forEach(logger => logger.log(message));
    };
  }
  
  private createValidator(): (data: any) => boolean {
    const validationService = inject(ValidationService, { optional: true });
    
    return (data: any) => {
      return validationService ? validationService.validate(data) : true;
    };
  }
}
```

**7. Injection in Standalone Directives:**
```typescript
// standalone.directive.ts
@Directive({
  selector: '[appHighlight]',
  standalone: true
})
export class HighlightDirective implements OnInit {
  private element = inject(ElementRef);
  private renderer = inject(Renderer2);
  private configService = inject(ConfigService);
  
  @Input() appHighlight = '';
  
  ngOnInit(): void {
    const color = this.appHighlight || this.configService.get('defaultHighlightColor', 'yellow');
    this.renderer.setStyle(this.element.nativeElement, 'background-color', color);
  }
}

// Usage in standalone component
@Component({
  selector: 'app-directive-host',
  standalone: true,
  imports: [HighlightDirective],
  template: `
    <div appHighlight="lightblue">This text is highlighted</div>
    <div appHighlight>This uses default highlight</div>
  `
})
export class DirectiveHostComponent {}
```

**8. Testing Standalone Components with Dependencies:**
```typescript
// standalone-component.spec.ts
describe('StandaloneComponent', () => {
  let component: UserListComponent;
  let fixture: ComponentFixture<UserListComponent>;
  let userService: jasmine.SpyObj<UserService>;
  
  beforeEach(async () => {
    const userServiceSpy = jasmine.createSpyObj('UserService', ['getUsers']);
    
    await TestBed.configureTestingModule({
      imports: [UserListComponent], // Import the standalone component
      providers: [
        { provide: UserService, useValue: userServiceSpy },
        // Override other dependencies as needed
        { provide: HttpClient, useValue: {} },
        { provide: Router, useValue: {} }
      ]
    }).compileComponents();
    
    fixture = TestBed.createComponent(UserListComponent);
    component = fixture.componentInstance;
    userService = TestBed.inject(UserService) as jasmine.SpyObj<UserService>;
  });
  
  it('should create', () => {
    expect(component).toBeTruthy();
  });
  
  it('should load users on init', () => {
    const mockUsers = [{ id: 1, name: 'Test User' }];
    userService.getUsers.and.returnValue(of(mockUsers));
    
    component.ngOnInit();
    
    component.users$.subscribe(users => {
      expect(users).toEqual(mockUsers);
    });
  });
});

// Testing with inject() function
describe('ModernStandaloneComponent', () => {
  let component: ModernStandaloneComponent;
  let fixture: ComponentFixture<ModernStandaloneComponent>;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ModernStandaloneComponent],
      providers: [
        { provide: UserService, useValue: { getUsers: () => of([]) } },
        { provide: HttpClient, useValue: {} },
        { provide: Router, useValue: { url: '/test' } },
        { provide: ActivatedRoute, useValue: { params: of({}) } }
      ]
    }).compileComponents();
    
    fixture = TestBed.createComponent(ModernStandaloneComponent);
    component = fixture.componentInstance;
  });
  
  it('should inject dependencies correctly', () => {
    expect(component).toBeTruthy();
    expect(component.currentRoute).toBe('/test');
  });
});
```

**Key Benefits of Dependency Injection in Standalone Components:**

1. **Simplified Setup**: No need for NgModules to configure providers
2. **Component-Level Providers**: Easy to scope services to specific components
3. **Modern `inject()` Function**: More flexible and functional approach
4. **Better Tree-Shaking**: Only import what you need
5. **Easier Testing**: Direct import and provider configuration
6. **Composition**: Mix and match components with their dependencies

**Best Practices:**
- Use `inject()` function for modern, functional dependency injection
- Leverage component-level providers for component-specific services
- Import only necessary dependencies to improve bundle size
- Use `DestroyRef` with `takeUntilDestroyed` for automatic cleanup
- Test standalone components by importing them directly in TestBed
- Organize providers in separate files for reusability

[Back to Dependency Injection](#dependency-injection)

### 91. What are optional dependencies?

**Answer:**
Optional dependencies in Angular are dependencies that may or may not be available in the injector hierarchy. When marked as optional, Angular won't throw an error if the dependency cannot be resolved, instead injecting `null` or a provided default value.

**Basic Optional Dependencies:**

**1. Using `@Optional()` Decorator:**
```typescript
// logger.service.ts
@Injectable({ providedIn: 'root' })
export class LoggerService {
  log(message: string): void {
    console.log(`[LOG]: ${message}`);
  }
}

// analytics.service.ts (optional dependency)
@Injectable()
export class AnalyticsService {
  track(event: string, data?: any): void {
    console.log(`[ANALYTICS]: ${event}`, data);
  }
}

// component with optional dependencies
@Component({
  selector: 'app-feature',
  template: `
    <div>
      <h3>Feature Component</h3>
      <button (click)="performAction()">Perform Action</button>
      <p>Analytics available: {{hasAnalytics}}</p>
      <p>Config available: {{hasConfig}}</p>
    </div>
  `
})
export class FeatureComponent {
  hasAnalytics: boolean;
  hasConfig: boolean;
  
  constructor(
    private logger: LoggerService, // Required dependency
    @Optional() private analytics: AnalyticsService | null, // Optional service
    @Optional() @Inject('FEATURE_CONFIG') private config: any, // Optional token
  ) {
    this.hasAnalytics = this.analytics !== null;
    this.hasConfig = this.config !== null;
    
    this.logger.log('FeatureComponent initialized');
    
    if (this.analytics) {
      this.analytics.track('component_initialized', { component: 'FeatureComponent' });
    }
  }
  
  performAction(): void {
    this.logger.log('Action performed');
    
    // Safe optional usage
    if (this.analytics) {
      this.analytics.track('action_performed');
    }
    
    // Use config if available
    const actionConfig = this.config?.actions || { enabled: true };
    if (actionConfig.enabled) {
      console.log('Action is enabled by config');
    }
  }
}
```

**2. Optional Dependencies with Default Values:**
```typescript
// config.service.ts
@Injectable({ providedIn: 'root' })
export class ConfigService {
  private config = new Map<string, any>();
  
  get<T>(key: string, defaultValue?: T): T {
    return this.config.get(key) ?? defaultValue;
  }
  
  set(key: string, value: any): void {
    this.config.set(key, value);
  }
}

// component with default values for optional dependencies
@Component({
  selector: 'app-configurable',
  template: `
    <div>
      <h3>Configurable Component</h3>
      <p>Theme: {{theme}}</p>
      <p>Max Items: {{maxItems}}</p>
      <p>Debug Mode: {{debugMode}}</p>
      <button (click)="toggleTheme()">Toggle Theme</button>
    </div>
  `
})
export class ConfigurableComponent {
  theme: string;
  maxItems: number;
  debugMode: boolean;
  
  constructor(
    @Optional() private configService: ConfigService | null,
    @Optional() @Inject('THEME_CONFIG') themeConfig: any = { theme: 'light' },
    @Optional() @Inject('MAX_ITEMS') maxItems: number = 10,
    @Optional() @Inject('DEBUG_MODE') debugMode: boolean = false
  ) {
    // Use ConfigService if available, otherwise use defaults
    this.theme = this.configService?.get('theme') ?? themeConfig.theme;
    this.maxItems = this.configService?.get('maxItems') ?? maxItems;
    this.debugMode = this.configService?.get('debugMode') ?? debugMode;
  }
  
  toggleTheme(): void {
    this.theme = this.theme === 'light' ? 'dark' : 'light';
    
    // Update config service if available
    if (this.configService) {
      this.configService.set('theme', this.theme);
    }
  }
}
```

**3. Optional Dependencies with `inject()` Function:**
```typescript
// modern-optional-injection.component.ts
@Component({
  selector: 'app-modern-optional',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div>
      <h3>Modern Optional Injection</h3>
      <p>Services available:</p>
      <ul>
        <li>Logger: {{services.logger ? '✓' : '✗'}}</li>
        <li>Analytics: {{services.analytics ? '✓' : '✗'}}</li>
        <li>Cache: {{services.cache ? '✓' : '✗'}}</li>
        <li>Notification: {{services.notification ? '✓' : '✗'}}</li>
      </ul>
      <button (click)="performComplexAction()">Perform Complex Action</button>
    </div>
  `
})
export class ModernOptionalComponent {
  // Using inject() with optional flag
  private logger = inject(LoggerService);
  private analytics = inject(AnalyticsService, { optional: true });
  private cache = inject(CacheService, { optional: true });
  private notification = inject(NotificationService, { optional: true });
  
  // Optional injection with custom default
  private config = inject('APP_CONFIG', { optional: true }) ?? {
    retries: 3,
    timeout: 5000
  };
  
  services = {
    logger: !!this.logger,
    analytics: !!this.analytics,
    cache: !!this.cache,
    notification: !!this.notification
  };
  
  performComplexAction(): void {
    this.logger.log('Starting complex action');
    
    // Use analytics if available
    this.analytics?.track('complex_action_started');
    
    // Check cache first if available
    const cacheKey = 'complex_action_result';
    let cachedResult = null;
    
    if (this.cache) {
      cachedResult = this.cache.get(cacheKey);
      if (cachedResult) {
        this.logger.log('Using cached result');
        this.handleResult(cachedResult);
        return;
      }
    }
    
    // Perform actual action
    this.performAction().then(result => {
      // Cache result if caching is available
      if (this.cache) {
        this.cache.set(cacheKey, result, 300000); // 5 minutes TTL
      }
      
      this.handleResult(result);
      
      // Track completion
      this.analytics?.track('complex_action_completed', { result });
    }).catch(error => {
      this.logger.log(`Action failed: ${error.message}`);
      
      // Show notification if available
      if (this.notification) {
        this.notification.error('Action failed', error.message);
      }
      
      this.analytics?.track('complex_action_failed', { error: error.message });
    });
  }
  
  private async performAction(): Promise<any> {
    // Simulate async operation with config
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.2) {
          resolve({ success: true, timestamp: Date.now() });
        } else {
          reject(new Error('Random failure'));
        }
      }, this.config.timeout / 10);
    });
  }
  
  private handleResult(result: any): void {
    this.logger.log(`Action completed: ${JSON.stringify(result)}`);
    
    if (this.notification) {
      this.notification.success('Action completed successfully!');
    }
  }
}
```

**4. Optional Dependencies in Services:**
```typescript
// http.service.ts with optional interceptors
@Injectable({ providedIn: 'root' })
export class HttpService {
  constructor(
    private http: HttpClient,
    @Optional() private authService: AuthService | null,
    @Optional() private loggingService: LoggingService | null,
    @Optional() @Inject('API_BASE_URL') private baseUrl: string = '/api'
  ) {}
  
  get<T>(endpoint: string): Observable<T> {
    const url = `${this.baseUrl}${endpoint}`;
    
    // Log request if logging service is available
    if (this.loggingService) {
      this.loggingService.log(`GET request to ${url}`);
    }
    
    // Add auth headers if auth service is available
    let headers = new HttpHeaders();
    if (this.authService) {
      const token = this.authService.getToken();
      if (token) {
        headers = headers.set('Authorization', `Bearer ${token}`);
      }
    }
    
    return this.http.get<T>(url, { headers }).pipe(
      tap(response => {
        if (this.loggingService) {
          this.loggingService.log(`GET response from ${url}:`, response);
        }
      }),
      catchError(error => {
        if (this.loggingService) {
          this.loggingService.log(`GET error from ${url}:`, error);
        }
        return throwError(() => error);
      })
    );
  }
}
```

**5. Plugin System with Optional Dependencies:**
```typescript
// plugin.system.ts
export interface Plugin {
  name: string;
  initialize(): void;
  process(data: any): any;
}

@Injectable({ providedIn: 'root' })
export class PluginSystemService {
  private plugins = new Map<string, Plugin>();
  
  constructor(
    // Optional plugins that may or may not be available
    @Optional() @Inject('VALIDATION_PLUGIN') validationPlugin: Plugin | null,
    @Optional() @Inject('TRANSFORM_PLUGIN') transformPlugin: Plugin | null,
    @Optional() @Inject('CACHE_PLUGIN') cachePlugin: Plugin | null,
    @Optional() @Inject('AUDIT_PLUGIN') auditPlugin: Plugin | null
  ) {
    // Register available plugins
    if (validationPlugin) {
      this.registerPlugin(validationPlugin);
    }
    
    if (transformPlugin) {
      this.registerPlugin(transformPlugin);
    }
    
    if (cachePlugin) {
      this.registerPlugin(cachePlugin);
    }
    
    if (auditPlugin) {
      this.registerPlugin(auditPlugin);
    }
  }
  
  private registerPlugin(plugin: Plugin): void {
    plugin.initialize();
    this.plugins.set(plugin.name, plugin);
    console.log(`Plugin registered: ${plugin.name}`);
  }
  
  processData(data: any): any {
    let result = data;
    
    // Process data through available plugins
    for (const plugin of this.plugins.values()) {
      result = plugin.process(result);
    }
    
    return result;
  }
  
  getAvailablePlugins(): string[] {
    return Array.from(this.plugins.keys());
  }
  
  hasPlugin(name: string): boolean {
    return this.plugins.has(name);
  }
}
```

**6. Optional Dependencies with Environment-Based Configuration:**
```typescript
// environment-aware.component.ts
@Component({
  selector: 'app-environment-aware',
  template: `
    <div>
      <h3>Environment Aware Component</h3>
      <p>Environment: {{environment}}</p>
      <p>Features available:</p>
      <ul>
        <li>Development Tools: {{features.devTools ? '✓' : '✗'}}</li>
        <li>Analytics: {{features.analytics ? '✓' : '✗'}}</li>
        <li>Error Reporting: {{features.errorReporting ? '✓' : '✗'}}</li>
        <li>Performance Monitoring: {{features.performanceMonitoring ? '✓' : '✗'}}</li>
      </ul>
    </div>
  `
})
export class EnvironmentAwareComponent {
  environment: string;
  features: any;
  
  constructor(
    @Inject('ENVIRONMENT') private env: any,
    
    // Development-only services (optional in production)
    @Optional() private devTools: DevToolsService | null,
    
    // Production-only services (optional in development)
    @Optional() private analytics: AnalyticsService | null,
    @Optional() private errorReporting: ErrorReportingService | null,
    @Optional() private performanceMonitoring: PerformanceMonitoringService | null
  ) {
    this.environment = env.production ? 'production' : 'development';
    
    this.features = {
      devTools: !!this.devTools,
      analytics: !!this.analytics,
      errorReporting: !!this.errorReporting,
      performanceMonitoring: !!this.performanceMonitoring
    };
    
    // Initialize services based on availability
    if (this.devTools && !env.production) {
      this.devTools.enable();
    }
    
    if (this.analytics && env.production) {
      this.analytics.initialize(env.analyticsKey);
    }
    
    if (this.errorReporting && env.production) {
      this.errorReporting.configure({
        apiKey: env.errorReportingKey,
        environment: 'production'
      });
    }
  }
}
```

**7. Testing Optional Dependencies:**
```typescript
// optional-dependencies.spec.ts
describe('Optional Dependencies', () => {
  describe('FeatureComponent', () => {
    let component: FeatureComponent;
    let fixture: ComponentFixture<FeatureComponent>;
    
    describe('with all dependencies', () => {
      beforeEach(() => {
        TestBed.configureTestingModule({
          declarations: [FeatureComponent],
          providers: [
            LoggerService,
            AnalyticsService,
            { provide: 'FEATURE_CONFIG', useValue: { actions: { enabled: true } } }
          ]
        });
        
        fixture = TestBed.createComponent(FeatureComponent);
        component = fixture.componentInstance;
      });
      
      it('should have all optional dependencies', () => {
        expect(component.hasAnalytics).toBe(true);
        expect(component.hasConfig).toBe(true);
      });
    });
    
    describe('without optional dependencies', () => {
      beforeEach(() => {
        TestBed.configureTestingModule({
          declarations: [FeatureComponent],
          providers: [
            LoggerService
            // No AnalyticsService or FEATURE_CONFIG provided
          ]
        });
        
        fixture = TestBed.createComponent(FeatureComponent);
        component = fixture.componentInstance;
      });
      
      it('should handle missing optional dependencies', () => {
        expect(component.hasAnalytics).toBe(false);
        expect(component.hasConfig).toBe(false);
        
        // Should not throw errors
        expect(() => component.performAction()).not.toThrow();
      });
    });
  });
});
```

**Benefits of Optional Dependencies:**

1. **Flexibility**: Components can work with or without certain services
2. **Graceful Degradation**: Features can be disabled when dependencies are unavailable
3. **Environment Adaptation**: Different services for different environments
4. **Plugin Architecture**: Optional plugins can extend functionality
5. **Testing**: Easier to test components without all dependencies
6. **Modular Design**: Reduces coupling between components and services

**Best Practices:**
- Always check for null before using optional dependencies
- Provide meaningful defaults when dependencies are missing
- Use optional dependencies for non-critical features
- Document which dependencies are optional and their effects
- Test both scenarios (with and without optional dependencies)
- Consider using the `inject()` function with `{ optional: true }` for modern code

[Back to Dependency Injection](#dependency-injection)

### 92. How do you create factory providers?

**Answer:**
Factory providers in Angular allow you to create dependencies using a factory function instead of directly instantiating classes. This provides flexibility for complex initialization logic, conditional creation, or dependencies that require runtime configuration.

**Basic Factory Provider:**

**1. Simple Factory Function:**
```typescript
// logger.factory.ts
export function createLogger(): LoggerService {
  const isDevelopment = !environment.production;
  
  if (isDevelopment) {
    return new ConsoleLoggerService();
  } else {
    return new RemoteLoggerService('https://api.example.com/logs');
  }
}

// logger.service.ts
export abstract class LoggerService {
  abstract log(message: string): void;
  abstract error(message: string, error?: any): void;
}

@Injectable()
export class ConsoleLoggerService extends LoggerService {
  log(message: string): void {
    console.log(`[LOG] ${message}`);
  }
  
  error(message: string, error?: any): void {
    console.error(`[ERROR] ${message}`, error);
  }
}

@Injectable()
export class RemoteLoggerService extends LoggerService {
  constructor(private apiUrl: string) {
    super();
  }
  
  log(message: string): void {
    this.sendToServer('log', message);
  }
  
  error(message: string, error?: any): void {
    this.sendToServer('error', message, error);
  }
  
  private sendToServer(level: string, message: string, error?: any): void {
    // Implementation for sending logs to remote server
    fetch(`${this.apiUrl}/${level}`, {
      method: 'POST',
      body: JSON.stringify({ message, error, timestamp: Date.now() })
    });
  }
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    {
      provide: LoggerService,
      useFactory: createLogger
    }
  ]
};
```

**2. Factory with Dependencies:**
```typescript
// http-client.factory.ts
export function createHttpClient(
  http: HttpClient,
  config: ApiConfig,
  authService: AuthService
): HttpClientWrapper {
  return new HttpClientWrapper(http, config, authService);
}

// http-client-wrapper.service.ts
@Injectable()
export class HttpClientWrapper {
  constructor(
    private http: HttpClient,
    private config: ApiConfig,
    private authService: AuthService
  ) {}
  
  get<T>(endpoint: string): Observable<T> {
    const url = `${this.config.baseUrl}${endpoint}`;
    const headers = this.buildHeaders();
    
    return this.http.get<T>(url, { headers }).pipe(
      retry(this.config.retryAttempts),
      timeout(this.config.timeout)
    );
  }
  
  private buildHeaders(): HttpHeaders {
    let headers = new HttpHeaders({
      'Content-Type': 'application/json',
      'API-Version': this.config.apiVersion
    });
    
    const token = this.authService.getToken();
    if (token) {
      headers = headers.set('Authorization', `Bearer ${token}`);
    }
    
    return headers;
  }
}

interface ApiConfig {
  baseUrl: string;
  apiVersion: string;
  timeout: number;
  retryAttempts: number;
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    {
      provide: HttpClientWrapper,
      useFactory: createHttpClient,
      deps: [HttpClient, 'API_CONFIG', AuthService]
    },
    {
      provide: 'API_CONFIG',
      useValue: {
        baseUrl: 'https://api.example.com',
        apiVersion: 'v1',
        timeout: 5000,
        retryAttempts: 3
      }
    }
  ]
};
```

**3. Dynamic Factory Based on Environment:**
```typescript
// storage.factory.ts
export function createStorageService(
  platformId: Object,
  environment: Environment
): StorageService {
  if (isPlatformBrowser(platformId)) {
    if (environment.production) {
      // Use IndexedDB for production
      return new IndexedDBStorageService();
    } else {
      // Use localStorage for development
      return new LocalStorageService();
    }
  } else {
    // Use memory storage for SSR
    return new MemoryStorageService();
  }
}

// storage.service.ts
export abstract class StorageService {
  abstract setItem(key: string, value: any): Promise<void>;
  abstract getItem(key: string): Promise<any>;
  abstract removeItem(key: string): Promise<void>;
  abstract clear(): Promise<void>;
}

@Injectable()
export class LocalStorageService extends StorageService {
  async setItem(key: string, value: any): Promise<void> {
    localStorage.setItem(key, JSON.stringify(value));
  }
  
  async getItem(key: string): Promise<any> {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  }
  
  async removeItem(key: string): Promise<void> {
    localStorage.removeItem(key);
  }
  
  async clear(): Promise<void> {
    localStorage.clear();
  }
}

@Injectable()
export class IndexedDBStorageService extends StorageService {
  private dbName = 'AppStorage';
  private version = 1;
  
  async setItem(key: string, value: any): Promise<void> {
    const db = await this.openDB();
    const transaction = db.transaction(['storage'], 'readwrite');
    const store = transaction.objectStore('storage');
    store.put({ key, value });
  }
  
  async getItem(key: string): Promise<any> {
    const db = await this.openDB();
    const transaction = db.transaction(['storage'], 'readonly');
    const store = transaction.objectStore('storage');
    const result = await store.get(key);
    return result?.value || null;
  }
  
  async removeItem(key: string): Promise<void> {
    const db = await this.openDB();
    const transaction = db.transaction(['storage'], 'readwrite');
    const store = transaction.objectStore('storage');
    store.delete(key);
  }
  
  async clear(): Promise<void> {
    const db = await this.openDB();
    const transaction = db.transaction(['storage'], 'readwrite');
    const store = transaction.objectStore('storage');
    store.clear();
  }
  
  private openDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      
      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains('storage')) {
          db.createObjectStore('storage', { keyPath: 'key' });
        }
      };
    });
  }
}

@Injectable()
export class MemoryStorageService extends StorageService {
  private storage = new Map<string, any>();
  
  async setItem(key: string, value: any): Promise<void> {
    this.storage.set(key, value);
  }
  
  async getItem(key: string): Promise<any> {
    return this.storage.get(key) || null;
  }
  
  async removeItem(key: string): Promise<void> {
    this.storage.delete(key);
  }
  
  async clear(): Promise<void> {
    this.storage.clear();
  }
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    {
      provide: StorageService,
      useFactory: createStorageService,
      deps: [PLATFORM_ID, 'ENVIRONMENT']
    }
  ]
};
```

**4. Factory for Plugin System:**
```typescript
// plugin.factory.ts
export function createPluginManager(
  http: HttpClient,
  config: PluginConfig[]
): PluginManager {
  const manager = new PluginManager();
  
  // Initialize plugins based on configuration
  config.forEach(pluginConfig => {
    const plugin = createPlugin(pluginConfig, http);
    if (plugin) {
      manager.register(plugin);
    }
  });
  
  return manager;
}

function createPlugin(config: PluginConfig, http: HttpClient): Plugin | null {
  switch (config.type) {
    case 'analytics':
      return new AnalyticsPlugin(config.options, http);
    case 'logging':
      return new LoggingPlugin(config.options);
    case 'caching':
      return new CachingPlugin(config.options);
    case 'validation':
      return new ValidationPlugin(config.options);
    default:
      console.warn(`Unknown plugin type: ${config.type}`);
      return null;
  }
}

// plugin.manager.ts
export class PluginManager {
  private plugins = new Map<string, Plugin>();
  
  register(plugin: Plugin): void {
    plugin.initialize();
    this.plugins.set(plugin.getName(), plugin);
    console.log(`Plugin registered: ${plugin.getName()}`);
  }
  
  execute(pluginName: string, data: any): any {
    const plugin = this.plugins.get(pluginName);
    if (!plugin) {
      throw new Error(`Plugin not found: ${pluginName}`);
    }
    return plugin.execute(data);
  }
  
  getAvailablePlugins(): string[] {
    return Array.from(this.plugins.keys());
  }
}

interface Plugin {
  getName(): string;
  initialize(): void;
  execute(data: any): any;
}

interface PluginConfig {
  type: string;
  options: any;
}

// Plugin implementations
class AnalyticsPlugin implements Plugin {
  constructor(
    private options: any,
    private http: HttpClient
  ) {}
  
  getName(): string {
    return 'analytics';
  }
  
  initialize(): void {
    console.log('Analytics plugin initialized');
  }
  
  execute(data: any): any {
    // Send analytics data
    this.http.post(this.options.endpoint, data).subscribe();
    return data;
  }
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    {
      provide: PluginManager,
      useFactory: createPluginManager,
      deps: [HttpClient, 'PLUGIN_CONFIG']
    },
    {
      provide: 'PLUGIN_CONFIG',
      useValue: [
        { type: 'analytics', options: { endpoint: '/api/analytics' } },
        { type: 'logging', options: { level: 'info' } },
        { type: 'caching', options: { ttl: 300000 } }
      ]
    }
  ]
};
```

**5. Async Factory Provider:**
```typescript
// async-factory.ts
export function createAsyncConfigService(): Promise<ConfigService> {
  return fetch('/api/config')
    .then(response => response.json())
    .then(config => {
      return new ConfigService(config);
    })
    .catch(error => {
      console.error('Failed to load config, using defaults:', error);
      return new ConfigService(DEFAULT_CONFIG);
    });
}

const DEFAULT_CONFIG = {
  apiUrl: 'http://localhost:3000',
  timeout: 5000,
  retries: 3
};

@Injectable()
export class ConfigService {
  constructor(private config: any) {}
  
  get(key: string): any {
    return this.config[key];
  }
  
  getAll(): any {
    return { ...this.config };
  }
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    {
      provide: ConfigService,
      useFactory: createAsyncConfigService
    }
  ]
};
```

**6. Factory with Conditional Logic:**
```typescript
// feature-flag.factory.ts
export function createFeatureService(
  http: HttpClient,
  environment: Environment,
  userService: UserService
): FeatureService {
  if (environment.production) {
    return new RemoteFeatureService(http, userService);
  } else {
    return new LocalFeatureService(DEVELOPMENT_FEATURES);
  }
}

const DEVELOPMENT_FEATURES = {
  newDashboard: true,
  betaFeatures: true,
  debugMode: true,
  experimentalUI: true
};

// feature.service.ts
export abstract class FeatureService {
  abstract isEnabled(feature: string): Promise<boolean>;
  abstract getFeatures(): Promise<Record<string, boolean>>;
}

@Injectable()
export class RemoteFeatureService extends FeatureService {
  private cache = new Map<string, { value: boolean; expiry: number }>();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  
  constructor(
    private http: HttpClient,
    private userService: UserService
  ) {
    super();
  }
  
  async isEnabled(feature: string): Promise<boolean> {
    // Check cache first
    const cached = this.cache.get(feature);
    if (cached && Date.now() < cached.expiry) {
      return cached.value;
    }
    
    try {
      const user = await this.userService.getCurrentUser();
      const response = await this.http.get<{ enabled: boolean }>(
        `/api/features/${feature}?userId=${user.id}`
      ).toPromise();
      
      const enabled = response?.enabled || false;
      
      // Cache the result
      this.cache.set(feature, {
        value: enabled,
        expiry: Date.now() + this.CACHE_TTL
      });
      
      return enabled;
    } catch (error) {
      console.error(`Failed to check feature ${feature}:`, error);
      return false;
    }
  }
  
  async getFeatures(): Promise<Record<string, boolean>> {
    try {
      const user = await this.userService.getCurrentUser();
      const response = await this.http.get<Record<string, boolean>>(
        `/api/features?userId=${user.id}`
      ).toPromise();
      
      return response || {};
    } catch (error) {
      console.error('Failed to get features:', error);
      return {};
    }
  }
}

@Injectable()
export class LocalFeatureService extends FeatureService {
  constructor(private features: Record<string, boolean>) {
    super();
  }
  
  async isEnabled(feature: string): Promise<boolean> {
    return this.features[feature] || false;
  }
  
  async getFeatures(): Promise<Record<string, boolean>> {
    return { ...this.features };
  }
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    {
      provide: FeatureService,
      useFactory: createFeatureService,
      deps: [HttpClient, 'ENVIRONMENT', UserService]
    }
  ]
};
```

**7. Testing Factory Providers:**
```typescript
// factory-provider.spec.ts
describe('Factory Providers', () => {
  describe('LoggerService Factory', () => {
    it('should create ConsoleLogger in development', () => {
      const mockEnvironment = { production: false };
      
      TestBed.configureTestingModule({
        providers: [
          {
            provide: LoggerService,
            useFactory: () => createLogger(),
          },
          { provide: 'ENVIRONMENT', useValue: mockEnvironment }
        ]
      });
      
      const logger = TestBed.inject(LoggerService);
      expect(logger).toBeInstanceOf(ConsoleLoggerService);
    });
    
    it('should create RemoteLogger in production', () => {
      const mockEnvironment = { production: true };
      
      TestBed.configureTestingModule({
        providers: [
          {
            provide: LoggerService,
            useFactory: () => createLogger(),
          },
          { provide: 'ENVIRONMENT', useValue: mockEnvironment }
        ]
      });
      
      const logger = TestBed.inject(LoggerService);
      expect(logger).toBeInstanceOf(RemoteLoggerService);
    });
  });
  
  describe('HttpClientWrapper Factory', () => {
    let mockHttp: jasmine.SpyObj<HttpClient>;
    let mockAuthService: jasmine.SpyObj<AuthService>;
    
    beforeEach(() => {
      mockHttp = jasmine.createSpyObj('HttpClient', ['get', 'post']);
      mockAuthService = jasmine.createSpyObj('AuthService', ['getToken']);
      
      TestBed.configureTestingModule({
        providers: [
          {
            provide: HttpClientWrapper,
            useFactory: createHttpClient,
            deps: [HttpClient, 'API_CONFIG', AuthService]
          },
          { provide: HttpClient, useValue: mockHttp },
          { provide: AuthService, useValue: mockAuthService },
          {
            provide: 'API_CONFIG',
            useValue: {
              baseUrl: 'https://test-api.com',
              apiVersion: 'v1',
              timeout: 3000,
              retryAttempts: 2
            }
          }
        ]
      });
    });
    
    it('should create HttpClientWrapper with correct dependencies', () => {
      const wrapper = TestBed.inject(HttpClientWrapper);
      expect(wrapper).toBeInstanceOf(HttpClientWrapper);
    });
  });
});
```

**Benefits of Factory Providers:**

1. **Conditional Creation**: Create different implementations based on runtime conditions
2. **Complex Initialization**: Handle complex setup logic that can't be done in constructors
3. **Dependency Transformation**: Modify or combine dependencies before injection
4. **Async Initialization**: Support for asynchronous setup (though with limitations)
5. **Environment Adaptation**: Different implementations for different environments
6. **Plugin Systems**: Dynamic creation of plugins or extensions

**Best Practices:**
- Keep factory functions pure and predictable
- Use meaningful names for factory functions
- Document the factory logic and its dependencies
- Test both the factory function and the created instances
- Consider using `InjectionToken` for factory configuration
- Handle errors gracefully in factory functions
- Use TypeScript for better type safety in factories

[Back to Dependency Injection](#dependency-injection)

### 93. What is forward reference and when to use it?

**Answer:**
Forward reference (`forwardRef`) in Angular is a utility function that allows you to refer to a class or token that hasn't been defined yet at the time of reference. This is necessary when dealing with circular dependencies or when the referenced entity appears later in the code.

**When Forward References Are Needed:**

**1. Circular Dependencies Between Classes:**
```typescript
// Without forwardRef - This would cause an error
// parent.service.ts
@Injectable({ providedIn: 'root' })
export class ParentService {
  constructor(private childService: ChildService) {} // Error: ChildService not defined yet
}

// child.service.ts  
@Injectable({ providedIn: 'root' })
export class ChildService {
  constructor(private parentService: ParentService) {}
}

// With forwardRef - Correct approach
// parent.service.ts
@Injectable({ providedIn: 'root' })
export class ParentService {
  constructor(
    @Inject(forwardRef(() => ChildService)) 
    private childService: ChildService
  ) {}
  
  getChildData(): any {
    return this.childService.getData();
  }
}

// child.service.ts
@Injectable({ providedIn: 'root' })
export class ChildService {
  constructor(
    @Inject(forwardRef(() => ParentService)) 
    private parentService: ParentService
  ) {}
  
  getData(): any {
    return { message: 'Data from child service' };
  }
  
  getParentInfo(): any {
    // Avoid infinite recursion by not calling parent methods that call back to child
    return { hasParent: true };
  }
}
```

**2. Component and Directive Forward References:**
```typescript
// tree-node.component.ts
@Component({
  selector: 'app-tree-node',
  template: `
    <div class="node">
      <div class="node-content" (click)="toggle()">
        <span>{{node.name}}</span>
        <span *ngIf="hasChildren">({{node.children?.length}} children)</span>
      </div>
      
      <div class="children" *ngIf="expanded && hasChildren">
        <app-tree-node 
          *ngFor="let child of node.children" 
          [node]="child"
          [parentComponent]="this">
        </app-tree-node>
      </div>
    </div>
  `
})
export class TreeNodeComponent {
  @Input() node!: TreeNode;
  @Input() parentComponent?: TreeNodeComponent;
  
  expanded = false;
  
  constructor(
    // Forward reference to inject parent component (optional)
    @Optional() @Inject(forwardRef(() => TreeNodeComponent))
    private parent: TreeNodeComponent | null
  ) {}
  
  get hasChildren(): boolean {
    return this.node.children && this.node.children.length > 0;
  }
  
  toggle(): void {
    this.expanded = !this.expanded;
    
    // Notify parent if available
    if (this.parentComponent) {
      this.parentComponent.onChildToggled(this.node, this.expanded);
    }
  }
  
  onChildToggled(childNode: TreeNode, expanded: boolean): void {
    console.log(`Child ${childNode.name} ${expanded ? 'expanded' : 'collapsed'}`);
  }
}

interface TreeNode {
  name: string;
  children?: TreeNode[];
}
```

**3. Provider Forward References:**
```typescript
// config.token.ts
export const CONFIG_TOKEN = new InjectionToken<ConfigService>('CONFIG_TOKEN');

// config.service.ts
@Injectable({
  providedIn: 'root',
  useFactory: () => new ConfigService(),
})
export class ConfigService {
  private config = new Map<string, any>();
  
  constructor(
    // Forward reference to a service that depends on this service
    @Optional() @Inject(forwardRef(() => ConfigValidatorService))
    private validator: ConfigValidatorService | null
  ) {
    this.loadDefaultConfig();
  }
  
  set(key: string, value: any): void {
    if (this.validator) {
      const isValid = this.validator.validate(key, value);
      if (!isValid) {
        throw new Error(`Invalid config value for ${key}`);
      }
    }
    
    this.config.set(key, value);
  }
  
  get(key: string): any {
    return this.config.get(key);
  }
  
  private loadDefaultConfig(): void {
    this.config.set('theme', 'light');
    this.config.set('language', 'en');
  }
}

// config-validator.service.ts
@Injectable({ providedIn: 'root' })
export class ConfigValidatorService {
  constructor(
    @Inject(forwardRef(() => ConfigService))
    private configService: ConfigService
  ) {}
  
  validate(key: string, value: any): boolean {
    switch (key) {
      case 'theme':
        return ['light', 'dark'].includes(value);
      case 'language':
        return typeof value === 'string' && value.length === 2;
      default:
        return true;
    }
  }
  
  validateAllConfig(): boolean {
    // Access current config without causing circular dependency issues
    const allConfig = this.getAllConfigSafely();
    return Object.entries(allConfig).every(([key, value]) => 
      this.validate(key, value)
    );
  }
  
  private getAllConfigSafely(): Record<string, any> {
    // Safe way to get config without triggering circular calls
    try {
      return {
        theme: this.configService.get('theme'),
        language: this.configService.get('language')
      };
    } catch {
      return {};
    }
  }
}
```

**4. Advanced Forward Reference Patterns:**
```typescript
// plugin.system.ts
export interface Plugin {
  name: string;
  initialize(manager: PluginManager): void;
  execute(data: any): any;
}

@Injectable({ providedIn: 'root' })
export class PluginManager {
  private plugins = new Map<string, Plugin>();
  
  constructor(
    // Forward reference to plugins that need the manager
    @Optional() @Inject(forwardRef(() => 'MANAGED_PLUGINS'))
    private managedPlugins: Plugin[] = []
  ) {
    this.initializeManagedPlugins();
  }
  
  register(plugin: Plugin): void {
    plugin.initialize(this);
    this.plugins.set(plugin.name, plugin);
  }
  
  execute(pluginName: string, data: any): any {
    const plugin = this.plugins.get(pluginName);
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} not found`);
    }
    return plugin.execute(data);
  }
  
  getPlugin(name: string): Plugin | undefined {
    return this.plugins.get(name);
  }
  
  private initializeManagedPlugins(): void {
    this.managedPlugins.forEach(plugin => {
      this.register(plugin);
    });
  }
}

// validation.plugin.ts
@Injectable()
export class ValidationPlugin implements Plugin {
  name = 'validation';
  private manager?: PluginManager;
  
  constructor(
    @Inject(forwardRef(() => PluginManager))
    managerRef: PluginManager
  ) {
    // Store reference but don't use it in constructor to avoid circular calls
    setTimeout(() => {
      this.manager = managerRef;
    });
  }
  
  initialize(manager: PluginManager): void {
    this.manager = manager;
    console.log('ValidationPlugin initialized');
  }
  
  execute(data: any): any {
    // Validate data and potentially use other plugins through manager
    const isValid = this.validateData(data);
    
    if (!isValid && this.manager) {
      // Use another plugin for error handling
      const errorPlugin = this.manager.getPlugin('error-handler');
      if (errorPlugin) {
        return errorPlugin.execute({ error: 'Validation failed', data });
      }
    }
    
    return { ...data, validated: isValid };
  }
  
  private validateData(data: any): boolean {
    return data && typeof data === 'object';
  }
}

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    PluginManager,
    ValidationPlugin,
    {
      provide: 'MANAGED_PLUGINS',
      useFactory: (validationPlugin: ValidationPlugin) => [validationPlugin],
      deps: [ValidationPlugin]
    }
  ]
};
```

**5. Form Control Forward References:**
```typescript
// custom-form-control.component.ts
@Component({
  selector: 'app-custom-form-control',
  template: `
    <div class="custom-control">
      <input 
        [(ngModel)]="value" 
        (blur)="onTouched()"
        (input)="onChange($event.target.value)" />
      
      <div class="validation-errors" *ngIf="showErrors">
        <div *ngFor="let error of errors">{{error}}</div>
      </div>
    </div>
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => CustomFormControlComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => CustomFormControlComponent),
      multi: true
    }
  ]
})
export class CustomFormControlComponent implements ControlValueAccessor, Validator {
  value = '';
  errors: string[] = [];
  showErrors = false;
  
  private onChange = (value: any) => {};
  private onTouched = () => {};
  
  // ControlValueAccessor implementation
  writeValue(value: any): void {
    this.value = value || '';
  }
  
  registerOnChange(fn: (value: any) => void): void {
    this.onChange = fn;
  }
  
  registerOnTouched(fn: () => void): void {
    this.onTouched = () => {
      fn();
      this.showErrors = true;
    };
  }
  
  // Validator implementation
  validate(control: AbstractControl): ValidationErrors | null {
    const value = control.value;
    this.errors = [];
    
    if (!value) {
      this.errors.push('This field is required');
    }
    
    if (value && value.length < 3) {
      this.errors.push('Minimum 3 characters required');
    }
    
    return this.errors.length > 0 ? { customValidation: this.errors } : null;
  }
}
```

**6. Avoiding Forward References (Better Patterns):**
```typescript
// Instead of circular dependencies, use event-driven communication
// event.service.ts
@Injectable({ providedIn: 'root' })
export class EventService {
  private events = new Subject<AppEvent>();
  
  emit(event: AppEvent): void {
    this.events.next(event);
  }
  
  on<T>(eventType: string): Observable<T> {
    return this.events.pipe(
      filter(event => event.type === eventType),
      map(event => event.data as T)
    );
  }
}

interface AppEvent {
  type: string;
  data: any;
}

// parent.service.ts (refactored without forward reference)
@Injectable({ providedIn: 'root' })
export class ParentService {
  constructor(private eventService: EventService) {
    // Listen for child events instead of direct dependency
    this.eventService.on<any>('child-data-updated').subscribe(data => {
      this.handleChildDataUpdate(data);
    });
  }
  
  requestChildData(): void {
    this.eventService.emit({
      type: 'request-child-data',
      data: { requestId: Math.random() }
    });
  }
  
  private handleChildDataUpdate(data: any): void {
    console.log('Child data updated:', data);
  }
}

// child.service.ts (refactored without forward reference)
@Injectable({ providedIn: 'root' })
export class ChildService {
  private data = { message: 'Child data' };
  
  constructor(private eventService: EventService) {
    // Listen for parent requests
    this.eventService.on<any>('request-child-data').subscribe(request => {
      this.sendDataToParent(request.requestId);
    });
  }
  
  updateData(newData: any): void {
    this.data = { ...this.data, ...newData };
    
    // Notify parent of data change
    this.eventService.emit({
      type: 'child-data-updated',
      data: this.data
    });
  }
  
  private sendDataToParent(requestId: string): void {
    this.eventService.emit({
      type: 'child-data-response',
      data: { requestId, data: this.data }
    });
  }
}
```

**7. Testing Forward References:**
```typescript
// forward-ref.spec.ts
describe('Forward References', () => {
  describe('CircularDependencyServices', () => {
    let parentService: ParentService;
    let childService: ChildService;
    
    beforeEach(() => {
      TestBed.configureTestingModule({
        providers: [ParentService, ChildService]
      });
      
      parentService = TestBed.inject(ParentService);
      childService = TestBed.inject(ChildService);
    });
    
    it('should resolve circular dependencies with forwardRef', () => {
      expect(parentService).toBeTruthy();
      expect(childService).toBeTruthy();
    });
    
    it('should allow communication between circular dependencies', () => {
      const childData = parentService.getChildData();
      expect(childData).toEqual({ message: 'Data from child service' });
      
      const parentInfo = childService.getParentInfo();
      expect(parentInfo).toEqual({ hasParent: true });
    });
  });
});
```

**When to Use Forward References:**

✅ **Use forwardRef when:**
- Dealing with unavoidable circular dependencies
- Creating self-referencing components (like tree structures)
- Implementing ControlValueAccessor or Validator interfaces
- Plugin systems where plugins need references to their managers

❌ **Avoid forwardRef when:**
- Dependencies can be restructured to eliminate circularity
- Event-driven communication can replace direct dependencies
- Dependency injection can be moved to a later lifecycle hook
- The circular dependency indicates poor architectural design

**Best Practices:**
- Use forwardRef sparingly - it often indicates architectural issues
- Consider event-driven patterns as alternatives to circular dependencies
- Document why forwardRef is necessary in each case
- Be careful with initialization order in circular dependencies
- Test circular dependencies thoroughly
- Consider lazy loading or factory patterns as alternatives

[Back to Dependency Injection](#dependency-injection)

### 94. How do you handle circular dependencies?

**Answer:**
Circular dependencies occur when two or more classes depend on each other directly or indirectly, creating a dependency cycle. Angular provides several strategies to handle circular dependencies, including `forwardRef`, architectural refactoring, and event-driven patterns.

**Understanding Circular Dependencies:**

**1. Simple Circular Dependency Example:**
```typescript
// This creates a circular dependency - DON'T DO THIS
// service-a.ts
@Injectable({ providedIn: 'root' })
export class ServiceA {
  constructor(private serviceB: ServiceB) {} // ServiceB depends on ServiceA
  
  methodA(): string {
    return 'A: ' + this.serviceB.methodB();
  }
}

// service-b.ts  
@Injectable({ providedIn: 'root' })
export class ServiceB {
  constructor(private serviceA: ServiceA) {} // ServiceA depends on ServiceB
  
  methodB(): string {
    return 'B: ' + this.serviceA.methodA(); // This will cause infinite recursion
  }
}
```

**Solutions for Circular Dependencies:**

**2. Using `forwardRef` (Quick Fix):**
```typescript
// service-a.ts
@Injectable({ providedIn: 'root' })
export class ServiceA {
  constructor(
    @Inject(forwardRef(() => ServiceB)) 
    private serviceB: ServiceB
  ) {}
  
  methodA(): string {
    return 'A: ' + this.serviceB.getDataB();
  }
  
  getDataA(): string {
    return 'Data from A';
  }
}

// service-b.ts
@Injectable({ providedIn: 'root' })
export class ServiceB {
  constructor(
    @Inject(forwardRef(() => ServiceA)) 
    private serviceA: ServiceA
  ) {}
  
  methodB(): string {
    return 'B: ' + this.serviceA.getDataA();
  }
  
  getDataB(): string {
    return 'Data from B';
  }
}
```

**3. Event-Driven Architecture (Recommended):**
```typescript
// event-bus.service.ts
@Injectable({ providedIn: 'root' })
export class EventBusService {
  private eventSubject = new Subject<AppEvent>();
  
  emit(event: AppEvent): void {
    this.eventSubject.next(event);
  }
  
  on<T>(eventType: string): Observable<T> {
    return this.eventSubject.pipe(
      filter(event => event.type === eventType),
      map(event => event.data as T)
    );
  }
  
  once<T>(eventType: string): Observable<T> {
    return this.on<T>(eventType).pipe(take(1));
  }
}

interface AppEvent {
  type: string;
  data: any;
  timestamp?: number;
}

// user.service.ts (no circular dependency)
@Injectable({ providedIn: 'root' })
export class UserService {
  private currentUser: User | null = null;
  
  constructor(private eventBus: EventBusService) {
    // Listen for authentication events
    this.eventBus.on<User>('user-authenticated').subscribe(user => {
      this.setCurrentUser(user);
    });
    
    this.eventBus.on('user-logout').subscribe(() => {
      this.clearCurrentUser();
    });
  }
  
  setCurrentUser(user: User): void {
    this.currentUser = user;
    
    // Emit user change event
    this.eventBus.emit({
      type: 'user-changed',
      data: user,
      timestamp: Date.now()
    });
  }
  
  getCurrentUser(): User | null {
    return this.currentUser;
  }
  
  private clearCurrentUser(): void {
    this.currentUser = null;
    this.eventBus.emit({
      type: 'user-changed',
      data: null,
      timestamp: Date.now()
    });
  }
}

// auth.service.ts (no circular dependency)
@Injectable({ providedIn: 'root' })
export class AuthService {
  constructor(
    private http: HttpClient,
    private eventBus: EventBusService
  ) {
    // Listen for user changes to update auth state
    this.eventBus.on<User>('user-changed').subscribe(user => {
      this.updateAuthState(user);
    });
  }
  
  async login(credentials: LoginCredentials): Promise<User> {
    try {
      const response = await this.http.post<AuthResponse>('/api/login', credentials).toPromise();
      const user = response.user;
      
      // Store token
      localStorage.setItem('auth_token', response.token);
      
      // Emit authentication event
      this.eventBus.emit({
        type: 'user-authenticated',
        data: user,
        timestamp: Date.now()
      });
      
      return user;
    } catch (error) {
      this.eventBus.emit({
        type: 'authentication-failed',
        data: error,
        timestamp: Date.now()
      });
      throw error;
    }
  }
  
  logout(): void {
    localStorage.removeItem('auth_token');
    
    this.eventBus.emit({
      type: 'user-logout',
      data: null,
      timestamp: Date.now()
    });
  }
  
  private updateAuthState(user: User | null): void {
    // Update internal auth state based on user changes
    console.log('Auth state updated for user:', user?.id);
  }
}

interface User {
  id: string;
  name: string;
  email: string;
}

interface LoginCredentials {
  email: string;
  password: string;
}

interface AuthResponse {
  user: User;
  token: string;
}
```

**4. Dependency Inversion with Abstractions:**
```typescript
// Instead of services depending on each other, depend on abstractions

// interfaces/payment.interface.ts
export interface PaymentProvider {
  processPayment(amount: number, currency: string): Promise<PaymentResult>;
}

export interface NotificationProvider {
  sendNotification(message: string, recipient: string): Promise<void>;
}

interface PaymentResult {
  success: boolean;
  transactionId?: string;
  error?: string;
}

// payment.service.ts
@Injectable({ providedIn: 'root' })
export class PaymentService implements PaymentProvider {
  constructor(
    private http: HttpClient,
    private eventBus: EventBusService
  ) {}
  
  async processPayment(amount: number, currency: string): Promise<PaymentResult> {
    try {
      const result = await this.http.post<PaymentResult>('/api/payment', {
        amount,
        currency
      }).toPromise();
      
      // Emit payment event instead of directly calling notification service
      this.eventBus.emit({
        type: 'payment-processed',
        data: { result, amount, currency }
      });
      
      return result;
    } catch (error) {
      this.eventBus.emit({
        type: 'payment-failed',
        data: { error, amount, currency }
      });
      
      throw error;
    }
  }
}

// notification.service.ts
@Injectable({ providedIn: 'root' })
export class NotificationService implements NotificationProvider {
  constructor(
    private http: HttpClient,
    private eventBus: EventBusService
  ) {
    // Listen for payment events
    this.eventBus.on<any>('payment-processed').subscribe(data => {
      this.handlePaymentSuccess(data);
    });
    
    this.eventBus.on<any>('payment-failed').subscribe(data => {
      this.handlePaymentFailure(data);
    });
  }
  
  async sendNotification(message: string, recipient: string): Promise<void> {
    await this.http.post('/api/notifications', {
      message,
      recipient,
      timestamp: Date.now()
    }).toPromise();
  }
  
  private async handlePaymentSuccess(data: any): Promise<void> {
    await this.sendNotification(
      `Payment of ${data.amount} ${data.currency} processed successfully`,
      'user@example.com'
    );
  }
  
  private async handlePaymentFailure(data: any): Promise<void> {
    await this.sendNotification(
      `Payment of ${data.amount} ${data.currency} failed: ${data.error}`,
      'admin@example.com'
    );
  }
}
```

**5. Lazy Injection Pattern:**
```typescript
// lazy-injection.service.ts
@Injectable({ providedIn: 'root' })
export class OrderService {
  private inventoryService?: InventoryService;
  
  constructor(private injector: Injector) {}
  
  async createOrder(items: OrderItem[]): Promise<Order> {
    // Lazy inject the service to break circular dependency
    if (!this.inventoryService) {
      this.inventoryService = this.injector.get(InventoryService);
    }
    
    // Check inventory
    const availabilityCheck = await this.inventoryService.checkAvailability(items);
    
    if (!availabilityCheck.allAvailable) {
      throw new Error('Some items are not available');
    }
    
    // Create order
    const order: Order = {
      id: this.generateOrderId(),
      items,
      status: 'pending',
      createdAt: new Date()
    };
    
    // Reserve inventory
    await this.inventoryService.reserveItems(items);
    
    return order;
  }
  
  private generateOrderId(): string {
    return 'order_' + Math.random().toString(36).substr(2, 9);
  }
}

@Injectable({ providedIn: 'root' })
export class InventoryService {
  private orderService?: OrderService;
  
  constructor(private injector: Injector) {}
  
  async checkAvailability(items: OrderItem[]): Promise<AvailabilityResult> {
    // Check each item's availability
    const results = await Promise.all(
      items.map(item => this.checkItemAvailability(item))
    );
    
    return {
      allAvailable: results.every(r => r.available),
      results
    };
  }
  
  async reserveItems(items: OrderItem[]): Promise<void> {
    // Reserve items in inventory
    for (const item of items) {
      await this.reserveItem(item);
    }
  }
  
  async cancelReservation(orderId: string): Promise<void> {
    // Lazy inject to avoid circular dependency
    if (!this.orderService) {
      this.orderService = this.injector.get(OrderService);
    }
    
    // Logic to cancel reservation
    console.log(`Reservation cancelled for order: ${orderId}`);
  }
  
  private async checkItemAvailability(item: OrderItem): Promise<ItemAvailability> {
    // Simulate availability check
    return {
      itemId: item.id,
      available: Math.random() > 0.1, // 90% availability
      quantity: item.quantity
    };
  }
  
  private async reserveItem(item: OrderItem): Promise<void> {
    // Simulate item reservation
    console.log(`Reserved ${item.quantity} of ${item.id}`);
  }
}

interface OrderItem {
  id: string;
  quantity: number;
  price: number;
}

interface Order {
  id: string;
  items: OrderItem[];
  status: string;
  createdAt: Date;
}

interface AvailabilityResult {
  allAvailable: boolean;
  results: ItemAvailability[];
}

interface ItemAvailability {
  itemId: string;
  available: boolean;
  quantity: number;
}
```

**6. State Management Pattern:**
```typescript
// state.service.ts
@Injectable({ providedIn: 'root' })
export class StateService {
  private state = new BehaviorSubject<AppState>(initialState);
  
  getState(): Observable<AppState> {
    return this.state.asObservable();
  }
  
  updateState(updater: (state: AppState) => AppState): void {
    const currentState = this.state.value;
    const newState = updater(currentState);
    this.state.next(newState);
  }
  
  getCurrentState(): AppState {
    return this.state.value;
  }
}

interface AppState {
  user: User | null;
  cart: CartItem[];
  orders: Order[];
  inventory: InventoryItem[];
}

const initialState: AppState = {
  user: null,
  cart: [],
  orders: [],
  inventory: []
};

// Services that depend on state instead of each other
@Injectable({ providedIn: 'root' })
export class UserStateService {
  constructor(private stateService: StateService) {}
  
  setUser(user: User): void {
    this.stateService.updateState(state => ({
      ...state,
      user
    }));
  }
  
  getUser(): Observable<User | null> {
    return this.stateService.getState().pipe(
      map(state => state.user)
    );
  }
}

@Injectable({ providedIn: 'root' })
export class CartStateService {
  constructor(private stateService: StateService) {}
  
  addToCart(item: CartItem): void {
    this.stateService.updateState(state => ({
      ...state,
      cart: [...state.cart, item]
    }));
  }
  
  getCart(): Observable<CartItem[]> {
    return this.stateService.getState().pipe(
      map(state => state.cart)
    );
  }
}

interface CartItem {
  id: string;
  name: string;
  quantity: number;
  price: number;
}

interface InventoryItem {
  id: string;
  name: string;
  available: number;
}
```

**7. Factory Pattern to Break Cycles:**
```typescript
// service.factory.ts
@Injectable({ providedIn: 'root' })
export class ServiceFactory {
  constructor(private injector: Injector) {}
  
  createOrderProcessor(): OrderProcessor {
    return new OrderProcessor(
      this.injector.get(PaymentService),
      this.injector.get(InventoryService),
      this.injector.get(NotificationService)
    );
  }
  
  createInventoryManager(): InventoryManager {
    return new InventoryManager(
      this.injector.get(OrderService),
      this.injector.get(SupplierService)
    );
  }
}

// order-processor.ts
export class OrderProcessor {
  constructor(
    private paymentService: PaymentService,
    private inventoryService: InventoryService,
    private notificationService: NotificationService
  ) {}
  
  async processOrder(order: Order): Promise<ProcessResult> {
    try {
      // Process payment
      const paymentResult = await this.paymentService.processPayment(
        order.total, 
        order.currency
      );
      
      if (!paymentResult.success) {
        throw new Error('Payment failed');
      }
      
      // Update inventory
      await this.inventoryService.updateStock(order.items);
      
      // Send confirmation
      await this.notificationService.sendNotification(
        'Order confirmed',
        order.customerEmail
      );
      
      return { success: true, orderId: order.id };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}

interface ProcessResult {
  success: boolean;
  orderId?: string;
  error?: string;
}
```

**8. Testing Circular Dependencies:**
```typescript
// circular-dependency.spec.ts
describe('Circular Dependency Handling', () => {
  describe('Event-Driven Pattern', () => {
    let userService: UserService;
    let authService: AuthService;
    let eventBus: EventBusService;
    
    beforeEach(() => {
      TestBed.configureTestingModule({
        providers: [
          UserService,
          AuthService,
          EventBusService,
          { provide: HttpClient, useValue: jasmine.createSpyObj('HttpClient', ['post']) }
        ]
      });
      
      userService = TestBed.inject(UserService);
      authService = TestBed.inject(AuthService);
      eventBus = TestBed.inject(EventBusService);
    });
    
    it('should handle user authentication without circular dependency', async () => {
      const mockUser = { id: '1', name: 'John', email: 'john@example.com' };
      
      // Mock HTTP response
      const httpClient = TestBed.inject(HttpClient) as jasmine.SpyObj<HttpClient>;
      httpClient.post.and.returnValue(of({ user: mockUser, token: 'abc123' }));
      
      // Login user
      await authService.login({ email: 'john@example.com', password: 'password' });
      
      // Check if user was set
      expect(userService.getCurrentUser()).toEqual(mockUser);
    });
  });
  
  describe('Lazy Injection Pattern', () => {
    let orderService: OrderService;
    let inventoryService: InventoryService;
    
    beforeEach(() => {
      TestBed.configureTestingModule({
        providers: [OrderService, InventoryService]
      });
      
      orderService = TestBed.inject(OrderService);
      inventoryService = TestBed.inject(InventoryService);
    });
    
    it('should create services without circular dependency errors', () => {
      expect(orderService).toBeTruthy();
      expect(inventoryService).toBeTruthy();
    });
  });
});
```

**Best Practices for Handling Circular Dependencies:**

**✅ Recommended Approaches:**
1. **Event-Driven Architecture** - Use events/observables for communication
2. **Dependency Inversion** - Depend on abstractions, not concrete implementations
3. **State Management** - Centralize state in a store/service
4. **Lazy Injection** - Inject dependencies when needed, not in constructor
5. **Factory Pattern** - Create objects with complex dependencies

**❌ Avoid When Possible:**
1. **forwardRef** - Should be last resort, indicates architectural issues
2. **Direct circular dependencies** - Refactor to eliminate cycles
3. **Constructor injection for circular deps** - Use lazy injection instead

**Prevention Strategies:**
- Design services with single responsibilities
- Use dependency graphs to visualize relationships
- Implement interfaces for loose coupling
- Consider the direction of data flow in your architecture
- Use linting rules to detect circular dependencies early

[Back to Dependency Injection](#dependency-injection)

### 95. What are injection scopes?

**Answer:**
Injection scopes in Angular determine the lifetime and availability of services within the dependency injection system. Different scopes control where and how long service instances exist, affecting memory usage, performance, and data sharing across the application.

**Angular Injection Scopes:**

**1. Root Scope (`providedIn: 'root'`):**
```typescript
// Global singleton service
@Injectable({ providedIn: 'root' })
export class GlobalConfigService {
  private config = new Map<string, any>();
  private instanceId = Math.random().toString(36);
  
  constructor() {
    console.log(`GlobalConfigService created with ID: ${this.instanceId}`);
    this.loadDefaultConfig();
  }
  
  set(key: string, value: any): void {
    this.config.set(key, value);
    console.log(`Config updated by instance ${this.instanceId}: ${key} = ${value}`);
  }
  
  get(key: string): any {
    return this.config.get(key);
  }
  
  getInstanceId(): string {
    return this.instanceId;
  }
  
  private loadDefaultConfig(): void {
    this.config.set('theme', 'light');
    this.config.set('language', 'en');
    this.config.set('version', '1.0.0');
  }
}

// Usage across multiple components - same instance
@Component({
  selector: 'app-header',
  template: `
    <div>
      <p>Header - Service ID: {{serviceId}}</p>
      <p>Theme: {{theme}}</p>
      <button (click)="changeTheme()">Change Theme</button>
    </div>
  `
})
export class HeaderComponent {
  serviceId: string;
  theme: string;
  
  constructor(private configService: GlobalConfigService) {
    this.serviceId = this.configService.getInstanceId();
    this.theme = this.configService.get('theme');
  }
  
  changeTheme(): void {
    const newTheme = this.theme === 'light' ? 'dark' : 'light';
    this.configService.set('theme', newTheme);
    this.theme = newTheme;
  }
}

@Component({
  selector: 'app-footer',
  template: `
    <div>
      <p>Footer - Service ID: {{serviceId}}</p>
      <p>Theme: {{theme}}</p>
    </div>
  `
})
export class FooterComponent {
  serviceId: string;
  theme: string;
  
  constructor(private configService: GlobalConfigService) {
    // Same instance as HeaderComponent
    this.serviceId = this.configService.getInstanceId();
    this.theme = this.configService.get('theme');
  }
}
```

**2. Platform Scope (`providedIn: 'platform'`):**
```typescript
// Platform-wide service shared across multiple Angular apps
@Injectable({ providedIn: 'platform' })
export class PlatformAnalyticsService {
  private events: AnalyticsEvent[] = [];
  private sessionId = `session_${Date.now()}_${Math.random().toString(36)}`;
  
  constructor(
    @Inject(PLATFORM_ID) private platformId: Object,
    @Inject(DOCUMENT) private document: Document
  ) {
    console.log(`PlatformAnalyticsService created for platform: ${platformId}`);
    this.initializeTracking();
  }
  
  track(event: string, data?: any): void {
    const analyticsEvent: AnalyticsEvent = {
      event,
      data,
      timestamp: Date.now(),
      sessionId: this.sessionId,
      url: this.document.location.href,
      userAgent: navigator.userAgent
    };
    
    this.events.push(analyticsEvent);
    console.log('Analytics event tracked:', analyticsEvent);
  }
  
  getEvents(): AnalyticsEvent[] {
    return [...this.events];
  }
  
  getSessionId(): string {
    return this.sessionId;
  }
  
  private initializeTracking(): void {
    if (isPlatformBrowser(this.platformId)) {
      // Browser-specific tracking setup
      this.track('platform_initialized', { platform: 'browser' });
    } else {
      // Server-specific tracking setup
      this.track('platform_initialized', { platform: 'server' });
    }
  }
}

interface AnalyticsEvent {
  event: string;
  data?: any;
  timestamp: number;
  sessionId: string;
  url: string;
  userAgent: string;
}
```

**3. Module Scope:**
```typescript
// Feature module with its own service scope
@NgModule({
  providers: [
    // Module-scoped service
    FeatureScopedService,
    { provide: 'FEATURE_CONFIG', useValue: { featureName: 'Advanced Features' } }
  ],
  declarations: [FeatureComponent, FeatureChildComponent],
  imports: [CommonModule]
})
export class FeatureModule {}

@Injectable()
export class FeatureScopedService {
  private data = new Map<string, any>();
  private instanceId = Math.random().toString(36);
  
  constructor(@Inject('FEATURE_CONFIG') private config: any) {
    console.log(`FeatureScopedService created for ${config.featureName} with ID: ${this.instanceId}`);
  }
  
  setData(key: string, value: any): void {
    this.data.set(key, value);
  }
  
  getData(key: string): any {
    return this.data.get(key);
  }
  
  getInstanceId(): string {
    return this.instanceId;
  }
}

// Components within the same module share the service instance
@Component({
  selector: 'app-feature',
  template: `
    <div>
      <h3>Feature Component</h3>
      <p>Service ID: {{serviceId}}</p>
      <input [(ngModel)]="inputValue" placeholder="Enter value" />
      <button (click)="saveData()">Save</button>
      <app-feature-child></app-feature-child>
    </div>
  `
})
export class FeatureComponent {
  serviceId: string;
  inputValue = '';
  
  constructor(private featureService: FeatureScopedService) {
    this.serviceId = this.featureService.getInstanceId();
  }
  
  saveData(): void {
    this.featureService.setData('userInput', this.inputValue);
  }
}

@Component({
  selector: 'app-feature-child',
  template: `
    <div>
      <h4>Feature Child Component</h4>
      <p>Service ID: {{serviceId}}</p>
      <p>Shared Data: {{sharedData}}</p>
    </div>
  `
})
export class FeatureChildComponent {
  serviceId: string;
  sharedData: string = '';
  
  constructor(private featureService: FeatureScopedService) {
    // Same instance as parent component
    this.serviceId = this.featureService.getInstanceId();
    
    // Access shared data
    setInterval(() => {
      this.sharedData = this.featureService.getData('userInput') || 'No data';
    }, 1000);
  }
}
```

**4. Component Scope:**
```typescript
// Component-scoped service - new instance per component
@Injectable()
export class ComponentScopedDataService {
  private data: any[] = [];
  private instanceId = Math.random().toString(36);
  
  constructor() {
    console.log(`ComponentScopedDataService created with ID: ${this.instanceId}`);
  }
  
  addItem(item: any): void {
    this.data.push({ ...item, id: Math.random(), timestamp: Date.now() });
  }
  
  getItems(): any[] {
    return [...this.data];
  }
  
  getInstanceId(): string {
    return this.instanceId;
  }
  
  clearData(): void {
    this.data = [];
  }
}

@Component({
  selector: 'app-isolated-component',
  template: `
    <div class="isolated-component">
      <h3>Isolated Component {{componentId}}</h3>
      <p>Service Instance ID: {{serviceId}}</p>
      <p>Items Count: {{items.length}}</p>
      
      <input [(ngModel)]="newItem" placeholder="Add item" />
      <button (click)="addItem()">Add</button>
      <button (click)="clearItems()">Clear</button>
      
      <ul>
        <li *ngFor="let item of items">{{item.name}} ({{item.timestamp | date:'short'}})</li>
      </ul>
    </div>
  `,
  providers: [ComponentScopedDataService] // Each component gets its own instance
})
export class IsolatedComponent implements OnInit {
  @Input() componentId!: string;
  
  serviceId: string;
  items: any[] = [];
  newItem = '';
  
  constructor(private dataService: ComponentScopedDataService) {
    this.serviceId = this.dataService.getInstanceId();
  }
  
  ngOnInit(): void {
    this.refreshItems();
  }
  
  addItem(): void {
    if (this.newItem.trim()) {
      this.dataService.addItem({ name: this.newItem });
      this.newItem = '';
      this.refreshItems();
    }
  }
  
  clearItems(): void {
    this.dataService.clearData();
    this.refreshItems();
  }
  
  private refreshItems(): void {
    this.items = this.dataService.getItems();
  }
}

// Parent component using multiple isolated components
@Component({
  selector: 'app-parent',
  template: `
    <div>
      <h2>Parent Component</h2>
      <p>Each child component has its own service instance:</p>
      
      <div class="components-container">
        <app-isolated-component componentId="A"></app-isolated-component>
        <app-isolated-component componentId="B"></app-isolated-component>
        <app-isolated-component componentId="C"></app-isolated-component>
      </div>
    </div>
  `
})
export class ParentComponent {}
```

**5. Custom Injection Scopes with Providers:**
```typescript
// Custom scope using injection tokens
export const FEATURE_SCOPE = new InjectionToken<string>('FEATURE_SCOPE');

@Injectable()
export class ScopedCacheService {
  private cache = new Map<string, CacheEntry>();
  private scopeId: string;
  
  constructor(@Inject(FEATURE_SCOPE) scope: string) {
    this.scopeId = scope;
    console.log(`ScopedCacheService created for scope: ${scope}`);
  }
  
  set(key: string, value: any, ttl: number = 300000): void {
    this.cache.set(key, {
      value,
      expiry: Date.now() + ttl,
      scope: this.scopeId
    });
  }
  
  get(key: string): any {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return null;
    }
    
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.value;
  }
  
  getScopeId(): string {
    return this.scopeId;
  }
  
  clearScope(): void {
    this.cache.clear();
  }
}

interface CacheEntry {
  value: any;
  expiry: number;
  scope: string;
}

// Different scopes for the same service
@Component({
  selector: 'app-user-dashboard',
  template: `
    <div>
      <h3>User Dashboard (Scope: {{cacheScope}})</h3>
      <button (click)="cacheUserData()">Cache User Data</button>
      <button (click)="getCachedData()">Get Cached Data</button>
      <p>Cached Data: {{cachedData | json}}</p>
    </div>
  `,
  providers: [
    { provide: FEATURE_SCOPE, useValue: 'user-dashboard' },
    ScopedCacheService
  ]
})
export class UserDashboardComponent {
  cacheScope: string;
  cachedData: any = null;
  
  constructor(private cacheService: ScopedCacheService) {
    this.cacheScope = this.cacheService.getScopeId();
  }
  
  cacheUserData(): void {
    const userData = {
      id: 1,
      name: 'John Doe',
      preferences: { theme: 'dark', language: 'en' },
      timestamp: Date.now()
    };
    
    this.cacheService.set('userData', userData);
  }
  
  getCachedData(): void {
    this.cachedData = this.cacheService.get('userData');
  }
}

@Component({
  selector: 'app-admin-panel',
  template: `
    <div>
      <h3>Admin Panel (Scope: {{cacheScope}})</h3>
      <button (click)="cacheAdminData()">Cache Admin Data</button>
      <button (click)="getCachedData()">Get Cached Data</button>
      <p>Cached Data: {{cachedData | json}}</p>
    </div>
  `,
  providers: [
    { provide: FEATURE_SCOPE, useValue: 'admin-panel' },
    ScopedCacheService // Different instance with different scope
  ]
})
export class AdminPanelComponent {
  cacheScope: string;
  cachedData: any = null;
  
  constructor(private cacheService: ScopedCacheService) {
    this.cacheScope = this.cacheService.getScopeId();
  }
  
  cacheAdminData(): void {
    const adminData = {
      adminId: 'admin_123',
      permissions: ['read', 'write', 'delete'],
      lastLogin: Date.now()
    };
    
    this.cacheService.set('adminData', adminData);
  }
  
  getCachedData(): void {
    this.cachedData = this.cacheService.get('adminData');
  }
}
```

**6. Lazy-Loaded Module Scopes:**
```typescript
// Lazy-loaded feature with its own service scope
// feature-routing.module.ts
const routes: Routes = [
  {
    path: 'feature',
    loadChildren: () => import('./feature/feature.module').then(m => m.LazyFeatureModule)
  }
];

// lazy-feature.module.ts
@NgModule({
  providers: [
    // Services scoped to this lazy-loaded module
    LazyFeatureService,
    { provide: 'LAZY_CONFIG', useValue: { moduleName: 'LazyFeature' } }
  ],
  declarations: [LazyFeatureComponent],
  imports: [CommonModule, RouterModule.forChild([
    { path: '', component: LazyFeatureComponent }
  ])]
})
export class LazyFeatureModule {}

@Injectable()
export class LazyFeatureService {
  private moduleData = new Map<string, any>();
  private loadTime = Date.now();
  
  constructor(@Inject('LAZY_CONFIG') private config: any) {
    console.log(`LazyFeatureService created for ${config.moduleName} at ${this.loadTime}`);
  }
  
  setModuleData(key: string, value: any): void {
    this.moduleData.set(key, value);
  }
  
  getModuleData(key: string): any {
    return this.moduleData.get(key);
  }
  
  getLoadTime(): number {
    return this.loadTime;
  }
}
```

**7. Testing Different Scopes:**
```typescript
// injection-scopes.spec.ts
describe('Injection Scopes', () => {
  describe('Root Scope', () => {
    let service1: GlobalConfigService;
    let service2: GlobalConfigService;
    
    beforeEach(() => {
      TestBed.configureTestingModule({});
      service1 = TestBed.inject(GlobalConfigService);
      service2 = TestBed.inject(GlobalConfigService);
    });
    
    it('should provide singleton instance', () => {
      expect(service1).toBe(service2);
      expect(service1.getInstanceId()).toBe(service2.getInstanceId());
    });
    
    it('should share state across instances', () => {
      service1.set('testKey', 'testValue');
      expect(service2.get('testKey')).toBe('testValue');
    });
  });
  
  describe('Component Scope', () => {
    let fixture1: ComponentFixture<IsolatedComponent>;
    let fixture2: ComponentFixture<IsolatedComponent>;
    let service1: ComponentScopedDataService;
    let service2: ComponentScopedDataService;
    
    beforeEach(() => {
      TestBed.configureTestingModule({
        declarations: [IsolatedComponent],
        imports: [FormsModule]
      });
      
      fixture1 = TestBed.createComponent(IsolatedComponent);
      fixture2 = TestBed.createComponent(IsolatedComponent);
      
      service1 = fixture1.debugElement.injector.get(ComponentScopedDataService);
      service2 = fixture2.debugElement.injector.get(ComponentScopedDataService);
    });
    
    it('should provide separate instances per component', () => {
      expect(service1).not.toBe(service2);
      expect(service1.getInstanceId()).not.toBe(service2.getInstanceId());
    });
    
    it('should maintain separate state per component', () => {
      service1.addItem({ name: 'Item 1' });
      service2.addItem({ name: 'Item 2' });
      
      expect(service1.getItems().length).toBe(1);
      expect(service2.getItems().length).toBe(1);
      expect(service1.getItems()[0].name).toBe('Item 1');
      expect(service2.getItems()[0].name).toBe('Item 2');
    });
  });
});
```

**Scope Summary:**

| Scope | Lifetime | Instance Count | Use Case |
|-------|----------|----------------|----------|
| **Root** | Application | Single | Global services, state management |
| **Platform** | Platform | Single (cross-app) | Platform utilities, SSR/browser detection |
| **Module** | Module | One per module | Feature-specific services |
| **Component** | Component | One per component | Component-specific state |
| **Custom** | Defined scope | Configurable | Specialized scoping needs |

**Best Practices:**
- Use root scope for singleton services that need to be shared globally
- Use component scope for services that manage component-specific state
- Use module scope for feature-specific services in lazy-loaded modules
- Consider memory implications of different scopes
- Test scope behavior to ensure correct service lifecycle
- Document the intended scope for each service
- Use custom scopes sparingly and only when built-in scopes don't fit

[Back to Dependency Injection](#dependency-injection)

### 96. What are standalone components vs NgModules?

**Answer:**
Standalone components (introduced in Angular 14) are self-contained components that don't need to be declared in NgModules. They can import dependencies directly and simplify Angular application architecture.

**Traditional NgModule Approach:**

```typescript
// user.module.ts
@NgModule({
  declarations: [
    UserListComponent,
    UserCardComponent,
    UserFormComponent
  ],
  imports: [
    CommonModule,
    ReactiveFormsModule,
    HttpClientModule,
    RouterModule
  ],
  providers: [
    UserService,
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ],
  exports: [UserListComponent]
})
export class UserModule {}

// user-list.component.ts
@Component({
  selector: 'app-user-list',
  templateUrl: './user-list.component.html',
  styleUrls: ['./user-list.component.scss']
})
export class UserListComponent {
  constructor(private userService: UserService) {}
}

// app.module.ts
@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    UserModule, // Import the feature module
    AppRoutingModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}
```

**Standalone Components Approach:**

```typescript
// user-list.component.ts
@Component({
  selector: 'app-user-list',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    UserCardComponent,
    UserFormComponent
  ],
  providers: [UserService],
  templateUrl: './user-list.component.html',
  styleUrls: ['./user-list.component.scss']
})
export class UserListComponent {
  constructor(private userService: UserService) {}
}

// user-card.component.ts
@Component({
  selector: 'app-user-card',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="user-card">
      <h3>{{user.name}}</h3>
      <p>{{user.email}}</p>
      <button (click)="onEdit()">Edit</button>
    </div>
  `
})
export class UserCardComponent {
  @Input() user!: User;
  @Output() edit = new EventEmitter<User>();
  
  onEdit(): void {
    this.edit.emit(this.user);
  }
}

// main.ts - Bootstrap standalone component
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { provideRouter } from '@angular/router';
import { provideHttpClient } from '@angular/common/http';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes),
    provideHttpClient(),
    // Global providers
    UserService,
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ]
}).catch(err => console.error(err));
```

**Routing with Standalone Components:**

```typescript
// app.routes.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'users',
    loadComponent: () => import('./user/user-list.component').then(m => m.UserListComponent)
  },
  {
    path: 'user/:id',
    loadComponent: () => import('./user/user-detail.component').then(m => m.UserDetailComponent)
  },
  {
    path: 'dashboard',
    loadChildren: () => import('./dashboard/dashboard.routes').then(m => m.dashboardRoutes)
  }
];

// dashboard.routes.ts
import { Routes } from '@angular/router';

export const dashboardRoutes: Routes = [
  {
    path: '',
    loadComponent: () => import('./dashboard.component').then(m => m.DashboardComponent),
    children: [
      {
        path: 'analytics',
        loadComponent: () => import('./analytics.component').then(m => m.AnalyticsComponent)
      },
      {
        path: 'reports',
        loadComponent: () => import('./reports.component').then(m => m.ReportsComponent)
      }
    ]
  }
];
```

**Hybrid Approach (Mixing Standalone and Modules):**

```typescript
// feature.module.ts - Traditional module
@NgModule({
  declarations: [LegacyComponent],
  imports: [
    CommonModule,
    // Import standalone component in module
    ModernStandaloneComponent
  ],
  exports: [LegacyComponent, ModernStandaloneComponent]
})
export class FeatureModule {}

// modern-standalone.component.ts
@Component({
  selector: 'app-modern',
  standalone: true,
  imports: [
    CommonModule,
    // Import module in standalone component
    FeatureModule
  ],
  template: `
    <div>
      <h2>Modern Standalone Component</h2>
      <app-legacy></app-legacy>
    </div>
  `
})
export class ModernStandaloneComponent {}
```

**Advanced Standalone Component Patterns:**

```typescript
// shared-standalone.component.ts
@Component({
  selector: 'app-shared-button',
  standalone: true,
  imports: [CommonModule],
  template: `
    <button 
      [class]="buttonClass" 
      [disabled]="disabled"
      (click)="onClick()">
      <ng-content></ng-content>
    </button>
  `,
  styles: [`
    .primary { background: blue; color: white; }
    .secondary { background: gray; color: black; }
    .danger { background: red; color: white; }
  `]
})
export class SharedButtonComponent {
  @Input() variant: 'primary' | 'secondary' | 'danger' = 'primary';
  @Input() disabled = false;
  @Output() click = new EventEmitter<void>();
  
  get buttonClass(): string {
    return this.variant;
  }
  
  onClick(): void {
    if (!this.disabled) {
      this.click.emit();
    }
  }
}

// app.component.ts - Using standalone components
@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    CommonModule,
    RouterOutlet,
    SharedButtonComponent,
    UserListComponent
  ],
  template: `
    <div class="app">
      <nav>
        <app-shared-button variant="primary" (click)="navigateToUsers()">
          Users
        </app-shared-button>
        <app-shared-button variant="secondary" (click)="navigateToDashboard()">
          Dashboard
        </app-shared-button>
      </nav>
      
      <main>
        <router-outlet></router-outlet>
      </main>
    </div>
  `
})
export class AppComponent {
  constructor(private router: Router) {}
  
  navigateToUsers(): void {
    this.router.navigate(['/users']);
  }
  
  navigateToDashboard(): void {
    this.router.navigate(['/dashboard']);
  }
}
```

**Comparison Table:**

| Aspect | NgModules | Standalone Components |
|--------|-----------|----------------------|
| **Setup Complexity** | High (module declarations) | Low (direct imports) |
| **Bundle Size** | Larger (module overhead) | Smaller (tree-shakable) |
| **Code Organization** | Module-based grouping | Component-based grouping |
| **Lazy Loading** | Module-level | Component-level |
| **Dependency Management** | Centralized in modules | Distributed per component |
| **Learning Curve** | Steeper | Gentler |
| **Migration** | Requires module refactoring | Gradual adoption possible |
| **Tree Shaking** | Limited | Excellent |

**Migration Strategy:**

```typescript
// Step 1: Convert leaf components first
@Component({
  selector: 'app-user-card',
  standalone: true, // Add standalone flag
  imports: [CommonModule], // Move imports here
  // Remove from module declarations
  templateUrl: './user-card.component.html'
})
export class UserCardComponent {}

// Step 2: Update parent components
@Component({
  selector: 'app-user-list',
  standalone: true,
  imports: [
    CommonModule,
    UserCardComponent // Import standalone child
  ],
  templateUrl: './user-list.component.html'
})
export class UserListComponent {}

// Step 3: Update routing
const routes: Routes = [
  {
    path: 'users',
    loadComponent: () => import('./user-list.component').then(m => m.UserListComponent)
  }
];

// Step 4: Remove empty modules
// Delete user.module.ts when all components are standalone
```

**Best Practices:**

**For Standalone Components:**
- Use for new applications and components
- Import only what you need per component
- Leverage lazy loading at component level
- Group related standalone components in feature folders

**For NgModules:**
- Keep for existing large applications
- Use for complex feature organization
- Maintain for shared functionality across multiple components
- Consider for third-party library integration

**When to Choose:**

**Choose Standalone Components when:**
- Starting new Angular applications
- Want simpler architecture
- Need better tree-shaking
- Prefer component-level dependency management
- Want to reduce boilerplate code

**Choose NgModules when:**
- Working with existing large applications
- Need complex feature organization
- Have many interdependent components
- Require centralized configuration
- Team prefers module-based architecture

[Back to Components and Templates](#components-and-templates)

### 97. How do you handle component communication?

**Answer:**
Angular provides multiple patterns for component communication depending on the relationship between components and the complexity of data flow.

**1. Parent-Child Communication (@Input/@Output):**

```typescript
// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <div>
      <h2>Parent Component</h2>
      <app-child 
        [userData]="user"
        [config]="childConfig"
        (userUpdated)="onUserUpdated($event)"
        (statusChange)="onStatusChange($event)">
      </app-child>
    </div>
  `
})
export class ParentComponent {
  user: User = { id: 1, name: 'John', email: 'john@example.com' };
  childConfig = { editable: true, showAvatar: true };
  
  onUserUpdated(updatedUser: User): void {
    this.user = updatedUser;
    console.log('User updated:', updatedUser);
  }
  
  onStatusChange(status: string): void {
    console.log('Status changed:', status);
  }
}

// child.component.ts
@Component({
  selector: 'app-child',
  template: `
    <div class="child-component">
      <h3>Child Component</h3>
      <div *ngIf="config.showAvatar" class="avatar">👤</div>
      
      <input 
        [(ngModel)]="userData.name" 
        [readonly]="!config.editable"
        (blur)="onNameChange()" />
      
      <button (click)="updateUser()" [disabled]="!config.editable">
        Update User
      </button>
      
      <button (click)="changeStatus('active')">Set Active</button>
    </div>
  `
})
export class ChildComponent {
  @Input() userData!: User;
  @Input() config!: { editable: boolean; showAvatar: boolean };
  
  @Output() userUpdated = new EventEmitter<User>();
  @Output() statusChange = new EventEmitter<string>();
  
  onNameChange(): void {
    console.log('Name changed to:', this.userData.name);
  }
  
  updateUser(): void {
    this.userUpdated.emit({ ...this.userData });
  }
  
  changeStatus(status: string): void {
    this.statusChange.emit(status);
  }
}
```

**2. Service-Based Communication:**

```typescript
// shared-data.service.ts
@Injectable({ providedIn: 'root' })
export class SharedDataService {
  private messageSubject = new BehaviorSubject<string>('');
  private userSubject = new BehaviorSubject<User | null>(null);
  
  message$ = this.messageSubject.asObservable();
  user$ = this.userSubject.asObservable();
  
  updateMessage(message: string): void {
    this.messageSubject.next(message);
  }
  
  updateUser(user: User): void {
    this.userSubject.next(user);
  }
  
  clearData(): void {
    this.messageSubject.next('');
    this.userSubject.next(null);
  }
}

// component-a.component.ts
@Component({
  selector: 'app-component-a',
  template: `
    <div>
      <h3>Component A</h3>
      <input [(ngModel)]="message" placeholder="Enter message" />
      <button (click)="sendMessage()">Send Message</button>
      
      <div>
        <p>Received: {{sharedMessage$ | async}}</p>
        <p>Current User: {{(sharedUser$ | async)?.name}}</p>
      </div>
    </div>
  `
})
export class ComponentAComponent {
  message = '';
  sharedMessage$ = this.sharedDataService.message$;
  sharedUser$ = this.sharedDataService.user$;
  
  constructor(private sharedDataService: SharedDataService) {}
  
  sendMessage(): void {
    this.sharedDataService.updateMessage(this.message);
    this.message = '';
  }
}

// component-b.component.ts
@Component({
  selector: 'app-component-b',
  template: `
    <div>
      <h3>Component B</h3>
      <p>Message from A: {{sharedMessage$ | async}}</p>
      <button (click)="updateUser()">Update User</button>
      <button (click)="clearAll()">Clear All</button>
    </div>
  `
})
export class ComponentBComponent {
  sharedMessage$ = this.sharedDataService.message$;
  
  constructor(private sharedDataService: SharedDataService) {}
  
  updateUser(): void {
    const user: User = { id: 2, name: 'Jane', email: 'jane@example.com' };
    this.sharedDataService.updateUser(user);
  }
  
  clearAll(): void {
    this.sharedDataService.clearData();
  }
}
```

**3. ViewChild/ContentChild Communication:**

```typescript
// parent-with-viewchild.component.ts
@Component({
  selector: 'app-parent-viewchild',
  template: `
    <div>
      <button (click)="callChildMethod()">Call Child Method</button>
      <button (click)="getChildData()">Get Child Data</button>
      
      <app-child-with-methods #childRef></app-child-with-methods>
      
      <div *ngIf="childData">
        <h4>Child Data:</h4>
        <pre>{{childData | json}}</pre>
      </div>
    </div>
  `
})
export class ParentWithViewChildComponent {
  @ViewChild('childRef') childComponent!: ChildWithMethodsComponent;
  childData: any = null;
  
  callChildMethod(): void {
    this.childComponent.performAction('Hello from parent!');
  }
  
  getChildData(): void {
    this.childData = this.childComponent.getData();
  }
}

// child-with-methods.component.ts
@Component({
  selector: 'app-child-with-methods',
  template: `
    <div>
      <h4>Child with Methods</h4>
      <p>Counter: {{counter}}</p>
      <p>Last message: {{lastMessage}}</p>
    </div>
  `
})
export class ChildWithMethodsComponent {
  counter = 0;
  lastMessage = '';
  
  performAction(message: string): void {
    this.counter++;
    this.lastMessage = message;
    console.log('Child action performed:', message);
  }
  
  getData(): any {
    return {
      counter: this.counter,
      lastMessage: this.lastMessage,
      timestamp: new Date().toISOString()
    };
  }
  
  reset(): void {
    this.counter = 0;
    this.lastMessage = '';
  }
}
```

**4. Event Bus Pattern:**

```typescript
// event-bus.service.ts
@Injectable({ providedIn: 'root' })
export class EventBusService {
  private eventSubject = new Subject<{ type: string; payload: any }>();
  
  events$ = this.eventSubject.asObservable();
  
  emit(type: string, payload: any = null): void {
    this.eventSubject.next({ type, payload });
  }
  
  on(eventType: string): Observable<any> {
    return this.events$.pipe(
      filter(event => event.type === eventType),
      map(event => event.payload)
    );
  }
}

// publisher.component.ts
@Component({
  selector: 'app-publisher',
  template: `
    <div>
      <h3>Publisher Component</h3>
      <button (click)="publishEvent()">Publish Event</button>
      <button (click)="publishData()">Publish Data</button>
    </div>
  `
})
export class PublisherComponent {
  constructor(private eventBus: EventBusService) {}
  
  publishEvent(): void {
    this.eventBus.emit('USER_ACTION', { action: 'click', timestamp: Date.now() });
  }
  
  publishData(): void {
    this.eventBus.emit('DATA_UPDATE', { data: 'New data', id: Math.random() });
  }
}

// subscriber.component.ts
@Component({
  selector: 'app-subscriber',
  template: `
    <div>
      <h3>Subscriber Component</h3>
      <div *ngFor="let event of events">
        <p>{{event.type}}: {{event.payload | json}}</p>
      </div>
    </div>
  `
})
export class SubscriberComponent implements OnInit, OnDestroy {
  events: Array<{ type: string; payload: any }> = [];
  private destroy$ = new Subject<void>();
  
  constructor(private eventBus: EventBusService) {}
  
  ngOnInit(): void {
    this.eventBus.on('USER_ACTION').pipe(
      takeUntil(this.destroy$)
    ).subscribe(payload => {
      this.events.push({ type: 'USER_ACTION', payload });
    });
    
    this.eventBus.on('DATA_UPDATE').pipe(
      takeUntil(this.destroy$)
    ).subscribe(payload => {
      this.events.push({ type: 'DATA_UPDATE', payload });
    });
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

**5. Signal-Based Communication (Angular 16+):**

```typescript
// signal-communication.service.ts
@Injectable({ providedIn: 'root' })
export class SignalCommunicationService {
  private _counter = signal(0);
  private _message = signal('');
  private _user = signal<User | null>(null);
  
  readonly counter = this._counter.asReadonly();
  readonly message = this._message.asReadonly();
  readonly user = this._user.asReadonly();
  
  // Computed signals
  readonly doubleCounter = computed(() => this._counter() * 2);
  readonly userDisplay = computed(() => {
    const user = this._user();
    return user ? `${user.name} (${user.email})` : 'No user';
  });
  
  incrementCounter(): void {
    this._counter.update(count => count + 1);
  }
  
  updateMessage(newMessage: string): void {
    this._message.set(newMessage);
  }
  
  updateUser(user: User): void {
    this._user.set(user);
  }
  
  reset(): void {
    this._counter.set(0);
    this._message.set('');
    this._user.set(null);
  }
}

// signal-component-a.component.ts
@Component({
  selector: 'app-signal-a',
  template: `
    <div>
      <h3>Signal Component A</h3>
      <p>Counter: {{counter()}} (Double: {{doubleCounter()}})</p>
      <p>Message: {{message()}}</p>
      <p>User: {{userDisplay()}}</p>
      
      <button (click)="increment()">Increment</button>
      <input [(ngModel)]="newMessage" placeholder="Enter message" />
      <button (click)="sendMessage()">Send</button>
    </div>
  `
})
export class SignalComponentAComponent {
  newMessage = '';
  
  // Access signals directly
  counter = this.signalService.counter;
  doubleCounter = this.signalService.doubleCounter;
  message = this.signalService.message;
  userDisplay = this.signalService.userDisplay;
  
  constructor(private signalService: SignalCommunicationService) {}
  
  increment(): void {
    this.signalService.incrementCounter();
  }
  
  sendMessage(): void {
    this.signalService.updateMessage(this.newMessage);
    this.newMessage = '';
  }
}
```

**Communication Pattern Comparison:**

| Pattern | Use Case | Pros | Cons |
|---------|----------|------|------|
| **@Input/@Output** | Parent-Child | Simple, type-safe | Limited to direct relationships |
| **Service + RxJS** | Any components | Flexible, powerful | Requires subscription management |
| **ViewChild** | Parent accessing child | Direct method calls | Tight coupling |
| **Event Bus** | Loosely coupled | Decoupled communication | Can become hard to track |
| **Signals** | Modern reactive | Simple, performant | Newer API, limited ecosystem |

[Back to Components and Templates](#components-and-templates)

### 98. What is content projection (single/multi-slot)?

**Answer:**
Content projection allows components to accept and display content from their parent components using `<ng-content>`. It enables flexible, reusable component designs.

**Single-Slot Content Projection:**

```typescript
// card.component.ts
@Component({
  selector: 'app-card',
  template: `
    <div class="card">
      <div class="card-header">
        <h3>Card Title</h3>
      </div>
      <div class="card-body">
        <ng-content></ng-content>
      </div>
      <div class="card-footer">
        <small>Card Footer</small>
      </div>
    </div>
  `,
  styles: [`
    .card { border: 1px solid #ccc; border-radius: 8px; }
    .card-header { background: #f5f5f5; padding: 1rem; }
    .card-body { padding: 1rem; }
    .card-footer { background: #f5f5f5; padding: 0.5rem; }
  `]
})
export class CardComponent {}

// Usage
@Component({
  template: `
    <app-card>
      <p>This content will be projected into the card body!</p>
      <ul>
        <li>Item 1</li>
        <li>Item 2</li>
      </ul>
    </app-card>
  `
})
export class ParentComponent {}
```

**Multi-Slot Content Projection with Selectors:**

```typescript
// modal.component.ts
@Component({
  selector: 'app-modal',
  template: `
    <div class="modal-overlay" (click)="onOverlayClick()">
      <div class="modal-content" (click)="$event.stopPropagation()">
        <div class="modal-header">
          <ng-content select="[slot=header]"></ng-content>
          <button class="close-btn" (click)="onClose()">&times;</button>
        </div>
        
        <div class="modal-body">
          <ng-content select="[slot=body]"></ng-content>
        </div>
        
        <div class="modal-footer">
          <ng-content select="[slot=footer]"></ng-content>
          <ng-content select=".modal-actions"></ng-content>
        </div>
      </div>
    </div>
  `,
  styles: [`
    .modal-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); display: flex;
      align-items: center; justify-content: center;
    }
    .modal-content {
      background: white; border-radius: 8px;
      min-width: 400px; max-width: 80vw;
    }
    .modal-header {
      display: flex; justify-content: space-between;
      align-items: center; padding: 1rem;
      border-bottom: 1px solid #eee;
    }
    .modal-body { padding: 1rem; }
    .modal-footer {
      padding: 1rem; border-top: 1px solid #eee;
      display: flex; justify-content: flex-end; gap: 0.5rem;
    }
    .close-btn {
      background: none; border: none;
      font-size: 1.5rem; cursor: pointer;
    }
  `]
})
export class ModalComponent {
  @Output() close = new EventEmitter<void>();
  
  onClose(): void {
    this.close.emit();
  }
  
  onOverlayClick(): void {
    this.close.emit();
  }
}

// Usage with multiple slots
@Component({
  template: `
    <app-modal (close)="closeModal()" *ngIf="showModal">
      <h2 slot="header">Confirm Action</h2>
      
      <div slot="body">
        <p>Are you sure you want to delete this item?</p>
        <p><strong>This action cannot be undone.</strong></p>
      </div>
      
      <div slot="footer">
        <button class="btn btn-secondary" (click)="closeModal()">Cancel</button>
        <button class="btn btn-danger" (click)="confirmDelete()">Delete</button>
      </div>
    </app-modal>
    
    <!-- Alternative syntax using CSS classes -->
    <app-modal (close)="closeModal()" *ngIf="showInfoModal">
      <h2 slot="header">Information</h2>
      
      <div slot="body">
        <p>This is some important information.</p>
      </div>
      
      <div class="modal-actions">
        <button class="btn btn-primary" (click)="closeModal()">OK</button>
      </div>
    </app-modal>
  `
})
export class ParentWithModalComponent {
  showModal = false;
  showInfoModal = false;
  
  closeModal(): void {
    this.showModal = false;
    this.showInfoModal = false;
  }
  
  confirmDelete(): void {
    console.log('Item deleted');
    this.closeModal();
  }
}
```

**Advanced Content Projection Patterns:**

```typescript
// tabs.component.ts
@Component({
  selector: 'app-tabs',
  template: `
    <div class="tabs">
      <div class="tab-headers">
        <button 
          *ngFor="let tab of tabs; let i = index"
          class="tab-header"
          [class.active]="activeTabIndex === i"
          (click)="selectTab(i)">
          {{tab.title}}
        </button>
      </div>
      
      <div class="tab-content">
        <ng-content></ng-content>
      </div>
    </div>
  `,
  styles: [`
    .tabs { border: 1px solid #ccc; }
    .tab-headers { display: flex; background: #f5f5f5; }
    .tab-header {
      padding: 0.5rem 1rem; border: none;
      background: transparent; cursor: pointer;
    }
    .tab-header.active { background: white; border-bottom: 2px solid blue; }
    .tab-content { padding: 1rem; }
  `]
})
export class TabsComponent implements AfterContentInit {
  @ContentChildren(TabComponent) tabs!: QueryList<TabComponent>;
  activeTabIndex = 0;
  
  ngAfterContentInit(): void {
    this.tabs.toArray().forEach((tab, index) => {
      tab.isActive = index === this.activeTabIndex;
    });
  }
  
  selectTab(index: number): void {
    this.activeTabIndex = index;
    this.tabs.toArray().forEach((tab, i) => {
      tab.isActive = i === index;
    });
  }
}

// tab.component.ts
@Component({
  selector: 'app-tab',
  template: `
    <div class="tab-pane" [hidden]="!isActive">
      <ng-content></ng-content>
    </div>
  `
})
export class TabComponent {
  @Input() title!: string;
  isActive = false;
}

// Usage
@Component({
  template: `
    <app-tabs>
      <app-tab title="Profile">
        <h3>Profile Information</h3>
        <p>User profile content goes here.</p>
      </app-tab>
      
      <app-tab title="Settings">
        <h3>Application Settings</h3>
        <p>Settings content goes here.</p>
      </app-tab>
      
      <app-tab title="Help">
        <h3>Help & Support</h3>
        <p>Help content goes here.</p>
      </app-tab>
    </app-tabs>
  `
})
export class TabsExampleComponent {}
```

[Back to Components and Templates](#components-and-templates)

### 99. Explain `ng-content select`

**Answer:**
`ng-content select` allows you to project specific content into designated slots based on CSS selectors, enabling precise control over content placement.

**Selector Types:**

```typescript
// layout.component.ts
@Component({
  selector: 'app-layout',
  template: `
    <div class="layout">
      <!-- Element selector -->
      <header class="header">
        <ng-content select="header"></ng-content>
      </header>
      
      <!-- Class selector -->
      <nav class="sidebar">
        <ng-content select=".sidebar-content"></ng-content>
      </nav>
      
      <!-- Attribute selector -->
      <main class="main">
        <ng-content select="[slot=main]"></ng-content>
      </main>
      
      <!-- Multiple selectors -->
      <aside class="aside">
        <ng-content select="aside, .widget"></ng-content>
      </aside>
      
      <!-- Default content (no selector) -->
      <footer class="footer">
        <ng-content></ng-content>
      </footer>
    </div>
  `
})
export class LayoutComponent {}

// Usage
@Component({
  template: `
    <app-layout>
      <header>
        <h1>My Application</h1>
        <nav>Navigation here</nav>
      </header>
      
      <div class="sidebar-content">
        <ul>
          <li>Menu Item 1</li>
          <li>Menu Item 2</li>
        </ul>
      </div>
      
      <div slot="main">
        <h2>Main Content</h2>
        <p>This is the main content area.</p>
      </div>
      
      <aside>
        <h3>Sidebar Widget</h3>
        <p>Widget content</p>
      </aside>
      
      <div class="widget">
        <h4>Another Widget</h4>
      </div>
      
      <!-- This goes to default ng-content -->
      <p>Footer content without selector</p>
    </app-layout>
  `
})
export class AppComponent {}
```

**Complex Selector Examples:**

```typescript
// form-layout.component.ts
@Component({
  selector: 'app-form-layout',
  template: `
    <form class="form-layout">
      <!-- Title section -->
      <div class="form-header">
        <ng-content select="h1, h2, h3, .form-title"></ng-content>
      </div>
      
      <!-- Input fields -->
      <div class="form-fields">
        <ng-content select=".form-field, input, select, textarea"></ng-content>
      </div>
      
      <!-- Action buttons -->
      <div class="form-actions">
        <ng-content select="button, .btn, [type=submit]"></ng-content>
      </div>
      
      <!-- Error messages -->
      <div class="form-errors">
        <ng-content select=".error, .validation-message"></ng-content>
      </div>
    </form>
  `
})
export class FormLayoutComponent {}
```

[Back to Components and Templates](#components-and-templates)

### 100. What are view queries vs content queries?

**Answer:**
View queries (`@ViewChild`/`@ViewChildren`) access elements in the component's own template, while content queries (`@ContentChild`/`@ContentChildren`) access elements projected from parent components.

**View Queries Example:**

```typescript
// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <div class="parent">
      <h2>Parent Component</h2>
      
      <!-- These are in the component's VIEW -->
      <input #nameInput type="text" placeholder="Name" />
      <button #submitBtn (click)="onSubmit()">Submit</button>
      
      <app-child #childRef [data]="inputData">
        <!-- This content is PROJECTED to child -->
        <p class="projected-content">Projected paragraph</p>
        <span #projectedSpan>Projected span</span>
      </app-child>
      
      <div class="results">
        <p>Input value: {{inputValue}}</p>
        <p>Child data: {{childData}}</p>
      </div>
    </div>
  `
})
export class ParentComponent implements AfterViewInit {
  // VIEW QUERIES - access elements in this component's template
  @ViewChild('nameInput') nameInput!: ElementRef<HTMLInputElement>;
  @ViewChild('submitBtn') submitButton!: ElementRef<HTMLButtonElement>;
  @ViewChild('childRef') childComponent!: ChildComponent;
  
  inputValue = '';
  childData = '';
  inputData = 'Hello from parent';
  
  ngAfterViewInit(): void {
    // Access view elements after view initialization
    console.log('Name input element:', this.nameInput.nativeElement);
    console.log('Submit button:', this.submitButton.nativeElement);
    console.log('Child component:', this.childComponent);
    
    // Focus the input
    this.nameInput.nativeElement.focus();
  }
  
  onSubmit(): void {
    this.inputValue = this.nameInput.nativeElement.value;
    this.childData = this.childComponent.getData();
  }
}

// child.component.ts
@Component({
  selector: 'app-child',
  template: `
    <div class="child">
      <h3>Child Component</h3>
      <p>Data from parent: {{data}}</p>
      
      <!-- These are in the child's VIEW -->
      <input #childInput type="text" value="Child input" />
      <button #childBtn>Child Button</button>
      
      <!-- This is where projected content appears -->
      <div class="projected-area">
        <h4>Projected Content:</h4>
        <ng-content></ng-content>
      </div>
    </div>
  `
})
export class ChildComponent implements AfterViewInit, AfterContentInit {
  @Input() data!: string;
  
  // VIEW QUERIES - access elements in THIS component's template
  @ViewChild('childInput') childInput!: ElementRef<HTMLInputElement>;
  @ViewChild('childBtn') childButton!: ElementRef<HTMLButtonElement>;
  
  // CONTENT QUERIES - access projected content from parent
  @ContentChild('projectedSpan') projectedSpan!: ElementRef<HTMLSpanElement>;
  @ContentChildren('.projected-content') projectedParagraphs!: QueryList<ElementRef>;
  
  ngAfterViewInit(): void {
    // View queries are available here
    console.log('Child input:', this.childInput.nativeElement);
    console.log('Child button:', this.childButton.nativeElement);
  }
  
  ngAfterContentInit(): void {
    // Content queries are available here
    console.log('Projected span:', this.projectedSpan?.nativeElement);
    console.log('Projected paragraphs:', this.projectedParagraphs.toArray());
    
    if (this.projectedSpan) {
      this.projectedSpan.nativeElement.style.color = 'blue';
    }
  }
  
  getData(): string {
    return this.childInput.nativeElement.value;
  }
}
```

**Advanced Content Queries:**

```typescript
// tab-container.component.ts
@Component({
  selector: 'app-tab-container',
  template: `
    <div class="tab-container">
      <div class="tab-headers">
        <button 
          *ngFor="let tab of tabs; let i = index"
          [class.active]="activeIndex === i"
          (click)="selectTab(i)">
          {{tab.title}}
        </button>
      </div>
      
      <div class="tab-content">
        <ng-content></ng-content>
      </div>
    </div>
  `
})
export class TabContainerComponent implements AfterContentInit {
  @ContentChildren(TabComponent) tabs!: QueryList<TabComponent>;
  activeIndex = 0;
  
  ngAfterContentInit(): void {
    // Initialize tabs
    this.tabs.forEach((tab, index) => {
      tab.isActive = index === this.activeIndex;
    });
    
    // Listen for changes in projected tabs
    this.tabs.changes.subscribe(() => {
      console.log('Tabs changed:', this.tabs.length);
    });
  }
  
  selectTab(index: number): void {
    this.activeIndex = index;
    this.tabs.forEach((tab, i) => {
      tab.isActive = i === index;
    });
  }
}

// tab.component.ts
@Component({
  selector: 'app-tab',
  template: `
    <div class="tab" [hidden]="!isActive">
      <ng-content></ng-content>
    </div>
  `
})
export class TabComponent {
  @Input() title!: string;
  isActive = false;
}
```

**Query Options:**

```typescript
@Component({
  template: `
    <div>
      <input #input1 type="text" />
      <input #input2 type="email" />
      <app-custom-component></app-custom-component>
    </div>
  `
})
export class QueryOptionsComponent {
  // Static queries (available in ngOnInit)
  @ViewChild('input1', { static: true }) staticInput!: ElementRef;
  
  // Dynamic queries (available in ngAfterViewInit)
  @ViewChild('input2', { static: false }) dynamicInput!: ElementRef;
  
  // Read as different types
  @ViewChild(CustomComponent, { read: ElementRef }) componentElement!: ElementRef;
  @ViewChild(CustomComponent, { read: CustomComponent }) componentInstance!: CustomComponent;
  
  // Multiple elements
  @ViewChildren('input1, input2') allInputs!: QueryList<ElementRef>;
}
```

**Comparison Table:**

| Aspect | View Queries | Content Queries |
|--------|--------------|----------------|
| **Target** | Component's own template | Projected content |
| **Decorators** | `@ViewChild`, `@ViewChildren` | `@ContentChild`, `@ContentChildren` |
| **Availability** | `ngAfterViewInit` | `ngAfterContentInit` |
| **Scope** | Current component only | From parent component |
| **Use Case** | Access own DOM elements | Access projected elements |

[Back to Components and Templates](#components-and-templates)

### 101. Explain `@ViewChild` options

**Answer:**
`@ViewChild` provides several options to control how elements are queried and what type of reference is returned.

**Basic @ViewChild Options:**

```typescript
@Component({
  selector: 'app-viewchild-options',
  template: `
    <div class="container">
      <!-- Template reference variables -->
      <input #userInput type="text" placeholder="Enter name" />
      <button #submitButton (click)="onSubmit()">Submit</button>
      
      <!-- Component references -->
      <app-custom-component #customComp [data]="inputData"></app-custom-component>
      
      <!-- Directive references -->
      <div appCustomDirective #directiveRef="customDir">Directive target</div>
      
      <!-- Multiple elements with same reference -->
      <div #multiRef class="item">Item 1</div>
      <div #multiRef class="item">Item 2</div>
      
      <!-- Conditional elements -->
      <div *ngIf="showConditional">
        <span #conditionalElement>Conditional content</span>
      </div>
    </div>
  `
})
export class ViewChildOptionsComponent implements OnInit, AfterViewInit {
  inputData = 'Hello';
  showConditional = false;
  
  // 1. STATIC OPTION
  // static: true - Available in ngOnInit (for elements not in *ngIf/*ngFor)
  @ViewChild('userInput', { static: true }) 
  staticInput!: ElementRef<HTMLInputElement>;
  
  // static: false (default) - Available in ngAfterViewInit
  @ViewChild('submitButton', { static: false }) 
  dynamicButton!: ElementRef<HTMLButtonElement>;
  
  // 2. READ OPTION - Specify what to read from the element
  
  // Read as ElementRef (default for template references)
  @ViewChild('customComp', { read: ElementRef }) 
  componentElement!: ElementRef;
  
  // Read as component instance (default for components)
  @ViewChild('customComp', { read: CustomComponent }) 
  componentInstance!: CustomComponent;
  
  // Read as ViewContainerRef
  @ViewChild('customComp', { read: ViewContainerRef }) 
  componentViewContainer!: ViewContainerRef;
  
  // Read directive instance
  @ViewChild('directiveRef', { read: CustomDirective }) 
  directiveInstance!: CustomDirective;
  
  // 3. SELECTOR OPTIONS
  
  // By template reference
  @ViewChild('userInput') inputByRef!: ElementRef;
  
  // By component type
  @ViewChild(CustomComponent) componentByType!: CustomComponent;
  
  // By directive type
  @ViewChild(CustomDirective) directiveByType!: CustomDirective;
  
  // Multiple matches - gets first one
  @ViewChild('multiRef') firstMultiRef!: ElementRef;
  
  // Conditional elements (static: false required)
  @ViewChild('conditionalElement', { static: false }) 
  conditionalEl!: ElementRef;
  
  ngOnInit(): void {
    // Static queries are available here
    console.log('Static input in ngOnInit:', this.staticInput?.nativeElement);
    
    // Dynamic queries are NOT available here
    console.log('Dynamic button in ngOnInit:', this.dynamicButton); // undefined
  }
  
  ngAfterViewInit(): void {
    // All queries are available here
    console.log('Static input:', this.staticInput.nativeElement);
    console.log('Dynamic button:', this.dynamicButton.nativeElement);
    
    // Different read types
    console.log('Component element:', this.componentElement.nativeElement);
    console.log('Component instance:', this.componentInstance);
    console.log('View container:', this.componentViewContainer);
    
    // Focus the input
    this.staticInput.nativeElement.focus();
  }
  
  onSubmit(): void {
    const value = this.staticInput.nativeElement.value;
    this.componentInstance.updateData(value);
  }
  
  toggleConditional(): void {
    this.showConditional = !this.showConditional;
    
    // Need to wait for view update
    setTimeout(() => {
      if (this.conditionalEl) {
        console.log('Conditional element:', this.conditionalEl.nativeElement);
      }
    });
  }
}
```

**Advanced ViewChild Patterns:**

```typescript
@Component({
  template: `
    <div class="advanced-examples">
      <!-- Generic component -->
      <app-generic-component #genericComp></app-generic-component>
      
      <!-- Form controls -->
      <form #userForm="ngForm">
        <input name="username" ngModel #usernameControl="ngModel" />
      </form>
      
      <!-- Dynamic component host -->
      <div #dynamicHost></div>
      
      <!-- Template with context -->
      <ng-template #templateRef let-data="data">
        <p>Template data: {{data}}</p>
      </ng-template>
    </div>
  `
})
export class AdvancedViewChildComponent implements AfterViewInit {
  
  // Generic component with type safety
  @ViewChild('genericComp') 
  genericComponent!: GenericComponent<User>;
  
  // Form and form controls
  @ViewChild('userForm', { read: NgForm }) 
  form!: NgForm;
  
  @ViewChild('usernameControl', { read: NgModel }) 
  usernameModel!: NgModel;
  
  // ViewContainerRef for dynamic components
  @ViewChild('dynamicHost', { read: ViewContainerRef }) 
  dynamicHost!: ViewContainerRef;
  
  // Template reference
  @ViewChild('templateRef', { read: TemplateRef }) 
  template!: TemplateRef<any>;
  
  constructor(private componentFactoryResolver: ComponentFactoryResolver) {}
  
  ngAfterViewInit(): void {
    // Work with form
    this.form.statusChanges?.subscribe(status => {
      console.log('Form status:', status);
    });
    
    // Work with form control
    this.usernameModel.valueChanges?.subscribe(value => {
      console.log('Username changed:', value);
    });
    
    // Create dynamic component
    this.createDynamicComponent();
    
    // Use template
    this.dynamicHost.createEmbeddedView(this.template, { data: 'Hello from template!' });
  }
  
  private createDynamicComponent(): void {
    const factory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent);
    const componentRef = this.dynamicHost.createComponent(factory);
    componentRef.instance.message = 'Dynamic component created!';
  }
}
```

**ViewChildren vs ViewChild:**

```typescript
@Component({
  template: `
    <div class="multiple-elements">
      <input #input class="form-control" *ngFor="let item of items; let i = index" 
             [placeholder]="'Input ' + (i + 1)" />
      
      <app-item #itemComponent 
                *ngFor="let item of items" 
                [data]="item"></app-item>
    </div>
  `
})
export class MultipleElementsComponent implements AfterViewInit {
  items = ['Item 1', 'Item 2', 'Item 3'];
  
  // Single element (first match)
  @ViewChild('input') firstInput!: ElementRef;
  @ViewChild(ItemComponent) firstItemComponent!: ItemComponent;
  
  // Multiple elements
  @ViewChildren('input') allInputs!: QueryList<ElementRef>;
  @ViewChildren(ItemComponent) allItemComponents!: QueryList<ItemComponent>;
  
  ngAfterViewInit(): void {
    console.log('First input:', this.firstInput.nativeElement);
    console.log('All inputs count:', this.allInputs.length);
    
    // Iterate through all inputs
    this.allInputs.forEach((input, index) => {
      console.log(`Input ${index}:`, input.nativeElement);
    });
    
    // Listen for changes in the query list
    this.allInputs.changes.subscribe((queryList: QueryList<ElementRef>) => {
      console.log('Inputs changed, new count:', queryList.length);
    });
    
    // Work with all item components
    this.allItemComponents.forEach(component => {
      component.highlight();
    });
  }
  
  addItem(): void {
    this.items.push(`Item ${this.items.length + 1}`);
  }
}
```

**ViewChild Options Summary:**

| Option | Type | Description | Example |
|--------|------|-------------|---------|
| **selector** | `string \| Type<any>` | Template ref, component, or directive | `'#myRef'`, `MyComponent` |
| **read** | `Type<any>` | What to read from element | `ElementRef`, `ViewContainerRef` |
| **static** | `boolean` | Available in ngOnInit vs ngAfterViewInit | `true` for static, `false` for dynamic |

**Best Practices:**
- Use `static: true` only for elements that are always present
- Prefer component/directive types over template references for type safety
- Use appropriate `read` option for your use case
- Handle undefined references gracefully
- Use `ViewChildren` for dynamic lists of elements

[Back to Components and Templates](#components-and-templates)

### 102. What is the difference between `*ngIf` vs `[hidden]`?

**Answer:**
`*ngIf` conditionally adds/removes elements from the DOM, while `[hidden]` toggles CSS visibility. This affects performance, lifecycle, and behavior.

**DOM Manipulation vs CSS Visibility:**

```typescript
@Component({
  selector: 'app-conditional-demo',
  template: `
    <div class="demo-container">
      <div class="controls">
        <button (click)="toggleCondition()">Toggle Condition: {{showContent}}</button>
        <button (click)="toggleVisibility()">Toggle Visibility: {{isVisible}}</button>
      </div>
      
      <!-- *ngIf - Conditional DOM rendering -->
      <div class="ngif-section">
        <h3>*ngIf Section</h3>
        <div *ngIf="showContent" class="content-box">
          <h4>NgIf Content</h4>
          <p>This element is {{showContent ? 'in' : 'not in'}} the DOM</p>
          <expensive-component></expensive-component>
        </div>
      </div>
      
      <!-- [hidden] - CSS visibility toggle -->
      <div class="hidden-section">
        <h3>[hidden] Section</h3>
        <div [hidden]="!isVisible" class="content-box">
          <h4>Hidden Content</h4>
          <p>This element is always in the DOM, just {{isVisible ? 'visible' : 'hidden'}}</p>
          <expensive-component></expensive-component>
        </div>
      </div>
      
      <!-- Comparison with form elements -->
      <div class="form-section">
        <h3>Form Elements Comparison</h3>
        
        <!-- NgIf with form control -->
        <div *ngIf="showContent">
          <label>NgIf Input:</label>
          <input [(ngModel)]="ngIfValue" placeholder="NgIf input" />
          <p>Value: {{ngIfValue}}</p>
        </div>
        
        <!-- Hidden with form control -->
        <div [hidden]="!isVisible">
          <label>Hidden Input:</label>
          <input [(ngModel)]="hiddenValue" placeholder="Hidden input" />
          <p>Value: {{hiddenValue}}</p>
        </div>
      </div>
    </div>
  `,
  styles: [`
    .content-box {
      border: 1px solid #ccc;
      padding: 1rem;
      margin: 0.5rem 0;
      background: #f9f9f9;
    }
    .controls {
      margin-bottom: 1rem;
    }
    .controls button {
      margin-right: 0.5rem;
      padding: 0.5rem 1rem;
    }
  `]
})
export class ConditionalDemoComponent {
  showContent = true;
  isVisible = true;
  ngIfValue = '';
  hiddenValue = '';
  
  toggleCondition(): void {
    this.showContent = !this.showContent;
    console.log('NgIf toggled:', this.showContent);
  }
  
  toggleVisibility(): void {
    this.isVisible = !this.isVisible;
    console.log('Hidden toggled:', this.isVisible);
  }
}

// Expensive component to demonstrate lifecycle differences
@Component({
  selector: 'expensive-component',
  template: `
    <div class="expensive">
      <p>Expensive Component ({{id}})</p>
      <p>Initialized at: {{initTime}}</p>
    </div>
  `
})
export class ExpensiveComponent implements OnInit, OnDestroy {
  id = Math.random().toString(36).substr(2, 9);
  initTime = new Date().toLocaleTimeString();
  
  ngOnInit(): void {
    console.log(`ExpensiveComponent ${this.id} initialized`);
    // Simulate expensive initialization
    for (let i = 0; i < 1000000; i++) {
      // Expensive operation
    }
  }
  
  ngOnDestroy(): void {
    console.log(`ExpensiveComponent ${this.id} destroyed`);
  }
}
```

**Performance Comparison:**

```typescript
@Component({
  selector: 'app-performance-demo',
  template: `
    <div class="performance-demo">
      <div class="controls">
        <button (click)="toggleNgIf()">Toggle NgIf ({{ngIfItems.length}} items)</button>
        <button (click)="toggleHidden()">Toggle Hidden ({{hiddenItems.length}} items)</button>
        <button (click)="addItems()">Add 1000 Items</button>
        <button (click)="clearItems()">Clear All</button>
      </div>
      
      <!-- Large list with *ngIf -->
      <div class="list-section">
        <h3>NgIf List ({{showNgIfList ? 'Shown' : 'Hidden'}})</h3>
        <div *ngIf="showNgIfList" class="item-list">
          <div *ngFor="let item of ngIfItems" class="item">
            {{item.name}} - {{item.value}}
          </div>
        </div>
      </div>
      
      <!-- Large list with [hidden] -->
      <div class="list-section">
        <h3>Hidden List ({{showHiddenList ? 'Shown' : 'Hidden'}})</h3>
        <div [hidden]="!showHiddenList" class="item-list">
          <div *ngFor="let item of hiddenItems" class="item">
            {{item.name}} - {{item.value}}
          </div>
        </div>
      </div>
    </div>
  `
})
export class PerformanceDemoComponent {
  showNgIfList = true;
  showHiddenList = true;
  ngIfItems: Array<{name: string, value: number}> = [];
  hiddenItems: Array<{name: string, value: number}> = [];
  
  toggleNgIf(): void {
    const start = performance.now();
    this.showNgIfList = !this.showNgIfList;
    setTimeout(() => {
      const end = performance.now();
      console.log(`NgIf toggle took ${end - start} milliseconds`);
    });
  }
  
  toggleHidden(): void {
    const start = performance.now();
    this.showHiddenList = !this.showHiddenList;
    setTimeout(() => {
      const end = performance.now();
      console.log(`Hidden toggle took ${end - start} milliseconds`);
    });
  }
  
  addItems(): void {
    const newItems = Array.from({length: 1000}, (_, i) => ({
      name: `Item ${i}`,
      value: Math.random()
    }));
    
    this.ngIfItems = [...this.ngIfItems, ...newItems];
    this.hiddenItems = [...this.hiddenItems, ...newItems];
  }
  
  clearItems(): void {
    this.ngIfItems = [];
    this.hiddenItems = [];
  }
}
```

**When to Use Each:**

```typescript
@Component({
  selector: 'app-usage-examples',
  template: `
    <div class="usage-examples">
      <!-- Use *ngIf for: -->
      
      <!-- 1. Conditional features -->
      <div *ngIf="user.isAdmin" class="admin-panel">
        <h3>Admin Panel</h3>
        <admin-controls></admin-controls>
      </div>
      
      <!-- 2. Expensive components -->
      <div *ngIf="showChart">
        <expensive-chart [data]="chartData"></expensive-chart>
      </div>
      
      <!-- 3. Form sections -->
      <form>
        <input [(ngModel)]="userType" name="userType" />
        
        <div *ngIf="userType === 'business'" class="business-fields">
          <input placeholder="Company Name" />
          <input placeholder="Tax ID" />
        </div>
      </form>
      
      <!-- Use [hidden] for: -->
      
      <!-- 1. Frequently toggled content -->
      <div class="accordion-item">
        <button (click)="toggleAccordion()">Toggle Details</button>
        <div [hidden]="!accordionOpen" class="accordion-content">
          <p>Frequently accessed content that should stay in DOM</p>
        </div>
      </div>
      
      <!-- 2. Form validation messages -->
      <div class="form-field">
        <input #email="ngModel" [(ngModel)]="userEmail" email required />
        <div [hidden]="email.valid || email.pristine" class="error">
          Please enter a valid email
        </div>
      </div>
      
      <!-- 3. Loading states -->
      <div class="data-container">
        <div [hidden]="!loading" class="loading-spinner">Loading...</div>
        <div [hidden]="loading || !data" class="data-content">
          {{data | json}}
        </div>
      </div>
    </div>
  `
})
export class UsageExamplesComponent {
  user = { isAdmin: false };
  showChart = false;
  userType = '';
  accordionOpen = false;
  userEmail = '';
  loading = false;
  data: any = null;
  chartData = [];
  
  toggleAccordion(): void {
    this.accordionOpen = !this.accordionOpen;
  }
}
```

**Comparison Summary:**

| Aspect | *ngIf | [hidden] |
|--------|-------|----------|
| **DOM Impact** | Adds/removes from DOM | Always in DOM |
| **Performance** | Better for large/expensive content | Better for frequent toggles |
| **Memory Usage** | Lower when hidden | Higher (always rendered) |
| **Initialization** | Runs lifecycle hooks on show | Runs once |
| **Form State** | Loses form data when hidden | Preserves form data |
| **CSS/Styling** | No styling when hidden | Can be styled when hidden |
| **Accessibility** | Completely removed | Hidden but present |
| **Use Cases** | Conditional features, expensive components | Frequent toggles, form validation |

**Best Practices:**
- Use `*ngIf` for conditional features and expensive components
- Use `[hidden]` for frequently toggled UI elements
- Consider memory usage with large lists
- Be aware of form state preservation needs
- Test performance with your specific use case

[Back to Components and Templates](#components-and-templates)

### 103. How do you use `ng-template`, `ng-container`?

**Answer:**
`ng-template` defines reusable template blocks, while `ng-container` groups elements without adding extra DOM nodes. Both are essential for advanced templating.

**ng-template Usage:**

```typescript
@Component({
  selector: 'app-template-demo',
  template: `
    <div class="template-demo">
      <!-- 1. Basic ng-template with ngIf else -->
      <div *ngIf="user; else noUserTemplate">
        <h3>Welcome, {{user.name}}!</h3>
        <p>Email: {{user.email}}</p>
      </div>
      
      <ng-template #noUserTemplate>
        <div class="no-user">
          <h3>No User Found</h3>
          <button (click)="loadUser()">Load User</button>
        </div>
      </ng-template>
      
      <!-- 2. Template with context -->
      <div class="user-cards">
        <div *ngFor="let user of users; let i = index">
          <ng-container *ngTemplateOutlet="userCardTemplate; context: { 
            $implicit: user, 
            index: i, 
            isLast: i === users.length - 1 
          }"></ng-container>
        </div>
      </div>
      
      <ng-template #userCardTemplate let-user let-index="index" let-isLast="isLast">
        <div class="user-card" [class.last]="isLast">
          <h4>{{index + 1}}. {{user.name}}</h4>
          <p>{{user.email}}</p>
          <p *ngIf="user.isAdmin" class="admin-badge">Admin</p>
        </div>
      </ng-template>
      
      <!-- 3. Conditional templates -->
      <div class="conditional-content">
        <ng-container [ngSwitch]="contentType">
          <ng-container *ngSwitchCase="'loading'">
            <ng-container *ngTemplateOutlet="loadingTemplate"></ng-container>
          </ng-container>
          <ng-container *ngSwitchCase="'error'">
            <ng-container *ngTemplateOutlet="errorTemplate; context: { error: errorMessage }"></ng-container>
          </ng-container>
          <ng-container *ngSwitchDefault>
            <ng-container *ngTemplateOutlet="contentTemplate"></ng-container>
          </ng-container>
        </ng-container>
      </div>
      
      <ng-template #loadingTemplate>
        <div class="loading">
          <div class="spinner"></div>
          <p>Loading...</p>
        </div>
      </ng-template>
      
      <ng-template #errorTemplate let-error="error">
        <div class="error">
          <h4>Error Occurred</h4>
          <p>{{error}}</p>
          <button (click)="retry()">Retry</button>
        </div>
      </ng-template>
      
      <ng-template #contentTemplate>
        <div class="content">
          <h4>Content Loaded Successfully</h4>
          <p>Here's your content!</p>
        </div>
      </ng-template>
    </div>
  `
})
export class TemplateDemoComponent {
  user: User | null = null;
  users: User[] = [
    { id: 1, name: 'John', email: 'john@example.com', isAdmin: false },
    { id: 2, name: 'Jane', email: 'jane@example.com', isAdmin: true },
    { id: 3, name: 'Bob', email: 'bob@example.com', isAdmin: false }
  ];
  
  contentType: 'loading' | 'error' | 'content' = 'content';
  errorMessage = 'Something went wrong!';
  
  loadUser(): void {
    this.user = { id: 1, name: 'John Doe', email: 'john@example.com', isAdmin: false };
  }
  
  retry(): void {
    this.contentType = 'loading';
    setTimeout(() => {
      this.contentType = 'content';
    }, 2000);
  }
}
```

**ng-container Usage:**

```typescript
@Component({
  selector: 'app-container-demo',
  template: `
    <div class="container-demo">
      <!-- 1. Grouping without extra DOM -->
      <div class="card">
        <ng-container *ngIf="showHeader">
          <h3>Card Title</h3>
          <p class="subtitle">Card Subtitle</p>
        </ng-container>
        
        <div class="card-body">
          <p>Card content goes here</p>
        </div>
      </div>
      
      <!-- 2. Multiple structural directives -->
      <div class="item-list">
        <ng-container *ngFor="let item of items; let i = index">
          <ng-container *ngIf="item.visible">
            <div class="item" [class.highlighted]="item.highlighted">
              <span>{{i + 1}}. {{item.name}}</span>
              <span class="value">{{item.value}}</span>
            </div>
          </ng-container>
        </ng-container>
      </div>
      
      <!-- 3. NgSwitch without wrapper -->
      <div class="status-display">
        <ng-container [ngSwitch]="status">
          <span *ngSwitchCase="'success'" class="success">✓ Success</span>
          <span *ngSwitchCase="'error'" class="error">✗ Error</span>
          <span *ngSwitchCase="'warning'" class="warning">⚠ Warning</span>
          <span *ngSwitchDefault class="info">ℹ Info</span>
        </ng-container>
      </div>
      
      <!-- 4. Complex conditional grouping -->
      <div class="user-info">
        <ng-container *ngIf="currentUser">
          <ng-container *ngIf="currentUser.isVerified; else unverifiedTemplate">
            <div class="verified-user">
              <h4>{{currentUser.name}}</h4>
              <p>Verified Account</p>
              <ng-container *ngIf="currentUser.isPremium">
                <span class="premium-badge">Premium</span>
              </ng-container>
            </div>
          </ng-container>
          
          <ng-template #unverifiedTemplate>
            <div class="unverified-user">
              <h4>{{currentUser.name}}</h4>
              <p class="warning">Please verify your account</p>
              <button (click)="sendVerification()">Send Verification</button>
            </div>
          </ng-template>
        </ng-container>
      </div>
    </div>
  `
})
export class ContainerDemoComponent {
  showHeader = true;
  status: 'success' | 'error' | 'warning' | 'info' = 'success';
  
  items = [
    { name: 'Item 1', value: 100, visible: true, highlighted: false },
    { name: 'Item 2', value: 200, visible: false, highlighted: true },
    { name: 'Item 3', value: 300, visible: true, highlighted: false }
  ];
  
  currentUser = {
    name: 'John Doe',
    isVerified: true,
    isPremium: true
  };
  
  sendVerification(): void {
    console.log('Verification sent!');
  }
}
```

**Dynamic Templates:**

```typescript
@Component({
  selector: 'app-dynamic-templates',
  template: `
    <div class="dynamic-templates">
      <!-- Template selector -->
      <div class="template-controls">
        <button *ngFor="let template of availableTemplates" 
                (click)="selectTemplate(template.name)"
                [class.active]="selectedTemplate === template.name">
          {{template.label}}
        </button>
      </div>
      
      <!-- Dynamic template rendering -->
      <div class="template-container">
        <ng-container [ngSwitch]="selectedTemplate">
          <ng-container *ngSwitchCase="'list'">
            <ng-container *ngTemplateOutlet="listTemplate; context: { items: data }"></ng-container>
          </ng-container>
          <ng-container *ngSwitchCase="'grid'">
            <ng-container *ngTemplateOutlet="gridTemplate; context: { items: data }"></ng-container>
          </ng-container>
          <ng-container *ngSwitchCase="'table'">
            <ng-container *ngTemplateOutlet="tableTemplate; context: { items: data }"></ng-container>
          </ng-container>
        </ng-container>
      </div>
      
      <!-- Template definitions -->
      <ng-template #listTemplate let-items="items">
        <ul class="list-view">
          <li *ngFor="let item of items" class="list-item">
            <h4>{{item.title}}</h4>
            <p>{{item.description}}</p>
          </li>
        </ul>
      </ng-template>
      
      <ng-template #gridTemplate let-items="items">
        <div class="grid-view">
          <div *ngFor="let item of items" class="grid-item">
            <div class="grid-card">
              <h4>{{item.title}}</h4>
              <p>{{item.description}}</p>
            </div>
          </div>
        </div>
      </ng-template>
      
      <ng-template #tableTemplate let-items="items">
        <table class="table-view">
          <thead>
            <tr>
              <th>Title</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr *ngFor="let item of items">
              <td>{{item.title}}</td>
              <td>{{item.description}}</td>
            </tr>
          </tbody>
        </table>
      </ng-template>
    </div>
  `
})
export class DynamicTemplatesComponent {
  selectedTemplate = 'list';
  
  availableTemplates = [
    { name: 'list', label: 'List View' },
    { name: 'grid', label: 'Grid View' },
    { name: 'table', label: 'Table View' }
  ];
  
  data = [
    { title: 'Item 1', description: 'Description for item 1' },
    { title: 'Item 2', description: 'Description for item 2' },
    { title: 'Item 3', description: 'Description for item 3' }
  ];
  
  selectTemplate(templateName: string): void {
    this.selectedTemplate = templateName;
  }
}
```

**Programmatic Template Usage:**

```typescript
@Component({
  selector: 'app-programmatic-templates',
  template: `
    <div class="programmatic-demo">
      <button (click)="renderTemplate()">Render Template</button>
      <button (click)="clearContainer()">Clear</button>
      
      <div #container class="template-container"></div>
      
      <ng-template #dynamicTemplate let-data="data" let-index="index">
        <div class="dynamic-content">
          <h4>Dynamic Content {{index}}</h4>
          <p>{{data.message}}</p>
          <small>Created at: {{data.timestamp}}</small>
        </div>
      </ng-template>
    </div>
  `
})
export class ProgrammaticTemplatesComponent {
  @ViewChild('container', { read: ViewContainerRef }) 
  container!: ViewContainerRef;
  
  @ViewChild('dynamicTemplate', { read: TemplateRef }) 
  template!: TemplateRef<any>;
  
  private counter = 0;
  
  renderTemplate(): void {
    const context = {
      data: {
        message: `This is message ${this.counter + 1}`,
        timestamp: new Date().toLocaleTimeString()
      },
      index: this.counter
    };
    
    this.container.createEmbeddedView(this.template, context);
    this.counter++;
  }
  
  clearContainer(): void {
    this.container.clear();
    this.counter = 0;
  }
}
```

**Key Differences:**

| Feature | ng-template | ng-container |
|---------|-------------|-------------|
| **Purpose** | Define reusable templates | Group elements without DOM |
| **DOM Output** | No direct output | No wrapper element |
| **Usage** | With `*ngTemplateOutlet` | With structural directives |
| **Context** | Can accept context data | No context |
| **Reusability** | Highly reusable | Single use grouping |

**Best Practices:**
- Use `ng-template` for reusable template blocks
- Use `ng-container` to avoid extra DOM wrappers
- Combine both for complex conditional rendering
- Leverage template context for dynamic data
- Keep templates focused and single-purpose

[Back to Components and Templates](#components-and-templates)

### 104. What are Angular 17 control flow features (`@if`, `@for`, `@defer`)?

**Answer:**
Angular 17 introduced new control flow syntax (`@if`, `@for`, `@defer`) that provides better performance, type safety, and developer experience compared to structural directives.

**@if Control Flow:**

```typescript
@Component({
  template: `
    <!-- New @if syntax -->
    @if (user) {
      <div class="user-info">
        <h3>Welcome, {{user.name}}!</h3>
        <p>Email: {{user.email}}</p>
        
        @if (user.isAdmin) {
          <div class="admin-panel">
            <h4>Admin Controls</h4>
            <button>Manage Users</button>
          </div>
        } @else {
          <div class="user-panel">
            <button>Edit Profile</button>
          </div>
        }
      </div>
    } @else {
      <div class="no-user">
        <h3>Please log in</h3>
        <button (click)="login()">Login</button>
      </div>
    }
    
    <!-- Complex conditional logic -->
    @if (loading) {
      <div class="loading">Loading...</div>
    } @else if (error) {
      <div class="error">
        <h4>Error: {{error.message}}</h4>
        <button (click)="retry()">Retry</button>
      </div>
    } @else if (data.length === 0) {
      <div class="empty">
        <p>No data available</p>
        <button (click)="loadData()">Load Data</button>
      </div>
    } @else {
      <div class="data">
        <h4>Data loaded successfully</h4>
        <p>{{data.length}} items found</p>
      </div>
    }
  `
})
export class IfControlFlowComponent {
  user: User | null = null;
  loading = false;
  error: Error | null = null;
  data: any[] = [];
  
  login(): void {
    this.user = { name: 'John', email: 'john@example.com', isAdmin: false };
  }
  
  retry(): void {
    this.error = null;
    this.loadData();
  }
  
  loadData(): void {
    this.loading = true;
    // Simulate API call
    setTimeout(() => {
      this.data = [1, 2, 3, 4, 5];
      this.loading = false;
    }, 1000);
  }
}
```

**@for Control Flow:**

```typescript
@Component({
  template: `
    <div class="for-examples">
      <!-- Basic @for loop -->
      <div class="simple-list">
        <h3>Simple List</h3>
        @for (item of items; track item.id) {
          <div class="item">
            {{item.name}} - {{item.value}}
          </div>
        }
      </div>
      
      <!-- @for with index and other variables -->
      <div class="indexed-list">
        <h3>Indexed List</h3>
        @for (item of items; track item.id; let i = $index, isFirst = $first, isLast = $last, isEven = $even) {
          <div class="item" 
               [class.first]="isFirst" 
               [class.last]="isLast" 
               [class.even]="isEven">
            {{i + 1}}. {{item.name}}
            @if (isFirst) {
              <span class="badge">First</span>
            }
            @if (isLast) {
              <span class="badge">Last</span>
            }
          </div>
        }
      </div>
      
      <!-- @for with @empty -->
      <div class="list-with-empty">
        <h3>List with Empty State</h3>
        @for (item of filteredItems; track item.id) {
          <div class="item">
            <h4>{{item.name}}</h4>
            <p>{{item.description}}</p>
          </div>
        } @empty {
          <div class="empty-state">
            <p>No items match your criteria</p>
            <button (click)="clearFilter()">Clear Filter</button>
          </div>
        }
      </div>
      
      <!-- Nested @for loops -->
      <div class="nested-lists">
        <h3>Nested Lists</h3>
        @for (category of categories; track category.id) {
          <div class="category">
            <h4>{{category.name}}</h4>
            @for (item of category.items; track item.id) {
              <div class="category-item">
                {{item.name}} - ${{item.price}}
              </div>
            } @empty {
              <p class="no-items">No items in this category</p>
            }
          </div>
        }
      </div>
    </div>
  `
})
export class ForControlFlowComponent {
  items = [
    { id: 1, name: 'Item 1', value: 100, description: 'First item' },
    { id: 2, name: 'Item 2', value: 200, description: 'Second item' },
    { id: 3, name: 'Item 3', value: 300, description: 'Third item' }
  ];
  
  filteredItems = this.items.filter(item => item.value > 150);
  
  categories = [
    {
      id: 1,
      name: 'Electronics',
      items: [
        { id: 101, name: 'Laptop', price: 999 },
        { id: 102, name: 'Phone', price: 699 }
      ]
    },
    {
      id: 2,
      name: 'Books',
      items: []
    }
  ];
  
  clearFilter(): void {
    this.filteredItems = this.items;
  }
}
```

**@defer Control Flow (Lazy Loading):**

```typescript
@Component({
  template: `
    <div class="defer-examples">
      <!-- Basic defer -->
      <h3>Deferred Content</h3>
      @defer {
        <expensive-component [data]="heavyData"></expensive-component>
      } @placeholder {
        <div class="placeholder">
          <p>Content will load when needed...</p>
        </div>
      } @loading {
        <div class="loading">
          <div class="spinner"></div>
          <p>Loading expensive component...</p>
        </div>
      } @error {
        <div class="error">
          <p>Failed to load component</p>
          <button>Retry</button>
        </div>
      }
      
      <!-- Defer with triggers -->
      <div class="trigger-examples">
        <h3>Defer with Triggers</h3>
        
        <!-- Hover trigger -->
        <div class="hover-trigger" #hoverTrigger>
          <p>Hover over this area to load content</p>
          @defer (on hover(hoverTrigger)) {
            <div class="hover-content">
              <h4>Hover Content Loaded!</h4>
              <p>This loaded when you hovered</p>
            </div>
          } @placeholder {
            <div class="placeholder">Hover to load...</div>
          }
        </div>
        
        <!-- Intersection trigger -->
        <div class="scroll-content">
          <p>Scroll down to see deferred content...</p>
          <div style="height: 200vh;"><!-- Spacer --></div>
          
          @defer (on viewport) {
            <div class="viewport-content">
              <h4>Viewport Content</h4>
              <p>This loaded when it came into view</p>
              <heavy-chart [data]="chartData"></heavy-chart>
            </div>
          } @placeholder {
            <div class="placeholder">Will load when in viewport...</div>
          }
        </div>
        
        <!-- Timer trigger -->
        @defer (on timer(3s)) {
          <div class="timer-content">
            <h4>Timer Content</h4>
            <p>This loaded after 3 seconds</p>
          </div>
        } @placeholder {
          <div class="placeholder">Loading in 3 seconds...</div>
        }
        
        <!-- Interaction trigger -->
        <button #loadButton>Click to load content</button>
        @defer (on interaction(loadButton)) {
          <div class="interaction-content">
            <h4>Interaction Content</h4>
            <p>This loaded when you clicked the button</p>
          </div>
        } @placeholder {
          <div class="placeholder">Click button to load...</div>
        }
      </div>
      
      <!-- Complex defer with multiple triggers -->
      <div class="complex-defer">
        <h3>Complex Defer</h3>
        @defer (on hover; on viewport; when shouldLoad) {
          <complex-dashboard 
            [userData]="userData" 
            [analytics]="analytics">
          </complex-dashboard>
        } @placeholder (minimum 500ms) {
          <div class="placeholder">
            <div class="skeleton"></div>
            <p>Loading dashboard...</p>
          </div>
        } @loading (minimum 2s; after 100ms) {
          <div class="loading">
            <progress-bar [progress]="loadingProgress"></progress-bar>
            <p>Loading dashboard components...</p>
          </div>
        } @error {
          <div class="error">
            <h4>Failed to load dashboard</h4>
            <button (click)="retryLoad()">Retry</button>
          </div>
        }
      </div>
    </div>
  `
})
export class DeferControlFlowComponent {
  heavyData = Array.from({length: 10000}, (_, i) => ({ id: i, value: Math.random() }));
  chartData = [1, 2, 3, 4, 5];
  shouldLoad = false;
  loadingProgress = 0;
  userData = { name: 'John', role: 'admin' };
  analytics = { views: 1000, clicks: 50 };
  
  retryLoad(): void {
    this.shouldLoad = true;
    // Simulate loading progress
    const interval = setInterval(() => {
      this.loadingProgress += 10;
      if (this.loadingProgress >= 100) {
        clearInterval(interval);
      }
    }, 200);
  }
}
```

**Comparison with Traditional Directives:**

```typescript
@Component({
  template: `
    <!-- Traditional approach -->
    <div *ngIf="user; else noUserTemplate">
      <div *ngIf="user.isAdmin; else userTemplate">
        Admin Panel
      </div>
      <ng-template #userTemplate>
        User Panel
      </ng-template>
    </div>
    <ng-template #noUserTemplate>
      Please login
    </ng-template>
    
    <div *ngFor="let item of items; let i = index; trackBy: trackByFn">
      {{i}}: {{item.name}}
    </div>
    
    <!-- New control flow approach -->
    @if (user) {
      @if (user.isAdmin) {
        <div>Admin Panel</div>
      } @else {
        <div>User Panel</div>
      }
    } @else {
      <div>Please login</div>
    }
    
    @for (item of items; track item.id; let i = $index) {
      <div>{{i}}: {{item.name}}</div>
    }
  `
})
export class ComparisonComponent {
  user: User | null = null;
  items = [{ id: 1, name: 'Item 1' }];
  
  trackByFn(index: number, item: any): any {
    return item.id;
  }
}
```

**Benefits of New Control Flow:**

1. **Better Performance**: Built-in optimizations and lazy loading
2. **Type Safety**: Better TypeScript integration
3. **Cleaner Syntax**: More readable and intuitive
4. **Built-in Features**: @empty, @placeholder, @loading, @error
5. **Advanced Triggers**: Multiple trigger conditions for @defer

**Migration Guide:**

| Old Syntax | New Syntax |
|------------|------------|
| `*ngIf="condition"` | `@if (condition) { }` |
| `*ngIf="condition; else template"` | `@if (condition) { } @else { }` |
| `*ngFor="let item of items"` | `@for (item of items; track item.id) { }` |
| `*ngFor with empty template` | `@for (...) { } @empty { }` |
| Manual lazy loading | `@defer { } @placeholder { }` |

[Back to Components and Templates](#components-and-templates)

### 105. How do you handle dynamic component loading?

**Answer:**
Dynamic component loading allows you to create and insert components at runtime. Angular provides several approaches depending on your use case.

**Modern Approach (Angular 13+):**

```typescript
// dynamic-component-loader.component.ts
@Component({
  selector: 'app-dynamic-loader',
  template: `
    <div class="dynamic-loader">
      <div class="controls">
        <button (click)="loadComponent('user')">Load User Component</button>
        <button (click)="loadComponent('product')">Load Product Component</button>
        <button (click)="loadComponent('chart')">Load Chart Component</button>
        <button (click)="clearComponents()">Clear All</button>
      </div>
      
      <div class="component-container" #container></div>
      
      <div class="component-info">
        <p>Loaded components: {{loadedComponents.length}}</p>
        <ul>
          <li *ngFor="let comp of loadedComponents">
            {{comp.type}} - {{comp.id}}
            <button (click)="removeComponent(comp.id)">Remove</button>
          </li>
        </ul>
      </div>
    </div>
  `
})
export class DynamicComponentLoaderComponent {
  @ViewChild('container', { read: ViewContainerRef }) 
  container!: ViewContainerRef;
  
  loadedComponents: Array<{ id: string; type: string; ref: ComponentRef<any> }> = [];
  
  constructor(private injector: Injector) {}
  
  async loadComponent(type: string): Promise<void> {
    let componentRef: ComponentRef<any>;
    const id = Math.random().toString(36).substr(2, 9);
    
    switch (type) {
      case 'user':
        componentRef = this.container.createComponent(UserComponent, {
          injector: this.injector
        });
        componentRef.instance.userId = id;
        componentRef.instance.userData = { name: 'John Doe', email: 'john@example.com' };
        break;
        
      case 'product':
        componentRef = this.container.createComponent(ProductComponent, {
          injector: this.injector
        });
        componentRef.instance.productId = id;
        componentRef.instance.productData = { name: 'Sample Product', price: 99.99 };
        break;
        
      case 'chart':
        // Lazy load component
        const { ChartComponent } = await import('./chart/chart.component');
        componentRef = this.container.createComponent(ChartComponent, {
          injector: this.injector
        });
        componentRef.instance.chartData = [1, 2, 3, 4, 5];
        componentRef.instance.chartType = 'bar';
        break;
        
      default:
        return;
    }
    
    // Store reference
    this.loadedComponents.push({ id, type, ref: componentRef });
    
    // Listen to component events
    if (componentRef.instance.closeEvent) {
      componentRef.instance.closeEvent.subscribe(() => {
        this.removeComponent(id);
      });
    }
  }
  
  removeComponent(id: string): void {
    const index = this.loadedComponents.findIndex(comp => comp.id === id);
    if (index !== -1) {
      const component = this.loadedComponents[index];
      component.ref.destroy();
      this.loadedComponents.splice(index, 1);
    }
  }
  
  clearComponents(): void {
    this.container.clear();
    this.loadedComponents = [];
  }
}

// Dynamic components
@Component({
  selector: 'app-user',
  template: `
    <div class="user-component">
      <h3>User Component ({{userId}})</h3>
      <p>Name: {{userData.name}}</p>
      <p>Email: {{userData.email}}</p>
      <button (click)="close()">Close</button>
    </div>
  `
})
export class UserComponent {
  @Input() userId!: string;
  @Input() userData!: { name: string; email: string };
  @Output() closeEvent = new EventEmitter<void>();
  
  close(): void {
    this.closeEvent.emit();
  }
}

@Component({
  selector: 'app-product',
  template: `
    <div class="product-component">
      <h3>Product Component ({{productId}})</h3>
      <p>Name: {{productData.name}}</p>
      <p>Price: ${{productData.price}}</p>
      <button (click)="close()">Close</button>
    </div>
  `
})
export class ProductComponent {
  @Input() productId!: string;
  @Input() productData!: { name: string; price: number };
  @Output() closeEvent = new EventEmitter<void>();
  
  close(): void {
    this.closeEvent.emit();
  }
}
```

**Advanced Dynamic Loading with Services:**

```typescript
// dynamic-component.service.ts
export interface DynamicComponentConfig {
  component: Type<any>;
  inputs?: { [key: string]: any };
  outputs?: { [key: string]: (event: any) => void };
}

@Injectable({ providedIn: 'root' })
export class DynamicComponentService {
  private componentRegistry = new Map<string, () => Promise<Type<any>>>();
  
  constructor() {
    // Register components
    this.registerComponent('user-card', () => 
      import('./user-card/user-card.component').then(m => m.UserCardComponent)
    );
    this.registerComponent('data-table', () => 
      import('./data-table/data-table.component').then(m => m.DataTableComponent)
    );
    this.registerComponent('chart', () => 
      import('./chart/chart.component').then(m => m.ChartComponent)
    );
  }
  
  registerComponent(name: string, loader: () => Promise<Type<any>>): void {
    this.componentRegistry.set(name, loader);
  }
  
  async loadComponent(
    name: string, 
    container: ViewContainerRef, 
    config?: DynamicComponentConfig
  ): Promise<ComponentRef<any> | null> {
    const loader = this.componentRegistry.get(name);
    if (!loader) {
      console.error(`Component '${name}' not found in registry`);
      return null;
    }
    
    try {
      const componentType = await loader();
      const componentRef = container.createComponent(componentType);
      
      // Set inputs
      if (config?.inputs) {
        Object.keys(config.inputs).forEach(key => {
          componentRef.instance[key] = config.inputs![key];
        });
      }
      
      // Bind outputs
      if (config?.outputs) {
        Object.keys(config.outputs).forEach(key => {
          if (componentRef.instance[key]) {
            componentRef.instance[key].subscribe(config.outputs![key]);
          }
        });
      }
      
      // Trigger change detection
      componentRef.changeDetectorRef.detectChanges();
      
      return componentRef;
    } catch (error) {
      console.error(`Failed to load component '${name}':`, error);
      return null;
    }
  }
  
  getAvailableComponents(): string[] {
    return Array.from(this.componentRegistry.keys());
  }
}

// Usage component
@Component({
  selector: 'app-advanced-loader',
  template: `
    <div class="advanced-loader">
      <div class="component-selector">
        <select [(ngModel)]="selectedComponent">
          <option value="">Select a component</option>
          <option *ngFor="let comp of availableComponents" [value]="comp">
            {{comp}}
          </option>
        </select>
        <button (click)="loadSelectedComponent()" [disabled]="!selectedComponent">
          Load Component
        </button>
      </div>
      
      <div class="dynamic-content" #dynamicContainer></div>
    </div>
  `
})
export class AdvancedLoaderComponent implements OnInit {
  @ViewChild('dynamicContainer', { read: ViewContainerRef }) 
  container!: ViewContainerRef;
  
  selectedComponent = '';
  availableComponents: string[] = [];
  
  constructor(private dynamicService: DynamicComponentService) {}
  
  ngOnInit(): void {
    this.availableComponents = this.dynamicService.getAvailableComponents();
  }
  
  async loadSelectedComponent(): Promise<void> {
    if (!this.selectedComponent) return;
    
    const config: DynamicComponentConfig = {
      inputs: this.getInputsForComponent(this.selectedComponent),
      outputs: {
        closeEvent: () => this.container.clear(),
        dataChange: (data: any) => console.log('Data changed:', data)
      }
    };
    
    await this.dynamicService.loadComponent(
      this.selectedComponent, 
      this.container, 
      config
    );
  }
  
  private getInputsForComponent(componentName: string): { [key: string]: any } {
    switch (componentName) {
      case 'user-card':
        return {
          user: { id: 1, name: 'John Doe', email: 'john@example.com' },
          editable: true
        };
      case 'data-table':
        return {
          data: [{ id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }],
          columns: ['id', 'name']
        };
      case 'chart':
        return {
          data: [10, 20, 30, 40, 50],
          type: 'line',
          title: 'Sample Chart'
        };
      default:
        return {};
    }
  }
}
```

**Dynamic Component with Custom Injector:**

```typescript
@Component({
  selector: 'app-injector-demo',
  template: `
    <div class="injector-demo">
      <button (click)="loadComponentWithCustomInjector()">Load with Custom Injector</button>
      <div #container></div>
    </div>
  `
})
export class InjectorDemoComponent {
  @ViewChild('container', { read: ViewContainerRef }) 
  container!: ViewContainerRef;
  
  constructor(private injector: Injector) {}
  
  loadComponentWithCustomInjector(): void {
    // Create custom injector with additional services
    const customInjector = Injector.create({
      providers: [
        { provide: 'CUSTOM_CONFIG', useValue: { theme: 'dark', lang: 'en' } },
        { provide: 'API_URL', useValue: 'https://api.example.com' },
        CustomService
      ],
      parent: this.injector
    });
    
    const componentRef = this.container.createComponent(CustomInjectableComponent, {
      injector: customInjector
    });
    
    componentRef.instance.title = 'Component with Custom Injector';
  }
}

@Component({
  selector: 'app-custom-injectable',
  template: `
    <div class="custom-component">
      <h3>{{title}}</h3>
      <p>Config: {{config | json}}</p>
      <p>API URL: {{apiUrl}}</p>
      <p>Custom Service Data: {{customData}}</p>
    </div>
  `
})
export class CustomInjectableComponent {
  @Input() title = '';
  
  config = inject('CUSTOM_CONFIG');
  apiUrl = inject('API_URL');
  customData = inject(CustomService).getData();
}

@Injectable()
export class CustomService {
  getData(): string {
    return 'Data from custom service';
  }
}
```

**Best Practices:**

1. **Memory Management**: Always destroy components when no longer needed
2. **Error Handling**: Handle component loading failures gracefully
3. **Type Safety**: Use proper TypeScript types for dynamic components
4. **Lazy Loading**: Use dynamic imports for better performance
5. **Service Registry**: Maintain a registry of available components
6. **Input Validation**: Validate inputs before passing to dynamic components

[Back to Components and Templates](#components-and-templates)

### 106. What are component factories?

**Answer:**
Component factories are deprecated in Angular 13+ in favor of the simpler `ViewContainerRef.createComponent()` method. However, understanding them is important for legacy code and migration.

**Legacy Component Factory Pattern (Deprecated):**

```typescript
// Legacy approach (Angular < 13)
@Component({
  selector: 'app-factory-demo',
  template: `
    <div class="factory-demo">
      <button (click)="createComponent()">Create Component</button>
      <div #container></div>
    </div>
  `
})
export class FactoryDemoComponent {
  @ViewChild('container', { read: ViewContainerRef }) 
  container!: ViewContainerRef;
  
  constructor(
    private componentFactoryResolver: ComponentFactoryResolver,
    private injector: Injector
  ) {}
  
  createComponent(): void {
    // Step 1: Resolve component factory
    const factory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent);
    
    // Step 2: Create component using factory
    const componentRef = this.container.createComponent(
      factory,
      undefined,
      this.injector
    );
    
    // Step 3: Set component properties
    componentRef.instance.title = 'Created by Factory';
    componentRef.instance.data = { message: 'Hello from factory!' };
    
    // Step 4: Listen to component events
    componentRef.instance.closeEvent.subscribe(() => {
      componentRef.destroy();
    });
  }
}

@Component({
  selector: 'app-dynamic',
  template: `
    <div class="dynamic-component">
      <h3>{{title}}</h3>
      <p>{{data.message}}</p>
      <button (click)="close()">Close</button>
    </div>
  `
})
export class DynamicComponent {
  @Input() title = '';
  @Input() data: any = {};
  @Output() closeEvent = new EventEmitter<void>();
  
  close(): void {
    this.closeEvent.emit();
  }
}
```

**Modern Approach (Angular 13+):**

```typescript
@Component({
  selector: 'app-modern-dynamic',
  template: `
    <div class="modern-dynamic">
      <button (click)="createComponent()">Create Component (Modern)</button>
      <button (click)="createWithInjector()">Create with Custom Injector</button>
      <button (click)="clearAll()">Clear All</button>
      <div #container></div>
    </div>
  `
})
export class ModernDynamicComponent {
  @ViewChild('container', { read: ViewContainerRef }) 
  container!: ViewContainerRef;
  
  constructor(private injector: Injector) {}
  
  createComponent(): void {
    // Modern approach - no factory needed
    const componentRef = this.container.createComponent(DynamicComponent);
    
    // Set properties directly
    componentRef.instance.title = 'Modern Creation';
    componentRef.instance.data = { message: 'No factory needed!' };
    
    // Handle events
    componentRef.instance.closeEvent.subscribe(() => {
      componentRef.destroy();
    });
  }
  
  createWithInjector(): void {
    // Create with custom injector
    const customInjector = Injector.create({
      providers: [
        { provide: 'CUSTOM_DATA', useValue: { theme: 'dark' } }
      ],
      parent: this.injector
    });
    
    const componentRef = this.container.createComponent(DynamicComponent, {
      injector: customInjector
    });
    
    componentRef.instance.title = 'With Custom Injector';
    componentRef.instance.data = { message: 'Custom injector used!' };
  }
  
  clearAll(): void {
    this.container.clear();
  }
}
```

[Back to Components and Templates](#components-and-templates)

### 107. How do you pass data to dynamically created components?

**Answer:**
There are several ways to pass data to dynamically created components: direct property assignment, dependency injection, and input/output binding.

**Direct Property Assignment:**

```typescript
@Component({
  template: `
    <button (click)="createUserComponent()">Create User Component</button>
    <div #container></div>
  `
})
export class DataPassingComponent {
  @ViewChild('container', { read: ViewContainerRef }) 
  container!: ViewContainerRef;
  
  createUserComponent(): void {
    const componentRef = this.container.createComponent(UserDisplayComponent);
    
    // Direct property assignment
    componentRef.instance.user = {
      id: 1,
      name: 'John Doe',
      email: 'john@example.com',
      role: 'admin'
    };
    
    componentRef.instance.settings = {
      showEmail: true,
      editable: false,
      theme: 'dark'
    };
    
    // Bind to component events
    componentRef.instance.userUpdated.subscribe((updatedUser) => {
      console.log('User updated:', updatedUser);
    });
    
    // Trigger change detection
    componentRef.changeDetectorRef.detectChanges();
  }
}

@Component({
  selector: 'app-user-display',
  template: `
    <div class="user-display" [attr.data-theme]="settings?.theme">
      <h3>{{user?.name}}</h3>
      <p *ngIf="settings?.showEmail">{{user?.email}}</p>
      <p>Role: {{user?.role}}</p>
      
      <button *ngIf="settings?.editable" (click)="editUser()">Edit</button>
    </div>
  `
})
export class UserDisplayComponent {
  @Input() user: User | null = null;
  @Input() settings: UserSettings | null = null;
  @Output() userUpdated = new EventEmitter<User>();
  
  editUser(): void {
    if (this.user) {
      // Simulate user edit
      const updatedUser = { ...this.user, name: this.user.name + ' (edited)' };
      this.userUpdated.emit(updatedUser);
    }
  }
}

interface User {
  id: number;
  name: string;
  email: string;
  role: string;
}

interface UserSettings {
  showEmail: boolean;
  editable: boolean;
  theme: string;
}
```

**Using Custom Injector for Data:**

```typescript
// Data service for injection
@Injectable()
export class ComponentDataService {
  constructor(private data: any) {}
  
  getData(): any {
    return this.data;
  }
}

@Component({
  template: `
    <div class="injector-data-demo">
      <button (click)="createComponentWithData()">Create with Injected Data</button>
      <div #container></div>
    </div>
  `
})
export class InjectorDataComponent {
  @ViewChild('container', { read: ViewContainerRef }) 
  container!: ViewContainerRef;
  
  constructor(private parentInjector: Injector) {}
  
  createComponentWithData(): void {
    const componentData = {
      title: 'Dynamic Component',
      items: ['Item 1', 'Item 2', 'Item 3'],
      config: { color: 'blue', size: 'large' }
    };
    
    // Create custom injector with data
    const customInjector = Injector.create({
      providers: [
        { provide: ComponentDataService, useValue: new ComponentDataService(componentData) },
        { provide: 'COMPONENT_CONFIG', useValue: componentData.config },
        { provide: 'ITEMS', useValue: componentData.items }
      ],
      parent: this.parentInjector
    });
    
    const componentRef = this.container.createComponent(InjectedDataComponent, {
      injector: customInjector
    });
    
    componentRef.instance.title = componentData.title;
  }
}

@Component({
  selector: 'app-injected-data',
  template: `
    <div class="injected-component">
      <h3>{{title}}</h3>
      
      <div class="data-section">
        <h4>Injected Data:</h4>
        <pre>{{injectedData | json}}</pre>
      </div>
      
      <div class="config-section">
        <h4>Config:</h4>
        <p>Color: {{config.color}}</p>
        <p>Size: {{config.size}}</p>
      </div>
      
      <div class="items-section">
        <h4>Items:</h4>
        <ul>
          <li *ngFor="let item of items">{{item}}</li>
        </ul>
      </div>
    </div>
  `
})
export class InjectedDataComponent {
  @Input() title = '';
  
  injectedData = this.dataService.getData();
  config = inject('COMPONENT_CONFIG');
  items = inject('ITEMS');
  
  constructor(private dataService: ComponentDataService) {}
}
```

**Complex Data Passing with Services:**

```typescript
// Shared data service
@Injectable({ providedIn: 'root' })
export class SharedDataService {
  private dataSubject = new BehaviorSubject<any>(null);
  data$ = this.dataSubject.asObservable();
  
  setData(data: any): void {
    this.dataSubject.next(data);
  }
  
  updateData(updates: Partial<any>): void {
    const currentData = this.dataSubject.value;
    this.dataSubject.next({ ...currentData, ...updates });
  }
}

@Component({
  template: `
    <div class="complex-data-demo">
      <div class="controls">
        <input [(ngModel)]="newItemName" placeholder="New item name" />
        <button (click)="addItem()">Add Item</button>
        <button (click)="createComponent()">Create Component</button>
        <button (click)="updateSharedData()">Update Shared Data</button>
      </div>
      
      <div #container></div>
    </div>
  `
})
export class ComplexDataComponent {
  @ViewChild('container', { read: ViewContainerRef }) 
  container!: ViewContainerRef;
  
  newItemName = '';
  items: string[] = ['Initial Item'];
  
  constructor(private sharedDataService: SharedDataService) {}
  
  addItem(): void {
    if (this.newItemName.trim()) {
      this.items.push(this.newItemName.trim());
      this.newItemName = '';
    }
  }
  
  createComponent(): void {
    // Set initial data in shared service
    this.sharedDataService.setData({
      items: [...this.items],
      timestamp: new Date().toISOString(),
      componentId: Math.random().toString(36).substr(2, 9)
    });
    
    const componentRef = this.container.createComponent(SharedDataComponent);
    
    // Pass additional data directly
    componentRef.instance.localData = {
      createdBy: 'ComplexDataComponent',
      version: '1.0'
    };
    
    // Handle component events
    componentRef.instance.itemAdded.subscribe((item: string) => {
      this.items.push(item);
      this.sharedDataService.updateData({ items: [...this.items] });
    });
  }
  
  updateSharedData(): void {
    this.sharedDataService.updateData({
      lastUpdated: new Date().toISOString(),
      updateCount: (this.sharedDataService.data$ | async)?.updateCount || 0 + 1
    });
  }
}

@Component({
  selector: 'app-shared-data',
  template: `
    <div class="shared-data-component">
      <h3>Shared Data Component</h3>
      
      <div class="shared-data" *ngIf="sharedData$ | async as data">
        <h4>Shared Data:</h4>
        <p>Component ID: {{data.componentId}}</p>
        <p>Created: {{data.timestamp | date:'short'}}</p>
        <p>Items count: {{data.items?.length}}</p>
        
        <ul>
          <li *ngFor="let item of data.items">{{item}}</li>
        </ul>
      </div>
      
      <div class="local-data">
        <h4>Local Data:</h4>
        <pre>{{localData | json}}</pre>
      </div>
      
      <div class="actions">
        <input #newItem placeholder="Add item" />
        <button (click)="addItem(newItem.value); newItem.value = ''">Add Item</button>
      </div>
    </div>
  `
})
export class SharedDataComponent {
  @Input() localData: any = {};
  @Output() itemAdded = new EventEmitter<string>();
  
  sharedData$ = this.sharedDataService.data$;
  
  constructor(private sharedDataService: SharedDataService) {}
  
  addItem(itemName: string): void {
    if (itemName.trim()) {
      this.itemAdded.emit(itemName.trim());
    }
  }
}
```

**Data Passing Strategies Comparison:**

| Method | Use Case | Pros | Cons |
|--------|----------|------|------|
| **Direct Assignment** | Simple, static data | Easy, direct | No reactivity |
| **Custom Injector** | Configuration, services | Type-safe, injectable | More setup |
| **Shared Service** | Dynamic, reactive data | Reactive, shared | Global state |
| **Input Properties** | Component interface | Standard Angular | Manual binding |

**Best Practices:**
1. Use direct assignment for simple, static data
2. Use custom injectors for configuration and services
3. Use shared services for reactive, dynamic data
4. Always trigger change detection after setting properties
5. Handle component cleanup and memory leaks
6. Validate data before passing to components

[Back to Components and Templates](#components-and-templates)

### 108. What is view encapsulation and its modes?

**Answer:**
View encapsulation controls how component styles are scoped and applied. Angular provides three encapsulation modes: Emulated (default), ShadowDom, and None.

**ViewEncapsulation.Emulated (Default):**

```typescript
@Component({
  selector: 'app-emulated',
  encapsulation: ViewEncapsulation.Emulated, // Default
  template: `
    <div class="container">
      <h3 class="title">Emulated Encapsulation</h3>
      <p class="content">This component uses emulated encapsulation.</p>
      <button class="btn">Click me</button>
    </div>
  `,
  styles: [`
    .container {
      border: 2px solid blue;
      padding: 1rem;
      margin: 1rem;
    }
    .title {
      color: blue;
      font-size: 1.5rem;
    }
    .content {
      color: darkblue;
      margin: 0.5rem 0;
    }
    .btn {
      background: blue;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      cursor: pointer;
    }
  `]
})
export class EmulatedComponent {}

// Generated HTML will look like:
// <app-emulated _ngcontent-abc-123>
//   <div class="container" _ngcontent-abc-123>
//     <h3 class="title" _ngcontent-abc-123>Emulated Encapsulation</h3>
//     ...
//   </div>
// </app-emulated>

// Generated CSS will look like:
// .container[_ngcontent-abc-123] { border: 2px solid blue; ... }
// .title[_ngcontent-abc-123] { color: blue; ... }
```

**ViewEncapsulation.ShadowDom:**

```typescript
@Component({
  selector: 'app-shadow-dom',
  encapsulation: ViewEncapsulation.ShadowDom,
  template: `
    <div class="container">
      <h3 class="title">Shadow DOM Encapsulation</h3>
      <p class="content">This component uses native Shadow DOM.</p>
      <button class="btn">Click me</button>
      
      <!-- Slot for content projection -->
      <slot name="projected"></slot>
    </div>
  `,
  styles: [`
    :host {
      display: block;
      font-family: Arial, sans-serif;
    }
    .container {
      border: 2px solid green;
      padding: 1rem;
      margin: 1rem;
    }
    .title {
      color: green;
      font-size: 1.5rem;
    }
    .content {
      color: darkgreen;
      margin: 0.5rem 0;
    }
    .btn {
      background: green;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      cursor: pointer;
    }
    /* Shadow DOM specific selectors */
    ::slotted(p) {
      font-style: italic;
      color: purple;
    }
  `]
})
export class ShadowDomComponent {}

// Usage with content projection:
// <app-shadow-dom>
//   <p slot="projected">This content is projected into shadow DOM</p>
// </app-shadow-dom>
```

**ViewEncapsulation.None:**

```typescript
@Component({
  selector: 'app-none-encapsulation',
  encapsulation: ViewEncapsulation.None,
  template: `
    <div class="global-container">
      <h3 class="global-title">No Encapsulation</h3>
      <p class="global-content">These styles are global!</p>
      <button class="global-btn">Global Button</button>
    </div>
  `,
  styles: [`
    /* These styles will be global and affect other components */
    .global-container {
      border: 2px solid red;
      padding: 1rem;
      margin: 1rem;
    }
    .global-title {
      color: red;
      font-size: 1.5rem;
    }
    .global-content {
      color: darkred;
      margin: 0.5rem 0;
    }
    .global-btn {
      background: red;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      cursor: pointer;
    }
    
    /* This will affect ALL buttons in the application */
    button {
      border-radius: 4px;
      font-weight: bold;
    }
  `]
})
export class NoneEncapsulationComponent {}
```

**Comparison Demo Component:**

```typescript
@Component({
  selector: 'app-encapsulation-demo',
  template: `
    <div class="demo-container">
      <h2>View Encapsulation Demo</h2>
      
      <div class="demo-section">
        <h3>Emulated Encapsulation (Default)</h3>
        <app-emulated></app-emulated>
      </div>
      
      <div class="demo-section">
        <h3>Shadow DOM Encapsulation</h3>
        <app-shadow-dom>
          <p slot="projected">Projected content with ::slotted styles</p>
        </app-shadow-dom>
      </div>
      
      <div class="demo-section">
        <h3>No Encapsulation</h3>
        <app-none-encapsulation></app-none-encapsulation>
      </div>
      
      <div class="demo-section">
        <h3>Style Inheritance Test</h3>
        <div class="container">
          <h4 class="title">This should be affected by None encapsulation</h4>
          <button class="btn">This button inherits global styles</button>
        </div>
      </div>
    </div>
  `,
  styles: [`
    .demo-container {
      padding: 2rem;
      background: #f5f5f5;
    }
    .demo-section {
      margin: 2rem 0;
      padding: 1rem;
      background: white;
      border-radius: 4px;
    }
    .demo-section h3 {
      margin-top: 0;
      color: #333;
    }
  `]
})
export class EncapsulationDemoComponent {}
```

**Advanced Encapsulation Patterns:**

```typescript
// Dynamic encapsulation based on conditions
@Component({
  selector: 'app-dynamic-encapsulation',
  template: `
    <div class="dynamic-component">
      <h3>Dynamic Encapsulation</h3>
      <p>Current mode: {{encapsulationMode}}</p>
      <button (click)="toggleEncapsulation()">Toggle Encapsulation</button>
      
      <div class="styled-content">
        <p class="special-text">This text styling depends on encapsulation mode</p>
      </div>
    </div>
  `,
  styles: [`
    .dynamic-component {
      border: 2px dashed orange;
      padding: 1rem;
      margin: 1rem;
    }
    .special-text {
      color: orange;
      font-weight: bold;
      background: #fff3cd;
      padding: 0.5rem;
    }
  `]
})
export class DynamicEncapsulationComponent {
  encapsulationMode = 'Emulated';
  
  // Note: Encapsulation mode cannot be changed at runtime
  // This is just for demonstration of different modes
  toggleEncapsulation(): void {
    // In real scenarios, you would have different components
    // with different encapsulation modes
    console.log('Encapsulation mode is set at compile time');
  }
}

// Host styling with different encapsulation modes
@Component({
  selector: 'app-host-styling',
  encapsulation: ViewEncapsulation.Emulated,
  template: `
    <div class="host-content">
      <h4>Host Styling Example</h4>
      <p>The host element has custom styling</p>
    </div>
  `,
  styles: [`
    :host {
      display: block;
      border: 3px solid purple;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem;
      background: linear-gradient(45deg, #f0f0ff, #e0e0ff);
    }
    
    :host(.highlighted) {
      box-shadow: 0 0 10px purple;
      transform: scale(1.02);
    }
    
    :host-context(.dark-theme) {
      background: linear-gradient(45deg, #2a2a2a, #1a1a1a);
      color: white;
      border-color: #666;
    }
    
    .host-content {
      text-align: center;
    }
  `]
})
export class HostStylingComponent {}
```

**Encapsulation Mode Comparison:**

| Mode | DOM Output | Style Scope | Performance | Use Case |
|------|------------|-------------|-------------|-----------|
| **Emulated** | Attribute selectors | Component-scoped | Good | Default choice |
| **ShadowDom** | Native Shadow DOM | Truly isolated | Slower | Web Components |
| **None** | No modification | Global | Best | Global styles |

**When to Use Each Mode:**

**Emulated (Default):**
- Most common use case
- Good balance of encapsulation and performance
- Works in all browsers
- Easy to debug

**ShadowDom:**
- True style isolation needed
- Building web components
- Need ::slotted selectors
- Modern browsers only

**None:**
- Global utility components
- Third-party component integration
- Shared style libraries
- Legacy code integration

**Best Practices:**
1. Use Emulated (default) for most components
2. Use ShadowDom for true isolation
3. Use None sparingly and with caution
4. Consider global styles impact with None
5. Use :host selectors for host element styling
6. Test cross-browser compatibility with ShadowDom

[Back to Components and Templates](#components-and-templates)

### 109. How do you use `:host` and `::ng-deep`?

**Answer:**
`:host` targets the component's host element, while `::ng-deep` (deprecated) pierces view encapsulation. Modern alternatives include CSS custom properties and global styles.

**:host Selector Usage:**

```typescript
@Component({
  selector: 'app-host-demo',
  template: `
    <div class="content">
      <h3>Host Selector Demo</h3>
      <p>Check the styling of this component's host element</p>
      <button (click)="toggleHighlight()">Toggle Highlight</button>
      <button (click)="toggleTheme()">Toggle Theme</button>
    </div>
  `,
  styles: [`
    /* Basic host styling */
    :host {
      display: block;
      border: 2px solid #ccc;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem;
      background: #f9f9f9;
      transition: all 0.3s ease;
    }
    
    /* Host with class conditions */
    :host(.highlighted) {
      border-color: #007bff;
      background: #e7f3ff;
      box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
      transform: translateY(-2px);
    }
    
    :host(.dark-theme) {
      background: #2a2a2a;
      border-color: #555;
      color: white;
    }
    
    :host(.dark-theme.highlighted) {
      border-color: #66b3ff;
      background: #1a3a5c;
    }
    
    /* Host context - style based on ancestor */
    :host-context(.mobile-view) {
      margin: 0.5rem;
      padding: 0.5rem;
      font-size: 0.9rem;
    }
    
    :host-context(.print-mode) {
      border: 1px solid black;
      background: white;
      color: black;
      box-shadow: none;
    }
    
    /* Attribute-based host styling */
    :host([data-size="large"]) {
      padding: 2rem;
      font-size: 1.2rem;
    }
    
    :host([data-size="small"]) {
      padding: 0.5rem;
      font-size: 0.8rem;
    }
    
    /* Host with pseudo-classes */
    :host(:hover) {
      border-color: #007bff;
    }
    
    :host(:focus-within) {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }
    
    .content {
      text-align: center;
    }
  `]
})
export class HostDemoComponent {
  @HostBinding('class.highlighted') isHighlighted = false;
  @HostBinding('class.dark-theme') isDarkTheme = false;
  @HostBinding('attr.data-size') size = 'medium';
  
  toggleHighlight(): void {
    this.isHighlighted = !this.isHighlighted;
  }
  
  toggleTheme(): void {
    this.isDarkTheme = !this.isDarkTheme;
  }
}
```

**::ng-deep Usage (Deprecated but Still Used):**

```typescript
@Component({
  selector: 'app-deep-demo',
  template: `
    <div class="wrapper">
      <h3>Deep Selector Demo</h3>
      <p>This component styles child components deeply</p>
      
      <!-- Third-party component that we want to style -->
      <mat-card>
        <mat-card-header>
          <mat-card-title>Card Title</mat-card-title>
        </mat-card-header>
        <mat-card-content>
          <p>Card content that we want to customize</p>
          <mat-button color="primary">Button</mat-button>
        </mat-card-content>
      </mat-card>
      
      <!-- Custom child component -->
      <app-child-component>
        <div class="projected-content">
          <p>Projected content to be styled</p>
        </div>
      </app-child-component>
    </div>
  `,
  styles: [`
    .wrapper {
      padding: 1rem;
    }
    
    /* WARNING: ::ng-deep is deprecated */
    /* Use only when necessary for third-party components */
    :host ::ng-deep .mat-card {
      background: linear-gradient(45deg, #f0f0ff, #e0e0ff);
      border-radius: 12px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    
    :host ::ng-deep .mat-card-title {
      color: #6a1b9a;
      font-weight: bold;
    }
    
    :host ::ng-deep .mat-button {
      border-radius: 20px;
      font-weight: bold;
    }
    
    /* Style projected content in child components */
    :host ::ng-deep app-child-component .projected-content {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 4px;
      padding: 1rem;
    }
    
    :host ::ng-deep app-child-component .projected-content p {
      color: #856404;
      font-style: italic;
    }
  `]
})
export class DeepDemoComponent {}
```

**Modern Alternatives to ::ng-deep:**

```typescript
// 1. CSS Custom Properties (Recommended)
@Component({
  selector: 'app-css-vars-parent',
  template: `
    <div class="parent-container">
      <h3>CSS Custom Properties Demo</h3>
      <app-css-vars-child></app-css-vars-child>
      
      <div class="theme-controls">
        <button (click)="setTheme('blue')">Blue Theme</button>
        <button (click)="setTheme('green')">Green Theme</button>
        <button (click)="setTheme('red')">Red Theme</button>
      </div>
    </div>
  `,
  styles: [`
    .parent-container {
      /* Define CSS custom properties */
      --primary-color: #007bff;
      --secondary-color: #6c757d;
      --border-radius: 8px;
      --spacing: 1rem;
      
      padding: var(--spacing);
      border: 2px solid var(--primary-color);
      border-radius: var(--border-radius);
    }
    
    .parent-container.blue-theme {
      --primary-color: #007bff;
      --secondary-color: #0056b3;
    }
    
    .parent-container.green-theme {
      --primary-color: #28a745;
      --secondary-color: #1e7e34;
    }
    
    .parent-container.red-theme {
      --primary-color: #dc3545;
      --secondary-color: #c82333;
    }
    
    .theme-controls {
      margin-top: var(--spacing);
    }
    
    .theme-controls button {
      margin-right: 0.5rem;
      padding: 0.5rem 1rem;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
    }
  `]
})
export class CssVarsParentComponent {
  @HostBinding('class') themeClass = 'blue-theme';
  
  setTheme(theme: string): void {
    this.themeClass = `${theme}-theme`;
  }
}

@Component({
  selector: 'app-css-vars-child',
  template: `
    <div class="child-container">
      <h4>Child Component</h4>
      <p>This component inherits CSS custom properties from parent</p>
      <button class="child-button">Child Button</button>
    </div>
  `,
  styles: [`
    .child-container {
      /* Use inherited CSS custom properties */
      background: var(--primary-color, #ccc);
      color: white;
      padding: var(--spacing, 1rem);
      border-radius: var(--border-radius, 4px);
      margin: var(--spacing, 1rem) 0;
    }
    
    .child-button {
      background: var(--secondary-color, #666);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: var(--border-radius, 4px);
      cursor: pointer;
    }
    
    .child-button:hover {
      opacity: 0.8;
    }
  `]
})
export class CssVarsChildComponent {}

// 2. Global Styles with Scoped Classes
// styles.css (global)
.theme-customizable .mat-card {
  background: var(--card-background, white);
  border-radius: var(--card-border-radius, 4px);
}

.theme-customizable .mat-button {
  border-radius: var(--button-border-radius, 4px);
}

@Component({
  selector: 'app-global-styles',
  template: `
    <div class="global-styles-demo">
      <h3>Global Styles Demo</h3>
      <mat-card>
        <mat-card-content>
          <p>This card is styled using global CSS with scoped classes</p>
          <mat-button color="primary">Styled Button</mat-button>
        </mat-card-content>
      </mat-card>
    </div>
  `,
  styles: [`
    .global-styles-demo {
      --card-background: linear-gradient(45deg, #e3f2fd, #bbdefb);
      --card-border-radius: 12px;
      --button-border-radius: 20px;
    }
  `]
})
export class GlobalStylesComponent {
  @HostBinding('class.theme-customizable') themeClass = true;
}
```

**Advanced Host Patterns:**

```typescript
@Component({
  selector: 'app-advanced-host',
  template: `
    <div class="content">
      <h3>Advanced Host Patterns</h3>
      <p>State: {{state}}</p>
      <p>Loading: {{loading}}</p>
      <button (click)="changeState()">Change State</button>
    </div>
  `,
  styles: [`
    /* Complex host selectors */
    :host {
      display: block;
      transition: all 0.3s ease;
    }
    
    /* Multiple class conditions */
    :host(.loading.error) {
      border: 2px solid red;
      background: #ffe6e6;
    }
    
    :host(.loading:not(.error)) {
      border: 2px solid orange;
      background: #fff3cd;
    }
    
    /* Pseudo-class combinations */
    :host(.interactive:hover:not(.disabled)) {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    
    /* Host context with complex selectors */
    :host-context(.mobile-view.portrait) {
      width: 100%;
      margin: 0;
    }
    
    :host-context(.desktop-view) :host(.maximized) {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
    }
  `]
})
export class AdvancedHostComponent {
  @HostBinding('class.loading') loading = false;
  @HostBinding('class.error') error = false;
  @HostBinding('class.interactive') interactive = true;
  @HostBinding('class.disabled') disabled = false;
  
  state = 'idle';
  
  changeState(): void {
    this.loading = !this.loading;
    this.state = this.loading ? 'loading' : 'idle';
  }
}
```

**Best Practices:**

**For :host:**
1. Use for styling the component's host element
2. Combine with @HostBinding for dynamic classes
3. Use :host-context for ancestor-based styling
4. Leverage pseudo-classes and attribute selectors

**Avoiding ::ng-deep:**
1. Use CSS custom properties for themeable components
2. Use global styles with scoped class names
3. Create wrapper components for third-party libraries
4. Use ViewEncapsulation.None sparingly

**Migration from ::ng-deep:**
```typescript
// Old approach (deprecated)
:host ::ng-deep .third-party-component {
  color: red;
}

// New approach with CSS custom properties
:host {
  --third-party-text-color: red;
}

// Or global styles
.my-component-theme .third-party-component {
  color: red;
}
```

[Back to Components and Templates](#components-and-templates)

### 110. What are host bindings and host listeners?

**Answer:**
Host bindings and listeners allow components to interact with their host element by binding properties/attributes and listening to events directly on the host element.

**@HostBinding - Binding Properties to Host Element:**

```typescript
@Component({
  selector: 'app-host-binding-demo',
  template: `
    <div class="content">
      <h3>Host Binding Demo</h3>
      <p>Check the host element's attributes and classes in DevTools</p>
      
      <div class="controls">
        <button (click)="toggleActive()">Toggle Active ({{isActive}})</button>
        <button (click)="toggleDisabled()">Toggle Disabled ({{isDisabled}})</button>
        <button (click)="changeSize()">Change Size ({{currentSize}})</button>
        <button (click)="updateTitle()">Update Title</button>
      </div>
      
      <div class="status">
        <p>Width: {{width}}px</p>
        <p>Height: {{height}}px</p>
        <p>Background: {{backgroundColor}}</p>
      </div>
    </div>
  `,
  styles: [`
    :host {
      display: block;
      border: 2px solid #ccc;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem;
      transition: all 0.3s ease;
    }
    
    :host(.active) {
      border-color: #007bff;
      box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
    }
    
    :host(.disabled) {
      opacity: 0.6;
      pointer-events: none;
    }
    
    :host(.size-large) {
      font-size: 1.2rem;
    }
    
    :host(.size-small) {
      font-size: 0.8rem;
    }
    
    .controls button {
      margin: 0.25rem;
      padding: 0.5rem 1rem;
    }
    
    .status {
      background: #f8f9fa;
      padding: 1rem;
      border-radius: 4px;
      margin-top: 1rem;
    }
  `]
})
export class HostBindingDemoComponent {
  // Bind CSS classes
  @HostBinding('class.active') isActive = false;
  @HostBinding('class.disabled') isDisabled = false;
  @HostBinding('class.size-large') isLarge = false;
  @HostBinding('class.size-small') isSmall = false;
  
  // Bind attributes
  @HostBinding('attr.data-component') componentName = 'host-binding-demo';
  @HostBinding('attr.data-version') version = '1.0.0';
  @HostBinding('attr.title') tooltipTitle = 'Host Binding Demo Component';
  @HostBinding('attr.role') role = 'region';
  @HostBinding('attr.aria-label') ariaLabel = 'Interactive demo component';
  
  // Bind styles directly
  @HostBinding('style.width.px') width = 400;
  @HostBinding('style.height.px') height = 300;
  @HostBinding('style.backgroundColor') backgroundColor = '#ffffff';
  @HostBinding('style.border-radius.px') borderRadius = 8;
  
  // Bind properties
  @HostBinding('id') componentId = 'host-demo-' + Math.random().toString(36).substr(2, 9);
  @HostBinding('tabindex') tabIndex = 0;
  
  currentSize = 'medium';
  
  toggleActive(): void {
    this.isActive = !this.isActive;
    this.backgroundColor = this.isActive ? '#e7f3ff' : '#ffffff';
  }
  
  toggleDisabled(): void {
    this.isDisabled = !this.isDisabled;
    this.tabIndex = this.isDisabled ? -1 : 0;
  }
  
  changeSize(): void {
    this.isLarge = false;
    this.isSmall = false;
    
    switch (this.currentSize) {
      case 'medium':
        this.currentSize = 'large';
        this.isLarge = true;
        this.width = 500;
        this.height = 350;
        break;
      case 'large':
        this.currentSize = 'small';
        this.isSmall = true;
        this.width = 300;
        this.height = 200;
        break;
      default:
        this.currentSize = 'medium';
        this.width = 400;
        this.height = 300;
    }
  }
  
  updateTitle(): void {
    this.tooltipTitle = `Updated at ${new Date().toLocaleTimeString()}`;
  }
}
```

**@HostListener - Listening to Host Element Events:**

```typescript
@Component({
  selector: 'app-host-listener-demo',
  template: `
    <div class="content">
      <h3>Host Listener Demo</h3>
      <p>Interact with this component to see host listeners in action</p>
      
      <div class="event-log">
        <h4>Event Log:</h4>
        <div class="log-entries">
          <div *ngFor="let entry of eventLog; let i = index" 
               class="log-entry"
               [class.recent]="i >= eventLog.length - 3">
            <span class="timestamp">{{entry.timestamp}}</span>
            <span class="event-type">{{entry.type}}</span>
            <span class="event-details">{{entry.details}}</span>
          </div>
        </div>
        <button (click)="clearLog()">Clear Log</button>
      </div>
      
      <div class="interaction-area">
        <p>Mouse position: ({{mouseX}}, {{mouseY}})</p>
        <p>Click count: {{clickCount}}</p>
        <p>Key presses: {{keyPressCount}}</p>
        <p>Focus state: {{hasFocus ? 'Focused' : 'Not focused'}}</p>
      </div>
    </div>
  `,
  styles: [`
    :host {
      display: block;
      border: 2px solid #28a745;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem;
      min-height: 200px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    :host(:hover) {
      border-color: #20c997;
      background-color: #f8fff9;
    }
    
    :host(:focus) {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }
    
    :host(.mouse-down) {
      transform: scale(0.98);
      border-color: #1e7e34;
    }
    
    .event-log {
      background: #f8f9fa;
      border-radius: 4px;
      padding: 1rem;
      margin: 1rem 0;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .log-entry {
      display: flex;
      gap: 1rem;
      padding: 0.25rem;
      font-family: monospace;
      font-size: 0.8rem;
    }
    
    .log-entry.recent {
      background: #fff3cd;
      border-radius: 2px;
    }
    
    .timestamp {
      color: #6c757d;
      min-width: 80px;
    }
    
    .event-type {
      color: #007bff;
      font-weight: bold;
      min-width: 100px;
    }
    
    .interaction-area {
      background: #e7f3ff;
      padding: 1rem;
      border-radius: 4px;
      margin-top: 1rem;
    }
  `]
})
export class HostListenerDemoComponent {
  @HostBinding('tabindex') tabIndex = 0;
  @HostBinding('class.mouse-down') isMouseDown = false;
  
  eventLog: Array<{timestamp: string, type: string, details: string}> = [];
  mouseX = 0;
  mouseY = 0;
  clickCount = 0;
  keyPressCount = 0;
  hasFocus = false;
  
  // Mouse events
  @HostListener('click', ['$event'])
  onClick(event: MouseEvent): void {
    this.clickCount++;
    this.logEvent('click', `Button: ${event.button}, Coordinates: (${event.clientX}, ${event.clientY})`);
  }
  
  @HostListener('dblclick', ['$event'])
  onDoubleClick(event: MouseEvent): void {
    this.logEvent('dblclick', `Double click at (${event.clientX}, ${event.clientY})`);
  }
  
  @HostListener('mousedown', ['$event'])
  onMouseDown(event: MouseEvent): void {
    this.isMouseDown = true;
    this.logEvent('mousedown', `Button: ${event.button}`);
  }
  
  @HostListener('mouseup', ['$event'])
  onMouseUp(event: MouseEvent): void {
    this.isMouseDown = false;
    this.logEvent('mouseup', `Button: ${event.button}`);
  }
  
  @HostListener('mousemove', ['$event'])
  onMouseMove(event: MouseEvent): void {
    this.mouseX = event.clientX;
    this.mouseY = event.clientY;
    // Don't log every mouse move to avoid spam
  }
  
  @HostListener('mouseenter')
  onMouseEnter(): void {
    this.logEvent('mouseenter', 'Mouse entered component');
  }
  
  @HostListener('mouseleave')
  onMouseLeave(): void {
    this.logEvent('mouseleave', 'Mouse left component');
  }
  
  // Keyboard events
  @HostListener('keydown', ['$event'])
  onKeyDown(event: KeyboardEvent): void {
    this.keyPressCount++;
    this.logEvent('keydown', `Key: ${event.key}, Code: ${event.code}, Modifiers: ${this.getModifiers(event)}`);
    
    // Handle specific keys
    if (event.key === 'Escape') {
      this.clearLog();
    } else if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      this.clickCount++;
    }
  }
  
  @HostListener('keyup', ['$event'])
  onKeyUp(event: KeyboardEvent): void {
    this.logEvent('keyup', `Key: ${event.key}`);
  }
  
  // Focus events
  @HostListener('focus')
  onFocus(): void {
    this.hasFocus = true;
    this.logEvent('focus', 'Component gained focus');
  }
  
  @HostListener('blur')
  onBlur(): void {
    this.hasFocus = false;
    this.logEvent('blur', 'Component lost focus');
  }
  
  // Window events
  @HostListener('window:resize', ['$event'])
  onWindowResize(event: Event): void {
    const target = event.target as Window;
    this.logEvent('window:resize', `Window size: ${target.innerWidth}x${target.innerHeight}`);
  }
  
  @HostListener('window:scroll', ['$event'])
  onWindowScroll(event: Event): void {
    this.logEvent('window:scroll', `Scroll Y: ${window.scrollY}`);
  }
  
  // Document events
  @HostListener('document:keydown.escape')
  onEscapeKey(): void {
    this.logEvent('document:escape', 'Escape key pressed anywhere in document');
  }
  
  private logEvent(type: string, details: string): void {
    this.eventLog.push({
      timestamp: new Date().toLocaleTimeString(),
      type,
      details
    });
    
    // Keep only last 20 entries
    if (this.eventLog.length > 20) {
      this.eventLog = this.eventLog.slice(-20);
    }
  }
  
  private getModifiers(event: KeyboardEvent): string {
    const modifiers = [];
    if (event.ctrlKey) modifiers.push('Ctrl');
    if (event.altKey) modifiers.push('Alt');
    if (event.shiftKey) modifiers.push('Shift');
    if (event.metaKey) modifiers.push('Meta');
    return modifiers.length > 0 ? modifiers.join('+') : 'None';
  }
  
  clearLog(): void {
    this.eventLog = [];
  }
}
```

**Advanced Host Patterns:**

```typescript
// Directive with host bindings and listeners
@Directive({
  selector: '[appInteractive]'
})
export class InteractiveDirective {
  @HostBinding('class.interactive') isInteractive = true;
  @HostBinding('attr.role') role = 'button';
  @HostBinding('attr.tabindex') tabIndex = 0;
  
  @HostListener('click')
  @HostListener('keydown.enter')
  @HostListener('keydown.space')
  onActivate(): void {
    console.log('Interactive element activated');
  }
  
  @HostListener('focus')
  onFocus(): void {
    this.isInteractive = true;
  }
  
  @HostListener('blur')
  onBlur(): void {
    this.isInteractive = false;
  }
}

// Component using both decorators and host metadata
@Component({
  selector: 'app-combined-host',
  template: `<div>Combined host bindings and listeners</div>`,
  host: {
    // Alternative syntax in component metadata
    'class': 'combined-host-component',
    '[attr.data-version]': 'version',
    '[class.active]': 'isActive',
    '(click)': 'onClick()',
    '(keydown.enter)': 'onEnterKey()'
  }
})
export class CombinedHostComponent {
  version = '2.0.0';
  isActive = false;
  
  // Also using decorators
  @HostBinding('style.border') border = '2px solid blue';
  @HostListener('mouseover') onMouseOver(): void {
    this.isActive = true;
  }
  
  @HostListener('mouseout') onMouseOut(): void {
    this.isActive = false;
  }
  
  onClick(): void {
    console.log('Clicked via host metadata');
  }
  
  onEnterKey(): void {
    console.log('Enter key via host metadata');
  }
}
```

**Best Practices:**

1. **Use @HostBinding for:**
   - Dynamic CSS classes
   - Accessibility attributes
   - Component state reflection
   - Style properties

2. **Use @HostListener for:**
   - User interaction events
   - Keyboard navigation
   - Window/document events
   - Accessibility events

3. **Performance considerations:**
   - Avoid expensive operations in frequently fired events
   - Use passive listeners when possible
   - Debounce or throttle high-frequency events

4. **Accessibility:**
   - Always include proper ARIA attributes
   - Handle keyboard navigation
   - Provide focus indicators
   - Support screen readers

[Back to Components and Templates](#components-and-templates)

### 111. How do you make HTTP requests in Angular?

[Back to HTTP and APIs](#http-and-apis)

### 112. What are HTTP interceptors and how do you use them?

[Back to HTTP and APIs](#http-and-apis)

### 113. How do you handle HTTP errors globally?

[Back to HTTP and APIs](#http-and-apis)

### 114. How do you implement caching for HTTP requests?

[Back to HTTP and APIs](#http-and-apis)

### 115. What is the difference between `HttpClient` and the old `Http` service?

[Back to HTTP and APIs](#http-and-apis)

### 116. How do you handle authentication with HTTP interceptors?

[Back to HTTP and APIs](#http-and-apis)

### 117. What are HTTP retry mechanisms and backoff strategies?

[Back to HTTP and APIs](#http-and-apis)

### 118. How do you cancel HTTP requests?

[Back to HTTP and APIs](#http-and-apis)

### 119. How do you handle file uploads and downloads?

[Back to HTTP and APIs](#http-and-apis)

### 120. What are HTTP headers and how to set them?

[Back to HTTP and APIs](#http-and-apis)

### 121. How do you mock HTTP requests for testing?

[Back to HTTP and APIs](#http-and-apis)

### 122. What is CORS and how to handle it?

[Back to HTTP and APIs](#http-and-apis)

### 123. How do you implement request/response transformation?

[Back to HTTP and APIs](#http-and-apis)

### 124. What are HTTP progress events?

[Back to HTTP and APIs](#http-and-apis)

### 125. How do you handle concurrent HTTP requests?

[Back to HTTP and APIs](#http-and-apis)

### 126. What are the different approaches to state management in Angular?

**Answer:**
Angular offers multiple approaches to state management, each suited for different use cases and application complexities. The choice depends on factors like application size, team preferences, performance requirements, and state complexity.

**1. Local Component State (Simple Applications):**

```typescript
// Simple component state with properties
@Component({
  selector: 'app-counter',
  template: `
    <div>
      <h3>Counter: {{count}}</h3>
      <button (click)="increment()">+</button>
      <button (click)="decrement()">-</button>
      <button (click)="reset()">Reset</button>
    </div>
  `
})
export class CounterComponent {
  count = 0;
  
  increment(): void {
    this.count++;
  }
  
  decrement(): void {
    this.count--;
  }
  
  reset(): void {
    this.count = 0;
  }
}

// Component state with reactive forms
@Component({
  selector: 'app-user-form',
  template: `
    <form [formGroup]="userForm" (ngSubmit)="onSubmit()">
      <input formControlName="name" placeholder="Name" />
      <input formControlName="email" placeholder="Email" />
      <button type="submit" [disabled]="userForm.invalid">Submit</button>
    </form>
    
    <div *ngIf="submitted">
      <h4>Form Data:</h4>
      <pre>{{formData | json}}</pre>
    </div>
  `
})
export class UserFormComponent {
  userForm: FormGroup;
  submitted = false;
  formData: any = null;
  
  constructor(private fb: FormBuilder) {
    this.userForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2)]],
      email: ['', [Validators.required, Validators.email]]
    });
  }
  
  onSubmit(): void {
    if (this.userForm.valid) {
      this.formData = this.userForm.value;
      this.submitted = true;
    }
  }
}
```

**2. Service-Based State Management (Medium Applications):**

```typescript
// Simple service with BehaviorSubject
@Injectable({ providedIn: 'root' })
export class UserStateService {
  private userSubject = new BehaviorSubject<User | null>(null);
  private loadingSubject = new BehaviorSubject<boolean>(false);
  private errorSubject = new BehaviorSubject<string | null>(null);
  
  user$ = this.userSubject.asObservable();
  loading$ = this.loadingSubject.asObservable();
  error$ = this.errorSubject.asObservable();
  
  constructor(private http: HttpClient) {}
  
  loadUser(id: string): void {
    this.loadingSubject.next(true);
    this.errorSubject.next(null);
    
    this.http.get<User>(`/api/users/${id}`).pipe(
      catchError(error => {
        this.errorSubject.next(error.message);
        return of(null);
      }),
      finalize(() => this.loadingSubject.next(false))
    ).subscribe(user => {
      this.userSubject.next(user);
    });
  }
  
  updateUser(user: User): void {
    this.loadingSubject.next(true);
    
    this.http.put<User>(`/api/users/${user.id}`, user).pipe(
      catchError(error => {
        this.errorSubject.next(error.message);
        return of(null);
      }),
      finalize(() => this.loadingSubject.next(false))
    ).subscribe(updatedUser => {
      if (updatedUser) {
        this.userSubject.next(updatedUser);
      }
    });
  }
  
  clearUser(): void {
    this.userSubject.next(null);
    this.errorSubject.next(null);
  }
}

// Advanced service with complex state
@Injectable({ providedIn: 'root' })
export class ShoppingCartService {
  private cartItemsSubject = new BehaviorSubject<CartItem[]>([]);
  private totalSubject = new BehaviorSubject<number>(0);
  
  cartItems$ = this.cartItemsSubject.asObservable();
  total$ = this.totalSubject.asObservable();
  itemCount$ = this.cartItems$.pipe(
    map(items => items.reduce((sum, item) => sum + item.quantity, 0))
  );
  
  addItem(product: Product, quantity: number = 1): void {
    const currentItems = this.cartItemsSubject.value;
    const existingItem = currentItems.find(item => item.product.id === product.id);
    
    let newItems: CartItem[];
    if (existingItem) {
      newItems = currentItems.map(item =>
        item.product.id === product.id
          ? { ...item, quantity: item.quantity + quantity }
          : item
      );
    } else {
      newItems = [...currentItems, { product, quantity }];
    }
    
    this.updateCart(newItems);
  }
  
  removeItem(productId: string): void {
    const newItems = this.cartItemsSubject.value.filter(
      item => item.product.id !== productId
    );
    this.updateCart(newItems);
  }
  
  updateQuantity(productId: string, quantity: number): void {
    if (quantity <= 0) {
      this.removeItem(productId);
      return;
    }
    
    const newItems = this.cartItemsSubject.value.map(item =>
      item.product.id === productId
        ? { ...item, quantity }
        : item
    );
    this.updateCart(newItems);
  }
  
  clearCart(): void {
    this.updateCart([]);
  }
  
  private updateCart(items: CartItem[]): void {
    this.cartItemsSubject.next(items);
    const total = items.reduce((sum, item) => sum + (item.product.price * item.quantity), 0);
    this.totalSubject.next(total);
  }
}

interface CartItem {
  product: Product;
  quantity: number;
}

interface Product {
  id: string;
  name: string;
  price: number;
}
```

**3. Signal-Based State Management (Modern Angular 16+):**

```typescript
// Signal-based state service
@Injectable({ providedIn: 'root' })
export class SignalStateService {
  // Private writable signals
  private _users = signal<User[]>([]);
  private _loading = signal<boolean>(false);
  private _error = signal<string | null>(null);
  private _selectedUserId = signal<string | null>(null);
  
  // Public readonly signals
  readonly users = this._users.asReadonly();
  readonly loading = this._loading.asReadonly();
  readonly error = this._error.asReadonly();
  readonly selectedUserId = this._selectedUserId.asReadonly();
  
  // Computed signals
  readonly selectedUser = computed(() => {
    const id = this._selectedUserId();
    return id ? this._users().find(user => user.id === id) ?? null : null;
  });
  
  readonly userCount = computed(() => this._users().length);
  
  readonly hasUsers = computed(() => this._users().length > 0);
  
  constructor(private http: HttpClient) {
    // Effects for side effects
    effect(() => {
      const error = this._error();
      if (error) {
        console.error('State error:', error);
        // Could trigger notifications, logging, etc.
      }
    });
  }
  
  // Actions
  loadUsers(): void {
    this._loading.set(true);
    this._error.set(null);
    
    this.http.get<User[]>('/api/users').pipe(
      catchError(error => {
        this._error.set(error.message);
        return of([]);
      }),
      finalize(() => this._loading.set(false))
    ).subscribe(users => {
      this._users.set(users);
    });
  }
  
  addUser(user: User): void {
    this._users.update(users => [...users, user]);
  }
  
  updateUser(updatedUser: User): void {
    this._users.update(users =>
      users.map(user => user.id === updatedUser.id ? updatedUser : user)
    );
  }
  
  removeUser(id: string): void {
    this._users.update(users => users.filter(user => user.id !== id));
    
    // Clear selection if removing selected user
    if (this._selectedUserId() === id) {
      this._selectedUserId.set(null);
    }
  }
  
  selectUser(id: string): void {
    this._selectedUserId.set(id);
  }
  
  clearError(): void {
    this._error.set(null);
  }
}

// Component using signals
@Component({
  selector: 'app-user-list',
  template: `
    <div>
      <h2>Users ({{userCount()}})</h2>
      
      <button (click)="loadUsers()" [disabled]="loading()">
        {{loading() ? 'Loading...' : 'Load Users'}}
      </button>
      
      <div *ngIf="error()" class="error">
        {{error()}}
        <button (click)="clearError()">Clear</button>
      </div>
      
      <div *ngIf="hasUsers()">
        <ul>
          <li *ngFor="let user of users()" 
              [class.selected]="selectedUserId() === user.id"
              (click)="selectUser(user.id)">
            {{user.name}} ({{user.email}})
          </li>
        </ul>
        
        <div *ngIf="selectedUser()" class="selected-user">
          <h3>Selected User</h3>
          <p>Name: {{selectedUser()!.name}}</p>
          <p>Email: {{selectedUser()!.email}}</p>
        </div>
      </div>
    </div>
  `
})
export class UserListComponent {
  // Inject signals
  users = this.stateService.users;
  loading = this.stateService.loading;
  error = this.stateService.error;
  selectedUserId = this.stateService.selectedUserId;
  selectedUser = this.stateService.selectedUser;
  userCount = this.stateService.userCount;
  hasUsers = this.stateService.hasUsers;
  
  constructor(private stateService: SignalStateService) {}
  
  loadUsers(): void {
    this.stateService.loadUsers();
  }
  
  selectUser(id: string): void {
    this.stateService.selectUser(id);
  }
  
  clearError(): void {
    this.stateService.clearError();
  }
}

interface User {
  id: string;
  name: string;
  email: string;
}
```

**4. NgRx Store (Large/Complex Applications):**

```typescript
// State interface
interface AppState {
  users: UserState;
  products: ProductState;
}

interface UserState {
  users: User[];
  selectedUser: User | null;
  loading: boolean;
  error: string | null;
}

// Actions
export const UserActions = createActionGroup({
  source: 'User',
  events: {
    'Load Users': emptyProps(),
    'Load Users Success': props<{ users: User[] }>(),
    'Load Users Failure': props<{ error: string }>(),
    'Select User': props<{ userId: string }>(),
    'Add User': props<{ user: User }>(),
    'Update User': props<{ user: User }>(),
    'Delete User': props<{ userId: string }>()
  }
});

// Reducer
const initialState: UserState = {
  users: [],
  selectedUser: null,
  loading: false,
  error: null
};

export const userReducer = createReducer(
  initialState,
  on(UserActions.loadUsers, (state) => ({
    ...state,
    loading: true,
    error: null
  })),
  on(UserActions.loadUsersSuccess, (state, { users }) => ({
    ...state,
    users,
    loading: false
  })),
  on(UserActions.loadUsersFailure, (state, { error }) => ({
    ...state,
    error,
    loading: false
  })),
  on(UserActions.selectUser, (state, { userId }) => ({
    ...state,
    selectedUser: state.users.find(user => user.id === userId) || null
  }))
);

// Effects
@Injectable()
export class UserEffects {
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.loadUsers),
      switchMap(() =>
        this.http.get<User[]>('/api/users').pipe(
          map(users => UserActions.loadUsersSuccess({ users })),
          catchError(error => of(UserActions.loadUsersFailure({ error: error.message })))
        )
      )
    )
  );
  
  constructor(
    private actions$: Actions,
    private http: HttpClient
  ) {}
}

// Selectors
export const selectUserState = (state: AppState) => state.users;

export const selectUsers = createSelector(
  selectUserState,
  (state: UserState) => state.users
);

export const selectSelectedUser = createSelector(
  selectUserState,
  (state: UserState) => state.selectedUser
);

export const selectUserLoading = createSelector(
  selectUserState,
  (state: UserState) => state.loading
);

// Component using NgRx
@Component({
  selector: 'app-ngrx-users',
  template: `
    <div>
      <button (click)="loadUsers()" [disabled]="loading$ | async">
        Load Users
      </button>
      
      <ul>
        <li *ngFor="let user of users$ | async" (click)="selectUser(user.id)">
          {{user.name}}
        </li>
      </ul>
      
      <div *ngIf="selectedUser$ | async as user">
        <h3>{{user.name}}</h3>
        <p>{{user.email}}</p>
      </div>
    </div>
  `
})
export class NgRxUsersComponent {
  users$ = this.store.select(selectUsers);
  selectedUser$ = this.store.select(selectSelectedUser);
  loading$ = this.store.select(selectUserLoading);
  
  constructor(private store: Store<AppState>) {}
  
  loadUsers(): void {
    this.store.dispatch(UserActions.loadUsers());
  }
  
  selectUser(userId: string): void {
    this.store.dispatch(UserActions.selectUser({ userId }));
  }
}
```

**5. NgRx ComponentStore (Feature-Level State):**

```typescript
// ComponentStore for feature-specific state
interface TodoState {
  todos: Todo[];
  filter: TodoFilter;
  loading: boolean;
}

type TodoFilter = 'all' | 'active' | 'completed';

@Injectable()
export class TodoStore extends ComponentStore<TodoState> {
  constructor(private http: HttpClient) {
    super({
      todos: [],
      filter: 'all',
      loading: false
    });
  }
  
  // Selectors
  readonly todos$ = this.select(state => state.todos);
  readonly filter$ = this.select(state => state.filter);
  readonly loading$ = this.select(state => state.loading);
  
  readonly filteredTodos$ = this.select(
    this.todos$,
    this.filter$,
    (todos, filter) => {
      switch (filter) {
        case 'active':
          return todos.filter(todo => !todo.completed);
        case 'completed':
          return todos.filter(todo => todo.completed);
        default:
          return todos;
      }
    }
  );
  
  readonly activeTodosCount$ = this.select(
    this.todos$,
    todos => todos.filter(todo => !todo.completed).length
  );
  
  // Updaters
  readonly setLoading = this.updater((state, loading: boolean) => ({
    ...state,
    loading
  }));
  
  readonly setTodos = this.updater((state, todos: Todo[]) => ({
    ...state,
    todos
  }));
  
  readonly addTodo = this.updater((state, todo: Todo) => ({
    ...state,
    todos: [...state.todos, todo]
  }));
  
  readonly updateTodo = this.updater((state, updatedTodo: Todo) => ({
    ...state,
    todos: state.todos.map(todo =>
      todo.id === updatedTodo.id ? updatedTodo : todo
    )
  }));
  
  readonly setFilter = this.updater((state, filter: TodoFilter) => ({
    ...state,
    filter
  }));
  
  // Effects
  readonly loadTodos = this.effect((trigger$) =>
    trigger$.pipe(
      tap(() => this.setLoading(true)),
      switchMap(() =>
        this.http.get<Todo[]>('/api/todos').pipe(
          tapResponse(
            (todos) => {
              this.setTodos(todos);
              this.setLoading(false);
            },
            (error) => {
              console.error('Error loading todos:', error);
              this.setLoading(false);
            }
          )
        )
      )
    )
  );
}

interface Todo {
  id: string;
  text: string;
  completed: boolean;
}
```

**Comparison Summary:**

| Approach | Best For | Pros | Cons |
|----------|----------|------|------|
| **Local Component State** | Simple components, forms | Simple, fast, no setup | Not shareable, limited |
| **Service + RxJS** | Medium apps, shared state | Flexible, familiar | Manual state management |
| **Signals** | Modern Angular apps | Reactive, performant | New API, limited ecosystem |
| **NgRx Store** | Large, complex apps | Predictable, debuggable | Boilerplate, learning curve |
| **ComponentStore** | Feature-specific state | Less boilerplate than Store | Limited to component tree |

**When to Use Each Approach:**

- **Local State**: Simple forms, UI state, component-specific data
- **Service + RxJS**: Medium applications, shared data between components
- **Signals**: Modern applications wanting reactive programming with less boilerplate
- **NgRx Store**: Large applications, complex state interactions, need for time-travel debugging
- **ComponentStore**: Feature modules that need state management but don't want global store complexity

[Back to State Management](#state-management)

### 127. How does NgRx work and what are its core concepts?

**Answer:**
NgRx is a reactive state management library for Angular based on Redux pattern and RxJS. It provides a predictable state container that helps manage application state through unidirectional data flow, making applications more maintainable and debuggable.

**Core NgRx Architecture:**

```
┌─────────────┐    dispatch    ┌─────────────┐    ┌─────────────┐
│ Components  │ ──────────────→ │   Actions   │ ──→ │  Reducers   │
└─────────────┘                 └─────────────┘    └─────────────┘
       ↑                                                    │
       │                                                    ▼
       │                        ┌─────────────┐    ┌─────────────┐
       └────────────────────────│  Selectors  │ ←──│    Store    │
                                └─────────────┘    └─────────────┘
                                       ↑                   │
                                       │                   ▼
                                ┌─────────────┐    ┌─────────────┐
                                │   Effects   │ ←──│   Actions   │
                                └─────────────┘    └─────────────┘
```

**1. Store - Single Source of Truth:**

```typescript
// app.state.ts - Global application state
export interface AppState {
  auth: AuthState;
  users: UserState;
  products: ProductState;
  ui: UiState;
}

export interface UserState {
  users: User[];
  selectedUser: User | null;
  loading: boolean;
  error: string | null;
  filters: UserFilters;
}

export interface AuthState {
  currentUser: User | null;
  isAuthenticated: boolean;
  token: string | null;
  loading: boolean;
}

// app.config.ts - Store configuration
import { provideStore, provideState } from '@ngrx/store';
import { provideEffects } from '@ngrx/effects';
import { provideStoreDevtools } from '@ngrx/store-devtools';

export const appConfig: ApplicationConfig = {
  providers: [
    // Core NgRx providers
    provideStore(),
    
    // Feature states
    provideState('users', userReducer),
    provideState('auth', authReducer),
    provideState('products', productReducer),
    
    // Effects
    provideEffects([UserEffects, AuthEffects, ProductEffects]),
    
    // DevTools (development only)
    provideStoreDevtools({
      maxAge: 25,
      logOnly: environment.production,
      autoPause: true,
      trace: false,
      traceLimit: 75
    })
  ]
};
```

**2. Actions - Events That Describe State Changes:**

```typescript
// user.actions.ts
import { createActionGroup, props, emptyProps } from '@ngrx/store';

// Modern action group syntax (NgRx 14+)
export const UserActions = createActionGroup({
  source: 'User',
  events: {
    // Load users
    'Load Users': emptyProps(),
    'Load Users Success': props<{ users: User[] }>(),
    'Load Users Failure': props<{ error: string }>(),
    
    // User CRUD operations
    'Add User': props<{ user: Omit<User, 'id'> }>(),
    'Add User Success': props<{ user: User }>(),
    'Add User Failure': props<{ error: string }>(),
    
    'Update User': props<{ user: User }>(),
    'Update User Success': props<{ user: User }>(),
    'Update User Failure': props<{ error: string }>(),
    
    'Delete User': props<{ userId: string }>(),
    'Delete User Success': props<{ userId: string }>(),
    'Delete User Failure': props<{ error: string }>(),
    
    // Selection and UI actions
    'Select User': props<{ userId: string }>(),
    'Clear Selection': emptyProps(),
    'Set Filter': props<{ filter: UserFilters }>(),
    'Clear Error': emptyProps()
  }
});

// Traditional action syntax (still valid)
export const loadUsersLegacy = createAction('[User] Load Users');
export const loadUsersSuccessLegacy = createAction(
  '[User] Load Users Success',
  props<{ users: User[] }>()
);

// Action usage in components
@Component({
  selector: 'app-user-list',
  template: `
    <div>
      <button (click)="loadUsers()">Load Users</button>
      <button (click)="addUser()">Add User</button>
      
      <div *ngFor="let user of users$ | async">
        {{user.name}}
        <button (click)="selectUser(user.id)">Select</button>
        <button (click)="deleteUser(user.id)">Delete</button>
      </div>
    </div>
  `
})
export class UserListComponent {
  users$ = this.store.select(selectUsers);
  
  constructor(private store: Store<AppState>) {}
  
  loadUsers(): void {
    this.store.dispatch(UserActions.loadUsers());
  }
  
  selectUser(userId: string): void {
    this.store.dispatch(UserActions.selectUser({ userId }));
  }
  
  deleteUser(userId: string): void {
    this.store.dispatch(UserActions.deleteUser({ userId }));
  }
  
  addUser(): void {
    const newUser = {
      name: 'New User',
      email: 'new@example.com',
      role: 'user' as const
    };
    this.store.dispatch(UserActions.addUser({ user: newUser }));
  }
}

interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user';
}

interface UserFilters {
  role?: 'admin' | 'user';
  searchTerm?: string;
}
```

**3. Reducers - Pure Functions That Update State:**

```typescript
// user.reducer.ts
import { createReducer, on } from '@ngrx/store';
import { UserActions } from './user.actions';

const initialState: UserState = {
  users: [],
  selectedUser: null,
  loading: false,
  error: null,
  filters: {}
};

export const userReducer = createReducer(
  initialState,
  
  // Loading states
  on(UserActions.loadUsers, (state) => ({
    ...state,
    loading: true,
    error: null
  })),
  
  on(UserActions.loadUsersSuccess, (state, { users }) => ({
    ...state,
    users,
    loading: false,
    error: null
  })),
  
  on(UserActions.loadUsersFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error
  })),
  
  // Add user
  on(UserActions.addUser, (state) => ({
    ...state,
    loading: true,
    error: null
  })),
  
  on(UserActions.addUserSuccess, (state, { user }) => ({
    ...state,
    users: [...state.users, user],
    loading: false
  })),
  
  on(UserActions.addUserFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error
  })),
  
  // Update user
  on(UserActions.updateUser, (state) => ({
    ...state,
    loading: true,
    error: null
  })),
  
  on(UserActions.updateUserSuccess, (state, { user }) => ({
    ...state,
    users: state.users.map(u => u.id === user.id ? user : u),
    selectedUser: state.selectedUser?.id === user.id ? user : state.selectedUser,
    loading: false
  })),
  
  // Delete user
  on(UserActions.deleteUserSuccess, (state, { userId }) => ({
    ...state,
    users: state.users.filter(user => user.id !== userId),
    selectedUser: state.selectedUser?.id === userId ? null : state.selectedUser,
    loading: false
  })),
  
  // Selection
  on(UserActions.selectUser, (state, { userId }) => {
    const selectedUser = state.users.find(user => user.id === userId) || null;
    return {
      ...state,
      selectedUser
    };
  }),
  
  on(UserActions.clearSelection, (state) => ({
    ...state,
    selectedUser: null
  })),
  
  // Filters
  on(UserActions.setFilter, (state, { filter }) => ({
    ...state,
    filters: { ...state.filters, ...filter }
  })),
  
  // Error handling
  on(UserActions.clearError, (state) => ({
    ...state,
    error: null
  }))
);

// Helper functions for complex state updates
function updateUserInState(users: User[], updatedUser: User): User[] {
  return users.map(user => 
    user.id === updatedUser.id ? { ...user, ...updatedUser } : user
  );
}

function removeUserFromState(users: User[], userId: string): User[] {
  return users.filter(user => user.id !== userId);
}
```

**4. Selectors - Query Functions for State:**

```typescript
// user.selectors.ts
import { createSelector, createFeatureSelector } from '@ngrx/store';

// Feature selector
export const selectUserState = createFeatureSelector<UserState>('users');

// Base selectors
export const selectUsers = createSelector(
  selectUserState,
  (state: UserState) => state.users
);

export const selectSelectedUser = createSelector(
  selectUserState,
  (state: UserState) => state.selectedUser
);

export const selectUserLoading = createSelector(
  selectUserState,
  (state: UserState) => state.loading
);

export const selectUserError = createSelector(
  selectUserState,
  (state: UserState) => state.error
);

export const selectUserFilters = createSelector(
  selectUserState,
  (state: UserState) => state.filters
);

// Computed selectors
export const selectFilteredUsers = createSelector(
  selectUsers,
  selectUserFilters,
  (users, filters) => {
    let filteredUsers = users;
    
    if (filters.role) {
      filteredUsers = filteredUsers.filter(user => user.role === filters.role);
    }
    
    if (filters.searchTerm) {
      const searchTerm = filters.searchTerm.toLowerCase();
      filteredUsers = filteredUsers.filter(user => 
        user.name.toLowerCase().includes(searchTerm) ||
        user.email.toLowerCase().includes(searchTerm)
      );
    }
    
    return filteredUsers;
  }
);

export const selectUserCount = createSelector(
  selectUsers,
  (users) => users.length
);

export const selectAdminUsers = createSelector(
  selectUsers,
  (users) => users.filter(user => user.role === 'admin')
);

export const selectUserById = (userId: string) => createSelector(
  selectUsers,
  (users) => users.find(user => user.id === userId)
);

// Complex selectors combining multiple features
export const selectUserWithAuthInfo = createSelector(
  selectSelectedUser,
  createFeatureSelector<AuthState>('auth'),
  (selectedUser, authState) => ({
    user: selectedUser,
    isCurrentUser: selectedUser?.id === authState.currentUser?.id,
    canEdit: authState.currentUser?.role === 'admin' || 
             selectedUser?.id === authState.currentUser?.id
  })
);

// Parametrized selectors
export const selectUsersWithRole = (role: 'admin' | 'user') => createSelector(
  selectUsers,
  (users) => users.filter(user => user.role === role)
);
```

**5. Effects - Side Effects and Async Operations:**

```typescript
// user.effects.ts
import { Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { Store } from '@ngrx/store';
import { HttpClient } from '@angular/common/http';
import { of } from 'rxjs';
import { map, mergeMap, catchError, switchMap, withLatestFrom, tap } from 'rxjs/operators';

@Injectable()
export class UserEffects {
  
  // Load users effect
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.loadUsers),
      switchMap(() =>
        this.http.get<User[]>('/api/users').pipe(
          map(users => UserActions.loadUsersSuccess({ users })),
          catchError(error => of(UserActions.loadUsersFailure({ 
            error: error.message || 'Failed to load users' 
          })))
        )
      )
    )
  );
  
  // Add user effect
  addUser$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.addUser),
      mergeMap(({ user }) =>
        this.http.post<User>('/api/users', user).pipe(
          map(createdUser => UserActions.addUserSuccess({ user: createdUser })),
          catchError(error => of(UserActions.addUserFailure({ 
            error: error.message || 'Failed to add user' 
          })))
        )
      )
    )
  );
  
  // Update user effect
  updateUser$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.updateUser),
      mergeMap(({ user }) =>
        this.http.put<User>(`/api/users/${user.id}`, user).pipe(
          map(updatedUser => UserActions.updateUserSuccess({ user: updatedUser })),
          catchError(error => of(UserActions.updateUserFailure({ 
            error: error.message || 'Failed to update user' 
          })))
        )
      )
    )
  );
  
  // Delete user effect
  deleteUser$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.deleteUser),
      mergeMap(({ userId }) =>
        this.http.delete(`/api/users/${userId}`).pipe(
          map(() => UserActions.deleteUserSuccess({ userId })),
          catchError(error => of(UserActions.deleteUserFailure({ 
            error: error.message || 'Failed to delete user' 
          })))
        )
      )
    )
  );
  
  // Non-dispatching effect for logging
  logUserActions$ = createEffect(() =>
    this.actions$.pipe(
      ofType(
        UserActions.addUserSuccess,
        UserActions.updateUserSuccess,
        UserActions.deleteUserSuccess
      ),
      tap(action => {
        console.log('User action completed:', action.type);
        // Could send to analytics, logging service, etc.
      })
    ),
    { dispatch: false }
  );
  
  // Effect that depends on current state
  selectUserWithValidation$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.selectUser),
      withLatestFrom(this.store.select(selectUsers)),
      switchMap(([{ userId }, users]) => {
        const userExists = users.some(user => user.id === userId);
        
        if (!userExists) {
          return of(UserActions.loadUsersFailure({ 
            error: `User with ID ${userId} not found` 
          }));
        }
        
        // If user exists, the reducer will handle the selection
        return of(); // Empty observable, no additional action needed
      }),
      filter(action => !!action) // Only emit if there's an action
    )
  );
  
  constructor(
    private actions$: Actions,
    private http: HttpClient,
    private store: Store<AppState>
  ) {}
}
```

**Key NgRx Principles:**

**1. Single Source of Truth:**
- All application state is stored in one place (the Store)
- Components get state via selectors, not direct access

**2. State is Read-Only:**
- State can only be changed by dispatching actions
- No direct mutations of state objects

**3. Changes are Made with Pure Functions:**
- Reducers are pure functions that return new state objects
- No side effects in reducers

**4. Unidirectional Data Flow:**
- Actions → Reducers → Store → Selectors → Components
- Predictable state updates

**Benefits of NgRx:**
- **Predictability**: Clear data flow and state updates
- **Debuggability**: Time-travel debugging with Redux DevTools
- **Testability**: Pure functions are easy to test
- **Performance**: OnPush change detection optimization
- **Scalability**: Organized code structure for large applications

**When to Use NgRx:**
- Large applications with complex state
- Multiple components sharing state
- Need for time-travel debugging
- Complex async operations
- State persistence requirements

[Back to State Management](#state-management)

### 128. What are effects in NgRx and when do you use them?

**Answer:**
NgRx Effects are a powerful feature that handles side effects in a reactive, declarative way. Effects listen for actions, perform side effects (like HTTP requests), and can dispatch new actions based on the results. They keep reducers pure by isolating side effects.

**Core Concepts of Effects:**

**1. Basic Effect Structure:**

```typescript
// user.effects.ts
import { Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { of } from 'rxjs';
import { map, mergeMap, catchError, switchMap, tap } from 'rxjs/operators';

@Injectable()
export class UserEffects {
  
  // Basic effect pattern
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.loadUsers),           // Listen for specific action
      switchMap(() =>                          // Handle the action
        this.http.get<User[]>('/api/users').pipe(
          map(users => UserActions.loadUsersSuccess({ users })),  // Success action
          catchError(error => of(UserActions.loadUsersFailure({   // Error action
            error: error.message 
          })))
        )
      )
    )
  );
  
  constructor(
    private actions$: Actions,
    private http: HttpClient
  ) {}
}
```

**2. Different Types of Effects:**

```typescript
@Injectable()
export class ComprehensiveEffects {
  
  // HTTP Request Effect (most common)
  loadData$ = createEffect(() =>
    this.actions$.pipe(
      ofType(DataActions.loadData),
      switchMap(({ id }) =>
        this.http.get<Data>(`/api/data/${id}`).pipe(
          map(data => DataActions.loadDataSuccess({ data })),
          catchError(error => of(DataActions.loadDataFailure({ error: error.message })))
        )
      )
    )
  );
  
  // Non-dispatching Effect (side effects only)
  logActions$ = createEffect(() =>
    this.actions$.pipe(
      tap(action => {
        console.log('Action dispatched:', action);
        // Send to analytics, logging service, etc.
      })
    ),
    { dispatch: false }  // Important: prevents infinite loops
  );
  
  // Navigation Effect
  navigateAfterLogin$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AuthActions.loginSuccess),
      tap(({ redirectUrl }) => {
        this.router.navigate([redirectUrl || '/dashboard']);
      })
    ),
    { dispatch: false }
  );
  
  // Local Storage Effect
  saveToLocalStorage$ = createEffect(() =>
    this.actions$.pipe(
      ofType(
        UserActions.updateUserPreferences,
        SettingsActions.saveSettings
      ),
      withLatestFrom(this.store.select(selectUserPreferences)),
      tap(([action, preferences]) => {
        localStorage.setItem('userPreferences', JSON.stringify(preferences));
      })
    ),
    { dispatch: false }
  );
  
  // WebSocket Effect
  connectWebSocket$ = createEffect(() =>
    this.actions$.pipe(
      ofType(WebSocketActions.connect),
      switchMap(() =>
        this.webSocketService.connect().pipe(
          map(message => WebSocketActions.messageReceived({ message })),
          catchError(error => of(WebSocketActions.connectionError({ error })))
        )
      )
    )
  );
  
  constructor(
    private actions$: Actions,
    private http: HttpClient,
    private router: Router,
    private store: Store,
    private webSocketService: WebSocketService
  ) {}
}
```

**3. Advanced Effect Patterns:**

```typescript
@Injectable()
export class AdvancedEffects {
  
  // Effect with State Dependency
  updateUserWithCurrentState$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.updateCurrentUser),
      withLatestFrom(
        this.store.select(selectCurrentUser),
        this.store.select(selectUserPreferences)
      ),
      switchMap(([action, currentUser, preferences]) => {
        if (!currentUser) {
          return of(UserActions.updateUserFailure({ 
            error: 'No current user found' 
          }));
        }
        
        const updatedUser = {
          ...currentUser,
          ...action.updates,
          preferences
        };
        
        return this.http.put<User>(`/api/users/${currentUser.id}`, updatedUser).pipe(
          map(user => UserActions.updateUserSuccess({ user })),
          catchError(error => of(UserActions.updateUserFailure({ 
            error: error.message 
          })))
        );
      })
    )
  );
  
  // Conditional Effect
  conditionalLoad$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AppActions.initialize),
      withLatestFrom(this.store.select(selectIsDataLoaded)),
      filter(([action, isLoaded]) => !isLoaded),  // Only if not already loaded
      switchMap(() =>
        this.http.get<AppData>('/api/app-data').pipe(
          map(data => AppActions.initializeSuccess({ data })),
          catchError(error => of(AppActions.initializeFailure({ error })))
        )
      )
    )
  );
  
  // Debounced Effect
  searchEffect$ = createEffect(() =>
    this.actions$.pipe(
      ofType(SearchActions.search),
      debounceTime(300),  // Wait 300ms after last search
      distinctUntilChanged((prev, curr) => prev.query === curr.query),
      switchMap(({ query }) => {
        if (!query.trim()) {
          return of(SearchActions.clearResults());
        }
        
        return this.http.get<SearchResult[]>(`/api/search?q=${query}`).pipe(
          map(results => SearchActions.searchSuccess({ results })),
          catchError(error => of(SearchActions.searchFailure({ error })))
        );
      })
    )
  );
  
  // Polling Effect
  startPolling$ = createEffect(() =>
    this.actions$.pipe(
      ofType(PollingActions.startPolling),
      switchMap(({ interval = 5000 }) =>
        timer(0, interval).pipe(
          switchMap(() =>
            this.http.get<StatusData>('/api/status').pipe(
              map(status => PollingActions.statusUpdate({ status })),
              catchError(error => of(PollingActions.pollingError({ error })))
            )
          ),
          takeUntil(this.actions$.pipe(ofType(PollingActions.stopPolling)))
        )
      )
    )
  );
  
  // Chain of Effects
  createUserAndAssignRole$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.createUserWithRole),
      switchMap(({ userData, roleId }) =>
        // First create user
        this.http.post<User>('/api/users', userData).pipe(
          switchMap(user =>
            // Then assign role
            this.http.post(`/api/users/${user.id}/roles`, { roleId }).pipe(
              map(() => UserActions.createUserWithRoleSuccess({ user, roleId })),
              catchError(roleError => 
                // If role assignment fails, we might want to delete the user
                this.http.delete(`/api/users/${user.id}`).pipe(
                  switchMap(() => of(UserActions.createUserWithRoleFailure({ 
                    error: 'Failed to assign role, user creation rolled back' 
                  }))),
                  catchError(() => of(UserActions.createUserWithRoleFailure({ 
                    error: 'Failed to assign role and rollback user creation' 
                  })))
                )
              )
            )
          ),
          catchError(userError => of(UserActions.createUserWithRoleFailure({ 
            error: userError.message 
          })))
        )
      )
    )
  );
}
```

**4. Error Handling in Effects:**

```typescript
@Injectable()
export class ErrorHandlingEffects {
  
  // Global Error Handling
  handleHttpErrors$ = createEffect(() =>
    this.actions$.pipe(
      ofType(
        UserActions.loadUsersFailure,
        ProductActions.loadProductsFailure,
        OrderActions.createOrderFailure
      ),
      tap(({ error }) => {
        // Show toast notification
        this.notificationService.showError(error);
        
        // Log to external service
        this.loggingService.logError(error);
      })
    ),
    { dispatch: false }
  );
  
  // Retry Logic
  loadDataWithRetry$ = createEffect(() =>
    this.actions$.pipe(
      ofType(DataActions.loadData),
      switchMap(({ id }) =>
        this.http.get<Data>(`/api/data/${id}`).pipe(
          retry(3),  // Retry up to 3 times
          map(data => DataActions.loadDataSuccess({ data })),
          catchError(error => {
            // After all retries failed
            this.notificationService.showError(
              'Failed to load data after 3 attempts'
            );
            return of(DataActions.loadDataFailure({ error: error.message }));
          })
        )
      )
    )
  );
  
  // Custom Retry with Exponential Backoff
  loadWithCustomRetry$ = createEffect(() =>
    this.actions$.pipe(
      ofType(DataActions.loadDataWithRetry),
      switchMap(({ id }) =>
        this.http.get<Data>(`/api/data/${id}`).pipe(
          retryWhen(errors =>
            errors.pipe(
              scan((retryCount, error) => {
                if (retryCount >= 3) {
                  throw error;
                }
                return retryCount + 1;
              }, 0),
              delay(1000)  // Wait 1 second between retries
            )
          ),
          map(data => DataActions.loadDataSuccess({ data })),
          catchError(error => of(DataActions.loadDataFailure({ error })))
        )
      )
    )
  );
}
```

**5. Testing Effects:**

```typescript
// user.effects.spec.ts
describe('UserEffects', () => {
  let actions$: Observable<Action>;
  let effects: UserEffects;
  let httpMock: HttpTestingController;
  
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [
        UserEffects,
        provideMockActions(() => actions$)
      ]
    });
    
    effects = TestBed.inject(UserEffects);
    httpMock = TestBed.inject(HttpTestingController);
  });
  
  describe('loadUsers$', () => {
    it('should return loadUsersSuccess on successful API call', () => {
      const users = [{ id: '1', name: 'John' }];
      const action = UserActions.loadUsers();
      const outcome = UserActions.loadUsersSuccess({ users });
      
      actions$ = hot('-a', { a: action });
      const response = cold('-b|', { b: users });
      const expected = cold('--c', { c: outcome });
      
      httpMock.expectOne('/api/users').flush(users);
      
      expect(effects.loadUsers$).toBeObservable(expected);
    });
    
    it('should return loadUsersFailure on API error', () => {
      const action = UserActions.loadUsers();
      const error = 'Server Error';
      const outcome = UserActions.loadUsersFailure({ error });
      
      actions$ = hot('-a', { a: action });
      const expected = cold('--c', { c: outcome });
      
      const req = httpMock.expectOne('/api/users');
      req.flush('Server Error', { status: 500, statusText: 'Server Error' });
      
      expect(effects.loadUsers$).toBeObservable(expected);
    });
  });
});
```

**When to Use Effects:**

**✅ Use Effects for:**
- **HTTP Requests**: API calls, file uploads/downloads
- **Navigation**: Route changes based on actions
- **Local Storage**: Persisting state to localStorage/sessionStorage
- **WebSocket**: Real-time communication
- **Notifications**: Showing toasts, alerts
- **Analytics**: Tracking user actions
- **Logging**: Error logging, audit trails
- **Timer Operations**: Polling, debouncing
- **External Integrations**: Third-party services

**❌ Don't Use Effects for:**
- **Pure State Transformations**: Use reducers instead
- **Synchronous Operations**: Handle in components or services
- **Simple UI State**: Local component state is sufficient
- **Computations**: Use selectors for derived state

**Best Practices:**

1. **Keep Effects Pure**: No direct state mutations
2. **Handle Errors**: Always include error handling
3. **Use Appropriate Operators**: `switchMap` for cancellable, `mergeMap` for concurrent
4. **Avoid Memory Leaks**: Use `takeUntil` for cleanup
5. **Test Effects**: Write comprehensive unit tests
6. **Use Typed Actions**: Leverage TypeScript for type safety
7. **Organize by Feature**: Group related effects together

[Back to State Management](#state-management)

### 129. How do you handle side effects in Angular applications?

**Answer:**
Side effects in Angular applications are operations that interact with the outside world or cause changes beyond the current function scope. These include HTTP requests, DOM manipulations, local storage operations, timers, and external API calls. Angular provides several patterns and tools to handle side effects effectively.

**1. Service-Based Side Effects (Traditional Approach):**

```typescript
// user.service.ts - Handling HTTP side effects
@Injectable({ providedIn: 'root' })
export class UserService {
  private usersSubject = new BehaviorSubject<User[]>([]);
  private loadingSubject = new BehaviorSubject<boolean>(false);
  private errorSubject = new BehaviorSubject<string | null>(null);
  
  users$ = this.usersSubject.asObservable();
  loading$ = this.loadingSubject.asObservable();
  error$ = this.errorSubject.asObservable();
  
  constructor(private http: HttpClient) {}
  
  // HTTP side effect with error handling
  loadUsers(): Observable<User[]> {
    this.loadingSubject.next(true);
    this.errorSubject.next(null);
    
    return this.http.get<User[]>('/api/users').pipe(
      tap(users => {
        this.usersSubject.next(users);
        this.loadingSubject.next(false);
      }),
      catchError(error => {
        this.errorSubject.next(error.message);
        this.loadingSubject.next(false);
        return throwError(() => error);
      }),
      finalize(() => this.loadingSubject.next(false))
    );
  }
  
  // Side effect with local storage
  saveUserPreferences(userId: string, preferences: UserPreferences): Observable<void> {
    return this.http.put<void>(`/api/users/${userId}/preferences`, preferences).pipe(
      tap(() => {
        // Side effect: update local storage
        localStorage.setItem(`user_${userId}_preferences`, JSON.stringify(preferences));
        
        // Side effect: update subject
        const currentUsers = this.usersSubject.value;
        const updatedUsers = currentUsers.map(user => 
          user.id === userId ? { ...user, preferences } : user
        );
        this.usersSubject.next(updatedUsers);
      })
    );
  }
}

// notification.service.ts - Side effects for UI feedback
@Injectable({ providedIn: 'root' })
export class NotificationService {
  private notificationsSubject = new Subject<Notification>();
  notifications$ = this.notificationsSubject.asObservable();
  
  // Side effect: show notification
  showNotification(message: string, type: 'success' | 'error' | 'info' = 'info'): void {
    const notification: Notification = {
      id: Math.random().toString(36),
      message,
      type,
      timestamp: Date.now()
    };
    
    this.notificationsSubject.next(notification);
    
    // Side effect: auto-dismiss after 5 seconds
    timer(5000).subscribe(() => {
      this.dismissNotification(notification.id);
    });
  }
  
  private dismissNotification(id: string): void {
    // Another side effect
    this.notificationsSubject.next({
      id,
      message: '',
      type: 'dismiss',
      timestamp: Date.now()
    });
  }
}
```

**2. NgRx Effects (Reactive Side Effects):**

```typescript
// user.effects.ts - Declarative side effect handling
@Injectable()
export class UserEffects {
  
  // HTTP side effect
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.loadUsers),
      switchMap(() =>
        this.http.get<User[]>('/api/users').pipe(
          map(users => UserActions.loadUsersSuccess({ users })),
          catchError(error => of(UserActions.loadUsersFailure({ 
            error: error.message 
          })))
        )
      )
    )
  );
  
  // Local storage side effect
  savePreferencesToStorage$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.updatePreferences),
      withLatestFrom(this.store.select(selectCurrentUser)),
      tap(([{ preferences }, currentUser]) => {
        if (currentUser) {
          localStorage.setItem(
            `user_${currentUser.id}_preferences`, 
            JSON.stringify(preferences)
          );
        }
      })
    ),
    { dispatch: false }
  );
  
  // Navigation side effect
  navigateAfterLogin$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AuthActions.loginSuccess),
      tap(({ redirectUrl }) => {
        this.router.navigate([redirectUrl || '/dashboard']);
      })
    ),
    { dispatch: false }
  );
  
  // Notification side effect
  showNotifications$ = createEffect(() =>
    this.actions$.pipe(
      ofType(
        UserActions.createUserSuccess,
        UserActions.updateUserSuccess,
        UserActions.deleteUserSuccess
      ),
      tap(action => {
        let message = '';
        switch (action.type) {
          case UserActions.createUserSuccess.type:
            message = 'User created successfully';
            break;
          case UserActions.updateUserSuccess.type:
            message = 'User updated successfully';
            break;
          case UserActions.deleteUserSuccess.type:
            message = 'User deleted successfully';
            break;
        }
        this.notificationService.showNotification(message, 'success');
      })
    ),
    { dispatch: false }
  );
  
  // WebSocket side effect
  connectWebSocket$ = createEffect(() =>
    this.actions$.pipe(
      ofType(WebSocketActions.connect),
      switchMap(() =>
        this.webSocketService.connect().pipe(
          map(message => WebSocketActions.messageReceived({ message })),
          catchError(error => of(WebSocketActions.connectionError({ error })))
        )
      )
    )
  );
  
  // Polling side effect
  startPolling$ = createEffect(() =>
    this.actions$.pipe(
      ofType(PollingActions.start),
      switchMap(({ interval }) =>
        timer(0, interval).pipe(
          switchMap(() =>
            this.http.get<StatusData>('/api/status').pipe(
              map(status => PollingActions.statusReceived({ status })),
              catchError(error => of(PollingActions.pollingError({ error })))
            )
          ),
          takeUntil(this.actions$.pipe(ofType(PollingActions.stop)))
        )
      )
    )
  );
  
  constructor(
    private actions$: Actions,
    private http: HttpClient,
    private router: Router,
    private store: Store,
    private notificationService: NotificationService,
    private webSocketService: WebSocketService
  ) {}
}
```

**3. Component-Level Side Effects:**

```typescript
// user-list.component.ts
@Component({
  selector: 'app-user-list',
  template: `
    <div>
      <input [(ngModel)]="searchTerm" 
             (input)="onSearch($event)" 
             placeholder="Search users..." />
      
      <div *ngFor="let user of filteredUsers$ | async" 
           (click)="selectUser(user)"
           [class.selected]="selectedUser?.id === user.id">
        {{user.name}}
      </div>
      
      <div *ngIf="loading$ | async" class="loading">
        Loading...
      </div>
    </div>
  `
})
export class UserListComponent implements OnInit, OnDestroy {
  searchTerm = '';
  selectedUser: User | null = null;
  
  // Observables for reactive side effects
  users$ = this.userService.users$;
  loading$ = this.userService.loading$;
  
  // Filtered users with debounced search
  private searchSubject = new Subject<string>();
  filteredUsers$ = combineLatest([
    this.users$,
    this.searchSubject.pipe(
      startWith(''),
      debounceTime(300),
      distinctUntilChanged()
    )
  ]).pipe(
    map(([users, searchTerm]) => 
      users.filter(user => 
        user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        user.email.toLowerCase().includes(searchTerm.toLowerCase())
      )
    )
  );
  
  private destroy$ = new Subject<void>();
  
  constructor(
    private userService: UserService,
    private analyticsService: AnalyticsService,
    private cdr: ChangeDetectorRef
  ) {}
  
  ngOnInit(): void {
    // Side effect: load users on component init
    this.userService.loadUsers().pipe(
      takeUntil(this.destroy$)
    ).subscribe();
    
    // Side effect: track page view
    this.analyticsService.trackPageView('user-list');
    
    // Side effect: keyboard shortcuts
    fromEvent<KeyboardEvent>(document, 'keydown').pipe(
      filter(event => event.ctrlKey && event.key === 'f'),
      tap(event => {
        event.preventDefault();
        this.focusSearchInput();
      }),
      takeUntil(this.destroy$)
    ).subscribe();
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  onSearch(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.searchSubject.next(target.value);
  }
  
  selectUser(user: User): void {
    this.selectedUser = user;
    
    // Side effect: track user selection
    this.analyticsService.trackEvent('user_selected', {
      userId: user.id,
      userName: user.name
    });
    
    // Side effect: update URL without navigation
    window.history.replaceState({}, '', `/users?selected=${user.id}`);
  }
  
  private focusSearchInput(): void {
    // Side effect: DOM manipulation
    const searchInput = document.querySelector('input[placeholder="Search users..."]') as HTMLInputElement;
    if (searchInput) {
      searchInput.focus();
    }
  }
}
```

**4. Signal-Based Side Effects (Angular 16+):**

```typescript
// signal-user.service.ts
@Injectable({ providedIn: 'root' })
export class SignalUserService {
  private _users = signal<User[]>([]);
  private _loading = signal<boolean>(false);
  private _error = signal<string | null>(null);
  
  readonly users = this._users.asReadonly();
  readonly loading = this._loading.asReadonly();
  readonly error = this._error.asReadonly();
  
  constructor(private http: HttpClient) {
    // Effect for side effects when error changes
    effect(() => {
      const error = this._error();
      if (error) {
        console.error('User service error:', error);
        // Side effect: show notification
        this.showErrorNotification(error);
      }
    });
    
    // Effect for local storage persistence
    effect(() => {
      const users = this._users();
      if (users.length > 0) {
        // Side effect: cache users in localStorage
        localStorage.setItem('cached_users', JSON.stringify(users));
      }
    });
  }
  
  loadUsers(): void {
    this._loading.set(true);
    this._error.set(null);
    
    this.http.get<User[]>('/api/users').pipe(
      catchError(error => {
        this._error.set(error.message);
        return of([]);
      }),
      finalize(() => this._loading.set(false))
    ).subscribe(users => {
      this._users.set(users);
    });
  }
  
  private showErrorNotification(error: string): void {
    // Side effect implementation
    console.log('Showing error notification:', error);
  }
}

// signal-user.component.ts
@Component({
  selector: 'app-signal-users',
  template: `
    <div>
      <h2>Users ({{userCount()}})</h2>
      <button (click)="loadUsers()" [disabled]="loading()">
        {{loading() ? 'Loading...' : 'Load Users'}}
      </button>
      
      <div *ngIf="error()" class="error">
        {{error()}}
      </div>
      
      <div *ngFor="let user of users()">
        {{user.name}}
      </div>
    </div>
  `
})
export class SignalUsersComponent {
  users = this.userService.users;
  loading = this.userService.loading;
  error = this.userService.error;
  
  // Computed signal
  userCount = computed(() => this.users().length);
  
  constructor(private userService: SignalUserService) {
    // Effect for side effects in component
    effect(() => {
      const count = this.userCount();
      if (count > 0) {
        // Side effect: update document title
        document.title = `Users (${count})`;
      }
    });
  }
  
  loadUsers(): void {
    this.userService.loadUsers();
  }
}
```

**5. Advanced Side Effect Patterns:**

```typescript
// cache.service.ts - Side effect with caching strategy
@Injectable({ providedIn: 'root' })
export class CacheService {
  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();
  
  get<T>(key: string): T | null {
    const cached = this.cache.get(key);
    if (!cached) return null;
    
    if (Date.now() > cached.timestamp + cached.ttl) {
      // Side effect: cleanup expired cache
      this.cache.delete(key);
      return null;
    }
    
    return cached.data;
  }
  
  set<T>(key: string, data: T, ttl: number = 300000): void {
    // Side effect: store in cache
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
    
    // Side effect: cleanup old entries
    this.cleanupExpiredEntries();
  }
  
  private cleanupExpiredEntries(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.timestamp + entry.ttl) {
        this.cache.delete(key);
      }
    }
  }
}

// offline.service.ts - Side effects for offline handling
@Injectable({ providedIn: 'root' })
export class OfflineService {
  private onlineSubject = new BehaviorSubject<boolean>(navigator.onLine);
  online$ = this.onlineSubject.asObservable();
  
  private pendingRequests: PendingRequest[] = [];
  
  constructor(private http: HttpClient) {
    // Side effect: listen to online/offline events
    fromEvent(window, 'online').subscribe(() => {
      this.onlineSubject.next(true);
      this.processPendingRequests();
    });
    
    fromEvent(window, 'offline').subscribe(() => {
      this.onlineSubject.next(false);
    });
  }
  
  makeRequest<T>(url: string, options?: any): Observable<T> {
    if (this.onlineSubject.value) {
      return this.http.request<T>('GET', url, options);
    } else {
      // Side effect: queue request for later
      return new Observable<T>(observer => {
        this.pendingRequests.push({
          url,
          options,
          observer
        });
      });
    }
  }
  
  private processPendingRequests(): void {
    // Side effect: process queued requests when back online
    const requests = [...this.pendingRequests];
    this.pendingRequests = [];
    
    requests.forEach(({ url, options, observer }) => {
      this.http.request('GET', url, options).subscribe(
        data => observer.next(data),
        error => observer.error(error),
        () => observer.complete()
      );
    });
  }
}

interface PendingRequest {
  url: string;
  options?: any;
  observer: any;
}
```

**Side Effect Categories:**

**1. Network Side Effects:**
- HTTP requests
- WebSocket connections
- File uploads/downloads
- Real-time data synchronization

**2. Storage Side Effects:**
- LocalStorage/SessionStorage operations
- IndexedDB transactions
- Cookie management
- Cache operations

**3. DOM Side Effects:**
- Direct DOM manipulation
- Focus management
- Scroll position changes
- Dynamic style updates

**4. Navigation Side Effects:**
- Route changes
- URL updates
- Browser history manipulation
- Deep linking

**5. External Integration Side Effects:**
- Analytics tracking
- Error reporting
- Third-party API calls
- Social media integrations

**Best Practices for Side Effects:**

1. **Isolate Side Effects**: Keep them separate from pure functions
2. **Use Reactive Patterns**: Leverage RxJS for complex side effect chains
3. **Handle Errors**: Always include error handling for side effects
4. **Clean Up**: Unsubscribe and clean up resources
5. **Test Side Effects**: Mock external dependencies in tests
6. **Use Effects/Services**: Don't put side effects in reducers or pure functions
7. **Consider Performance**: Debounce, throttle, or cache when appropriate

[Back to State Management](#state-management)

### 130. What is the difference between local component state and global state?

**Answer:**
Local component state and global state represent different scopes and lifetimes of data in Angular applications. Understanding when to use each approach is crucial for building maintainable and performant applications.

**Local Component State:**

**1. Basic Local State Examples:**

```typescript
// Simple local state with properties
@Component({
  selector: 'app-todo-item',
  template: `
    <div class="todo-item" [class.editing]="isEditing">
      <div *ngIf="!isEditing" class="view-mode">
        <span [class.completed]="todo.completed">{{todo.text}}</span>
        <button (click)="startEdit()">Edit</button>
        <button (click)="toggle()">{{todo.completed ? 'Undo' : 'Complete'}}</button>
        <button (click)="delete()">Delete</button>
      </div>
      
      <div *ngIf="isEditing" class="edit-mode">
        <input [(ngModel)]="editText" 
               (keyup.enter)="saveEdit()"
               (keyup.escape)="cancelEdit()"
               #editInput />
        <button (click)="saveEdit()">Save</button>
        <button (click)="cancelEdit()">Cancel</button>
      </div>
    </div>
  `
})
export class TodoItemComponent {
  @Input() todo!: Todo;
  @Output() todoChange = new EventEmitter<Todo>();
  @Output() todoDelete = new EventEmitter<string>();
  
  // Local component state
  isEditing = false;
  editText = '';
  
  startEdit(): void {
    this.isEditing = true;
    this.editText = this.todo.text;
    
    // Focus input after view update
    setTimeout(() => {
      const input = document.querySelector('input') as HTMLInputElement;
      input?.focus();
    });
  }
  
  saveEdit(): void {
    if (this.editText.trim()) {
      const updatedTodo = { ...this.todo, text: this.editText.trim() };
      this.todoChange.emit(updatedTodo);
      this.isEditing = false;
    }
  }
  
  cancelEdit(): void {
    this.isEditing = false;
    this.editText = '';
  }
  
  toggle(): void {
    const updatedTodo = { ...this.todo, completed: !this.todo.completed };
    this.todoChange.emit(updatedTodo);
  }
  
  delete(): void {
    this.todoDelete.emit(this.todo.id);
  }
}

// Complex local state with reactive forms
@Component({
  selector: 'app-user-profile-form',
  template: `
    <form [formGroup]="profileForm" (ngSubmit)="onSubmit()">
      <div class="form-section">
        <h3>Personal Information</h3>
        <input formControlName="firstName" placeholder="First Name" />
        <input formControlName="lastName" placeholder="Last Name" />
        <input formControlName="email" type="email" placeholder="Email" />
      </div>
      
      <div class="form-section">
        <h3>Address</h3>
        <div formGroupName="address">
          <input formControlName="street" placeholder="Street" />
          <input formControlName="city" placeholder="City" />
          <input formControlName="zipCode" placeholder="ZIP Code" />
        </div>
      </div>
      
      <div class="form-section">
        <h3>Preferences</h3>
        <label>
          <input type="checkbox" formControlName="newsletter" />
          Subscribe to newsletter
        </label>
        <select formControlName="theme">
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="auto">Auto</option>
        </select>
      </div>
      
      <div class="form-actions">
        <button type="submit" [disabled]="profileForm.invalid || saving">
          {{saving ? 'Saving...' : 'Save Profile'}}
        </button>
        <button type="button" (click)="resetForm()">Reset</button>
        <button type="button" (click)="loadDefaults()">Load Defaults</button>
      </div>
      
      <div *ngIf="validationErrors.length > 0" class="errors">
        <div *ngFor="let error of validationErrors">{{error}}</div>
      </div>
      
      <div *ngIf="saveMessage" class="message" [class.success]="saveSuccess">
        {{saveMessage}}
      </div>
    </form>
  `
})
export class UserProfileFormComponent implements OnInit {
  @Input() user: User | null = null;
  @Output() profileSaved = new EventEmitter<UserProfile>();
  
  // Local form state
  profileForm: FormGroup;
  saving = false;
  saveMessage = '';
  saveSuccess = false;
  validationErrors: string[] = [];
  
  // Local UI state
  private initialFormValue: any;
  
  constructor(
    private fb: FormBuilder,
    private userService: UserService
  ) {
    this.profileForm = this.createForm();
  }
  
  ngOnInit(): void {
    if (this.user) {
      this.loadUserData(this.user);
    }
    
    // Track form changes for unsaved changes warning
    this.profileForm.valueChanges.pipe(
      debounceTime(500)
    ).subscribe(() => {
      this.validateForm();
    });
  }
  
  private createForm(): FormGroup {
    return this.fb.group({
      firstName: ['', [Validators.required, Validators.minLength(2)]],
      lastName: ['', [Validators.required, Validators.minLength(2)]],
      email: ['', [Validators.required, Validators.email]],
      address: this.fb.group({
        street: [''],
        city: ['', Validators.required],
        zipCode: ['', [Validators.pattern(/^\d{5}$/)]]
      }),
      newsletter: [false],
      theme: ['light']
    });
  }
  
  private loadUserData(user: User): void {
    const formValue = {
      firstName: user.firstName,
      lastName: user.lastName,
      email: user.email,
      address: {
        street: user.address?.street || '',
        city: user.address?.city || '',
        zipCode: user.address?.zipCode || ''
      },
      newsletter: user.preferences?.newsletter || false,
      theme: user.preferences?.theme || 'light'
    };
    
    this.profileForm.patchValue(formValue);
    this.initialFormValue = formValue;
  }
  
  onSubmit(): void {
    if (this.profileForm.valid) {
      this.saving = true;
      this.saveMessage = '';
      
      const profile = this.profileForm.value;
      
      this.userService.updateProfile(profile).subscribe({
        next: (updatedProfile) => {
          this.profileSaved.emit(updatedProfile);
          this.saveMessage = 'Profile saved successfully!';
          this.saveSuccess = true;
          this.saving = false;
          this.initialFormValue = this.profileForm.value;
        },
        error: (error) => {
          this.saveMessage = 'Failed to save profile. Please try again.';
          this.saveSuccess = false;
          this.saving = false;
        }
      });
    }
  }
  
  resetForm(): void {
    this.profileForm.reset(this.initialFormValue);
    this.validationErrors = [];
    this.saveMessage = '';
  }
  
  loadDefaults(): void {
    const defaults = {
      firstName: '',
      lastName: '',
      email: '',
      address: { street: '', city: '', zipCode: '' },
      newsletter: false,
      theme: 'light'
    };
    
    this.profileForm.patchValue(defaults);
  }
  
  private validateForm(): void {
    this.validationErrors = [];
    
    if (this.profileForm.get('firstName')?.hasError('required')) {
      this.validationErrors.push('First name is required');
    }
    
    if (this.profileForm.get('email')?.hasError('email')) {
      this.validationErrors.push('Please enter a valid email address');
    }
    
    // Custom validation logic
    const zipCode = this.profileForm.get('address.zipCode')?.value;
    if (zipCode && !/^\d{5}$/.test(zipCode)) {
      this.validationErrors.push('ZIP code must be 5 digits');
    }
  }
  
  get hasUnsavedChanges(): boolean {
    return JSON.stringify(this.profileForm.value) !== JSON.stringify(this.initialFormValue);
  }
}
```

**Global State Examples:**

**2. Service-Based Global State:**

```typescript
// Global state service
@Injectable({ providedIn: 'root' })
export class AppStateService {
  // Global user state
  private currentUserSubject = new BehaviorSubject<User | null>(null);
  currentUser$ = this.currentUserSubject.asObservable();
  
  // Global UI state
  private sidebarOpenSubject = new BehaviorSubject<boolean>(false);
  sidebarOpen$ = this.sidebarOpenSubject.asObservable();
  
  // Global theme state
  private themeSubject = new BehaviorSubject<Theme>('light');
  theme$ = this.themeSubject.asObservable();
  
  // Global notification state
  private notificationsSubject = new BehaviorSubject<Notification[]>([]);
  notifications$ = this.notificationsSubject.asObservable();
  
  // Global loading state
  private loadingSubject = new BehaviorSubject<boolean>(false);
  loading$ = this.loadingSubject.asObservable();
  
  constructor(private http: HttpClient) {
    this.initializeFromStorage();
  }
  
  // User actions
  setCurrentUser(user: User | null): void {
    this.currentUserSubject.next(user);
    if (user) {
      localStorage.setItem('currentUser', JSON.stringify(user));
    } else {
      localStorage.removeItem('currentUser');
    }
  }
  
  // UI actions
  toggleSidebar(): void {
    this.sidebarOpenSubject.next(!this.sidebarOpenSubject.value);
  }
  
  setSidebarOpen(open: boolean): void {
    this.sidebarOpenSubject.next(open);
  }
  
  // Theme actions
  setTheme(theme: Theme): void {
    this.themeSubject.next(theme);
    localStorage.setItem('theme', theme);
    document.documentElement.setAttribute('data-theme', theme);
  }
  
  // Notification actions
  addNotification(notification: Omit<Notification, 'id' | 'timestamp'>): void {
    const newNotification: Notification = {
      ...notification,
      id: Math.random().toString(36),
      timestamp: Date.now()
    };
    
    const current = this.notificationsSubject.value;
    this.notificationsSubject.next([...current, newNotification]);
    
    // Auto-remove after delay
    if (notification.autoRemove !== false) {
      timer(notification.duration || 5000).subscribe(() => {
        this.removeNotification(newNotification.id);
      });
    }
  }
  
  removeNotification(id: string): void {
    const current = this.notificationsSubject.value;
    this.notificationsSubject.next(current.filter(n => n.id !== id));
  }
  
  // Loading actions
  setLoading(loading: boolean): void {
    this.loadingSubject.next(loading);
  }
  
  private initializeFromStorage(): void {
    // Restore user from localStorage
    const savedUser = localStorage.getItem('currentUser');
    if (savedUser) {
      try {
        this.currentUserSubject.next(JSON.parse(savedUser));
      } catch (e) {
        localStorage.removeItem('currentUser');
      }
    }
    
    // Restore theme
    const savedTheme = localStorage.getItem('theme') as Theme;
    if (savedTheme) {
      this.setTheme(savedTheme);
    }
  }
}

// Components using global state
@Component({
  selector: 'app-header',
  template: `
    <header class="app-header">
      <button (click)="toggleSidebar()" class="menu-button">
        <i class="icon-menu"></i>
      </button>
      
      <h1 class="app-title">My App</h1>
      
      <div class="header-actions">
        <button (click)="toggleTheme()" class="theme-toggle">
          <i [class]="themeIcon"></i>
        </button>
        
        <div *ngIf="currentUser$ | async as user" class="user-menu">
          <span>Welcome, {{user.firstName}}</span>
          <button (click)="logout()">Logout</button>
        </div>
        
        <div *ngIf="!(currentUser$ | async)" class="auth-buttons">
          <button routerLink="/login">Login</button>
          <button routerLink="/register">Register</button>
        </div>
      </div>
      
      <div *ngIf="loading$ | async" class="global-loading">
        <div class="spinner"></div>
      </div>
    </header>
  `
})
export class HeaderComponent {
  currentUser$ = this.appState.currentUser$;
  theme$ = this.appState.theme$;
  loading$ = this.appState.loading$;
  
  themeIcon = 'icon-sun';
  
  constructor(private appState: AppStateService) {
    this.theme$.subscribe(theme => {
      this.themeIcon = theme === 'dark' ? 'icon-moon' : 'icon-sun';
    });
  }
  
  toggleSidebar(): void {
    this.appState.toggleSidebar();
  }
  
  toggleTheme(): void {
    this.theme$.pipe(take(1)).subscribe(currentTheme => {
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      this.appState.setTheme(newTheme);
    });
  }
  
  logout(): void {
    this.appState.setCurrentUser(null);
    this.appState.addNotification({
      type: 'info',
      message: 'You have been logged out successfully'
    });
  }
}
```

**3. NgRx Global State:**

```typescript
// Global state with NgRx
interface AppState {
  auth: AuthState;
  ui: UiState;
  notifications: NotificationState;
}

interface AuthState {
  currentUser: User | null;
  isAuthenticated: boolean;
  loading: boolean;
}

interface UiState {
  sidebarOpen: boolean;
  theme: Theme;
  loading: boolean;
}

// Actions
export const AuthActions = createActionGroup({
  source: 'Auth',
  events: {
    'Login': props<{ credentials: LoginCredentials }>(),
    'Login Success': props<{ user: User }>(),
    'Login Failure': props<{ error: string }>(),
    'Logout': emptyProps(),
    'Set Current User': props<{ user: User | null }>()
  }
});

export const UiActions = createActionGroup({
  source: 'UI',
  events: {
    'Toggle Sidebar': emptyProps(),
    'Set Sidebar Open': props<{ open: boolean }>(),
    'Set Theme': props<{ theme: Theme }>(),
    'Set Loading': props<{ loading: boolean }>()
  }
});

// Selectors
export const selectAuthState = createFeatureSelector<AuthState>('auth');
export const selectCurrentUser = createSelector(
  selectAuthState,
  (state: AuthState) => state.currentUser
);
export const selectIsAuthenticated = createSelector(
  selectAuthState,
  (state: AuthState) => state.isAuthenticated
);

export const selectUiState = createFeatureSelector<UiState>('ui');
export const selectSidebarOpen = createSelector(
  selectUiState,
  (state: UiState) => state.sidebarOpen
);
export const selectTheme = createSelector(
  selectUiState,
  (state: UiState) => state.theme
);

// Component using NgRx global state
@Component({
  selector: 'app-dashboard',
  template: `
    <div class="dashboard" [class.sidebar-open]="sidebarOpen$ | async">
      <aside class="sidebar" *ngIf="sidebarOpen$ | async">
        <nav>
          <a routerLink="/dashboard" routerLinkActive="active">Dashboard</a>
          <a routerLink="/users" routerLinkActive="active">Users</a>
          <a routerLink="/settings" routerLinkActive="active">Settings</a>
        </nav>
      </aside>
      
      <main class="main-content">
        <div *ngIf="currentUser$ | async as user">
          <h2>Welcome back, {{user.firstName}}!</h2>
          <p>Last login: {{user.lastLogin | date}}</p>
        </div>
        
        <router-outlet></router-outlet>
      </main>
    </div>
  `
})
export class DashboardComponent {
  currentUser$ = this.store.select(selectCurrentUser);
  sidebarOpen$ = this.store.select(selectSidebarOpen);
  theme$ = this.store.select(selectTheme);
  
  constructor(private store: Store<AppState>) {}
}
```

**Comparison Table:**

| Aspect | Local Component State | Global State |
|--------|----------------------|-------------|
| **Scope** | Single component and its children | Entire application |
| **Lifetime** | Component lifecycle | Application lifecycle |
| **Sharing** | Parent-child via @Input/@Output | Any component can access |
| **Complexity** | Simple properties and methods | Services, stores, state management |
| **Performance** | Fast, direct access | Slight overhead for state management |
| **Memory** | Destroyed with component | Persists throughout app |
| **Testing** | Easy to test in isolation | Requires mocking/setup |
| **Debugging** | Simple debugging | May need specialized tools |
| **Use Cases** | Form state, UI toggles, temporary data | User auth, app settings, shared data |

**When to Use Local State:**
- Form input values and validation states
- Component-specific UI states (expanded/collapsed, editing mode)
- Temporary data that doesn't need to be shared
- Loading states for component-specific operations
- Modal/dialog visibility states
- Component-specific filters or sorting

**When to Use Global State:**
- User authentication and authorization
- Application-wide settings (theme, language)
- Data shared between multiple components
- Navigation state and routing data
- Notifications and alerts
- Shopping cart or similar persistent data
- Real-time data that multiple components need

**Best Practices:**

1. **Start Local, Go Global When Needed**: Begin with local state and move to global when sharing is required
2. **Use the Right Tool**: Simple local state for simple needs, global state for complex sharing
3. **Avoid Over-Globalization**: Not everything needs to be in global state
4. **Consider Component Communication**: Sometimes parent-child communication is better than global state
5. **Think About Persistence**: Global state is better for data that needs to persist across navigation
6. **Performance Considerations**: Local state has less overhead than global state management

[Back to State Management](#state-management)

### 131. NgRx/ComponentStore vs service-with-RxJS vs Signals Store

**Answer:**
Each state management approach in Angular serves different use cases and has distinct characteristics. Understanding their strengths and trade-offs helps in choosing the right approach for your application needs.

**1. NgRx Store (Global State Management):**

```typescript
// NgRx Store Implementation
// state/user.state.ts
export interface UserState {
  users: User[];
  selectedUser: User | null;
  loading: boolean;
  error: string | null;
  filters: UserFilters;
}

const initialState: UserState = {
  users: [],
  selectedUser: null,
  loading: false,
  error: null,
  filters: { role: null, searchTerm: '' }
};

// actions/user.actions.ts
export const UserActions = createActionGroup({
  source: 'User',
  events: {
    'Load Users': emptyProps(),
    'Load Users Success': props<{ users: User[] }>(),
    'Load Users Failure': props<{ error: string }>(),
    'Select User': props<{ userId: string }>(),
    'Update User': props<{ user: User }>(),
    'Set Filter': props<{ filters: Partial<UserFilters> }>()
  }
});

// reducers/user.reducer.ts
export const userReducer = createReducer(
  initialState,
  on(UserActions.loadUsers, (state) => ({
    ...state,
    loading: true,
    error: null
  })),
  on(UserActions.loadUsersSuccess, (state, { users }) => ({
    ...state,
    users,
    loading: false
  })),
  on(UserActions.loadUsersFailure, (state, { error }) => ({
    ...state,
    error,
    loading: false
  })),
  on(UserActions.selectUser, (state, { userId }) => ({
    ...state,
    selectedUser: state.users.find(u => u.id === userId) || null
  })),
  on(UserActions.setFilter, (state, { filters }) => ({
    ...state,
    filters: { ...state.filters, ...filters }
  }))
);

// effects/user.effects.ts
@Injectable()
export class UserEffects {
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.loadUsers),
      switchMap(() =>
        this.http.get<User[]>('/api/users').pipe(
          map(users => UserActions.loadUsersSuccess({ users })),
          catchError(error => of(UserActions.loadUsersFailure({ error: error.message })))
        )
      )
    )
  );
  
  constructor(
    private actions$: Actions,
    private http: HttpClient
  ) {}
}

// selectors/user.selectors.ts
export const selectUserState = createFeatureSelector<UserState>('users');

export const selectUsers = createSelector(
  selectUserState,
  (state) => state.users
);

export const selectFilteredUsers = createSelector(
  selectUsers,
  createSelector(selectUserState, (state) => state.filters),
  (users, filters) => {
    let filtered = users;
    
    if (filters.role) {
      filtered = filtered.filter(user => user.role === filters.role);
    }
    
    if (filters.searchTerm) {
      const term = filters.searchTerm.toLowerCase();
      filtered = filtered.filter(user => 
        user.name.toLowerCase().includes(term) ||
        user.email.toLowerCase().includes(term)
      );
    }
    
    return filtered;
  }
);

// Component using NgRx Store
@Component({
  selector: 'app-ngrx-users',
  template: `
    <div>
      <input [(ngModel)]="searchTerm" 
             (input)="onSearch($event)" 
             placeholder="Search users..." />
      
      <select [(ngModel)]="selectedRole" (change)="onRoleFilter($event)">
        <option value="">All Roles</option>
        <option value="admin">Admin</option>
        <option value="user">User</option>
      </select>
      
      <button (click)="loadUsers()" [disabled]="loading$ | async">
        {{(loading$ | async) ? 'Loading...' : 'Load Users'}}
      </button>
      
      <div *ngIf="error$ | async as error" class="error">
        {{error}}
      </div>
      
      <div *ngFor="let user of filteredUsers$ | async" 
           (click)="selectUser(user.id)"
           [class.selected]="(selectedUser$ | async)?.id === user.id">
        {{user.name}} - {{user.role}}
      </div>
    </div>
  `
})
export class NgRxUsersComponent {
  users$ = this.store.select(selectUsers);
  filteredUsers$ = this.store.select(selectFilteredUsers);
  selectedUser$ = this.store.select(selectSelectedUser);
  loading$ = this.store.select(selectUserLoading);
  error$ = this.store.select(selectUserError);
  
  searchTerm = '';
  selectedRole = '';
  
  constructor(private store: Store) {}
  
  loadUsers(): void {
    this.store.dispatch(UserActions.loadUsers());
  }
  
  selectUser(userId: string): void {
    this.store.dispatch(UserActions.selectUser({ userId }));
  }
  
  onSearch(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.searchTerm = target.value;
    this.store.dispatch(UserActions.setFilter({ 
      filters: { searchTerm: this.searchTerm } 
    }));
  }
  
  onRoleFilter(event: Event): void {
    const target = event.target as HTMLSelectElement;
    this.selectedRole = target.value;
    this.store.dispatch(UserActions.setFilter({ 
      filters: { role: target.value as UserRole || null } 
    }));
  }
}
```

**2. NgRx ComponentStore (Feature-Level State):**

```typescript
// ComponentStore Implementation
interface TodoState {
  todos: Todo[];
  filter: TodoFilter;
  loading: boolean;
  error: string | null;
}

type TodoFilter = 'all' | 'active' | 'completed';

@Injectable()
export class TodoStore extends ComponentStore<TodoState> {
  constructor(private http: HttpClient) {
    super({
      todos: [],
      filter: 'all',
      loading: false,
      error: null
    });
  }
  
  // Selectors
  readonly todos$ = this.select(state => state.todos);
  readonly filter$ = this.select(state => state.filter);
  readonly loading$ = this.select(state => state.loading);
  readonly error$ = this.select(state => state.error);
  
  readonly filteredTodos$ = this.select(
    this.todos$,
    this.filter$,
    (todos, filter) => {
      switch (filter) {
        case 'active':
          return todos.filter(todo => !todo.completed);
        case 'completed':
          return todos.filter(todo => todo.completed);
        default:
          return todos;
      }
    },
    { debounce: true } // Debounce selector updates
  );
  
  readonly todoStats$ = this.select(
    this.todos$,
    (todos) => ({
      total: todos.length,
      active: todos.filter(t => !t.completed).length,
      completed: todos.filter(t => t.completed).length
    })
  );
  
  // Updaters
  readonly setLoading = this.updater((state, loading: boolean) => ({
    ...state,
    loading
  }));
  
  readonly setError = this.updater((state, error: string | null) => ({
    ...state,
    error
  }));
  
  readonly setTodos = this.updater((state, todos: Todo[]) => ({
    ...state,
    todos
  }));
  
  readonly addTodo = this.updater((state, todo: Todo) => ({
    ...state,
    todos: [...state.todos, todo]
  }));
  
  readonly updateTodo = this.updater((state, updatedTodo: Todo) => ({
    ...state,
    todos: state.todos.map(todo =>
      todo.id === updatedTodo.id ? updatedTodo : todo
    )
  }));
  
  readonly removeTodo = this.updater((state, todoId: string) => ({
    ...state,
    todos: state.todos.filter(todo => todo.id !== todoId)
  }));
  
  readonly setFilter = this.updater((state, filter: TodoFilter) => ({
    ...state,
    filter
  }));
  
  // Effects
  readonly loadTodos = this.effect((trigger$: Observable<void>) =>
    trigger$.pipe(
      tap(() => this.setLoading(true)),
      switchMap(() =>
        this.http.get<Todo[]>('/api/todos').pipe(
          tapResponse(
            (todos) => {
              this.setTodos(todos);
              this.setLoading(false);
            },
            (error: HttpErrorResponse) => {
              this.setError(error.message);
              this.setLoading(false);
            }
          )
        )
      )
    )
  );
  
  readonly saveTodo = this.effect((todo$: Observable<Omit<Todo, 'id'>>) =>
    todo$.pipe(
      switchMap((todoData) =>
        this.http.post<Todo>('/api/todos', todoData).pipe(
          tapResponse(
            (todo) => this.addTodo(todo),
            (error: HttpErrorResponse) => this.setError(error.message)
          )
        )
      )
    )
  );
}

// Component using ComponentStore
@Component({
  selector: 'app-todo-list',
  template: `
    <div>
      <div class="todo-header">
        <input #newTodoInput 
               (keyup.enter)="addTodo(newTodoInput.value); newTodoInput.value = ''" 
               placeholder="Add new todo..." />
        
        <div class="filters">
          <button *ngFor="let f of filters" 
                  (click)="setFilter(f)"
                  [class.active]="(filter$ | async) === f">
            {{f | titlecase}}
          </button>
        </div>
      </div>
      
      <div *ngIf="loading$ | async" class="loading">Loading...</div>
      <div *ngIf="error$ | async as error" class="error">{{error}}</div>
      
      <div class="todo-list">
        <div *ngFor="let todo of filteredTodos$ | async" class="todo-item">
          <input type="checkbox" 
                 [checked]="todo.completed"
                 (change)="toggleTodo(todo)" />
          <span [class.completed]="todo.completed">{{todo.text}}</span>
          <button (click)="deleteTodo(todo.id)">Delete</button>
        </div>
      </div>
      
      <div class="todo-stats" *ngIf="todoStats$ | async as stats">
        Total: {{stats.total}}, Active: {{stats.active}}, Completed: {{stats.completed}}
      </div>
    </div>
  `,
  providers: [TodoStore] // Provided at component level
})
export class TodoListComponent implements OnInit {
  filteredTodos$ = this.todoStore.filteredTodos$;
  filter$ = this.todoStore.filter$;
  loading$ = this.todoStore.loading$;
  error$ = this.todoStore.error$;
  todoStats$ = this.todoStore.todoStats$;
  
  filters: TodoFilter[] = ['all', 'active', 'completed'];
  
  constructor(private todoStore: TodoStore) {}
  
  ngOnInit(): void {
    this.todoStore.loadTodos();
  }
  
  addTodo(text: string): void {
    if (text.trim()) {
      this.todoStore.saveTodo({ text: text.trim(), completed: false });
    }
  }
  
  toggleTodo(todo: Todo): void {
    this.todoStore.updateTodo({ ...todo, completed: !todo.completed });
  }
  
  deleteTodo(todoId: string): void {
    this.todoStore.removeTodo(todoId);
  }
  
  setFilter(filter: TodoFilter): void {
    this.todoStore.setFilter(filter);
  }
}
```

**3. Service with RxJS (Manual State Management):**

```typescript
// Service with RxJS Implementation
@Injectable({ providedIn: 'root' })
export class ProductService {
  // Private subjects for state
  private productsSubject = new BehaviorSubject<Product[]>([]);
  private selectedProductSubject = new BehaviorSubject<Product | null>(null);
  private loadingSubject = new BehaviorSubject<boolean>(false);
  private errorSubject = new BehaviorSubject<string | null>(null);
  private filtersSubject = new BehaviorSubject<ProductFilters>({
    category: null,
    priceRange: null,
    searchTerm: ''
  });
  
  // Public observables
  products$ = this.productsSubject.asObservable();
  selectedProduct$ = this.selectedProductSubject.asObservable();
  loading$ = this.loadingSubject.asObservable();
  error$ = this.errorSubject.asObservable();
  filters$ = this.filtersSubject.asObservable();
  
  // Computed observables
  filteredProducts$ = combineLatest([
    this.products$,
    this.filters$
  ]).pipe(
    map(([products, filters]) => {
      let filtered = products;
      
      if (filters.category) {
        filtered = filtered.filter(p => p.category === filters.category);
      }
      
      if (filters.priceRange) {
        filtered = filtered.filter(p => 
          p.price >= filters.priceRange!.min && 
          p.price <= filters.priceRange!.max
        );
      }
      
      if (filters.searchTerm) {
        const term = filters.searchTerm.toLowerCase();
        filtered = filtered.filter(p => 
          p.name.toLowerCase().includes(term) ||
          p.description.toLowerCase().includes(term)
        );
      }
      
      return filtered;
    }),
    shareReplay(1) // Cache the last result
  );
  
  productStats$ = this.products$.pipe(
    map(products => ({
      total: products.length,
      categories: [...new Set(products.map(p => p.category))],
      averagePrice: products.length > 0 
        ? products.reduce((sum, p) => sum + p.price, 0) / products.length 
        : 0
    })),
    shareReplay(1)
  );
  
  constructor(private http: HttpClient) {}
  
  // Actions
  loadProducts(): Observable<Product[]> {
    this.loadingSubject.next(true);
    this.errorSubject.next(null);
    
    return this.http.get<Product[]>('/api/products').pipe(
      tap(products => {
        this.productsSubject.next(products);
        this.loadingSubject.next(false);
      }),
      catchError(error => {
        this.errorSubject.next(error.message);
        this.loadingSubject.next(false);
        return throwError(() => error);
      }),
      finalize(() => this.loadingSubject.next(false))
    );
  }
  
  selectProduct(productId: string): void {
    const products = this.productsSubject.value;
    const product = products.find(p => p.id === productId) || null;
    this.selectedProductSubject.next(product);
  }
  
  updateFilters(filters: Partial<ProductFilters>): void {
    const currentFilters = this.filtersSubject.value;
    this.filtersSubject.next({ ...currentFilters, ...filters });
  }
  
  addProduct(product: Omit<Product, 'id'>): Observable<Product> {
    this.loadingSubject.next(true);
    
    return this.http.post<Product>('/api/products', product).pipe(
      tap(newProduct => {
        const currentProducts = this.productsSubject.value;
        this.productsSubject.next([...currentProducts, newProduct]);
        this.loadingSubject.next(false);
      }),
      catchError(error => {
        this.errorSubject.next(error.message);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }
  
  updateProduct(product: Product): Observable<Product> {
    this.loadingSubject.next(true);
    
    return this.http.put<Product>(`/api/products/${product.id}`, product).pipe(
      tap(updatedProduct => {
        const currentProducts = this.productsSubject.value;
        const updatedProducts = currentProducts.map(p => 
          p.id === updatedProduct.id ? updatedProduct : p
        );
        this.productsSubject.next(updatedProducts);
        
        // Update selected product if it's the one being updated
        const selectedProduct = this.selectedProductSubject.value;
        if (selectedProduct?.id === updatedProduct.id) {
          this.selectedProductSubject.next(updatedProduct);
        }
        
        this.loadingSubject.next(false);
      }),
      catchError(error => {
        this.errorSubject.next(error.message);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }
  
  deleteProduct(productId: string): Observable<void> {
    this.loadingSubject.next(true);
    
    return this.http.delete<void>(`/api/products/${productId}`).pipe(
      tap(() => {
        const currentProducts = this.productsSubject.value;
        const updatedProducts = currentProducts.filter(p => p.id !== productId);
        this.productsSubject.next(updatedProducts);
        
        // Clear selection if deleted product was selected
        const selectedProduct = this.selectedProductSubject.value;
        if (selectedProduct?.id === productId) {
          this.selectedProductSubject.next(null);
        }
        
        this.loadingSubject.next(false);
      }),
      catchError(error => {
        this.errorSubject.next(error.message);
        this.loadingSubject.next(false);
        return throwError(() => error);
      })
    );
  }
  
  clearError(): void {
    this.errorSubject.next(null);
  }
  
  // Helper methods
  getCurrentProducts(): Product[] {
    return this.productsSubject.value;
  }
  
  getCurrentFilters(): ProductFilters {
    return this.filtersSubject.value;
  }
}

// Component using Service with RxJS
@Component({
  selector: 'app-rxjs-products',
  template: `
    <div>
      <div class="product-controls">
        <input [(ngModel)]="searchTerm" 
               (input)="onSearch($event)" 
               placeholder="Search products..." />
        
        <select [(ngModel)]="selectedCategory" (change)="onCategoryChange($event)">
          <option value="">All Categories</option>
          <option *ngFor="let category of categories$ | async" [value]="category">
            {{category}}
          </option>
        </select>
        
        <button (click)="loadProducts()" [disabled]="loading$ | async">
          {{(loading$ | async) ? 'Loading...' : 'Load Products'}}
        </button>
      </div>
      
      <div *ngIf="error$ | async as error" class="error">
        {{error}}
        <button (click)="clearError()">Clear</button>
      </div>
      
      <div class="product-grid">
        <div *ngFor="let product of filteredProducts$ | async" 
             class="product-card"
             [class.selected]="(selectedProduct$ | async)?.id === product.id"
             (click)="selectProduct(product.id)">
          <h3>{{product.name}}</h3>
          <p>{{product.description}}</p>
          <p class="price">${{product.price}}</p>
          <p class="category">{{product.category}}</p>
        </div>
      </div>
      
      <div class="product-stats" *ngIf="productStats$ | async as stats">
        <p>Total Products: {{stats.total}}</p>
        <p>Average Price: ${{stats.averagePrice | number:'1.2-2'}}</p>
        <p>Categories: {{stats.categories.length}}</p>
      </div>
    </div>
  `
})
export class RxjsProductsComponent implements OnInit, OnDestroy {
  filteredProducts$ = this.productService.filteredProducts$;
  selectedProduct$ = this.productService.selectedProduct$;
  loading$ = this.productService.loading$;
  error$ = this.productService.error$;
  productStats$ = this.productService.productStats$;
  
  categories$ = this.productStats$.pipe(
    map(stats => stats.categories)
  );
  
  searchTerm = '';
  selectedCategory = '';
  
  private destroy$ = new Subject<void>();
  
  constructor(private productService: ProductService) {}
  
  ngOnInit(): void {
    this.loadProducts();
    
    // Set up debounced search
    this.productService.filters$.pipe(
      takeUntil(this.destroy$)
    ).subscribe(filters => {
      this.searchTerm = filters.searchTerm;
      this.selectedCategory = filters.category || '';
    });
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  loadProducts(): void {
    this.productService.loadProducts().subscribe();
  }
  
  selectProduct(productId: string): void {
    this.productService.selectProduct(productId);
  }
  
  onSearch(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.productService.updateFilters({ searchTerm: target.value });
  }
  
  onCategoryChange(event: Event): void {
    const target = event.target as HTMLSelectElement;
    this.productService.updateFilters({ 
      category: target.value || null 
    });
  }
  
  clearError(): void {
    this.productService.clearError();
  }
}
```

**4. Signals Store (Modern Angular 17+):**

```typescript
// Signals Store Implementation
@Injectable({ providedIn: 'root' })
export class SignalsCartService {
  // Private writable signals
  private _items = signal<CartItem[]>([]);
  private _loading = signal<boolean>(false);
  private _error = signal<string | null>(null);
  
  // Public readonly signals
  readonly items = this._items.asReadonly();
  readonly loading = this._loading.asReadonly();
  readonly error = this._error.asReadonly();
  
  // Computed signals
  readonly totalItems = computed(() => 
    this._items().reduce((sum, item) => sum + item.quantity, 0)
  );
  
  readonly totalPrice = computed(() => 
    this._items().reduce((sum, item) => sum + (item.price * item.quantity), 0)
  );
  
  readonly isEmpty = computed(() => this._items().length === 0);
  
  readonly itemsByCategory = computed(() => {
    const items = this._items();
    return items.reduce((acc, item) => {
      const category = item.category;
      if (!acc[category]) {
        acc[category] = [];
      }
      acc[category].push(item);
      return acc;
    }, {} as Record<string, CartItem[]>);
  });
  
  constructor(private http: HttpClient) {
    // Effects for side effects
    effect(() => {
      const items = this._items();
      // Persist to localStorage
      localStorage.setItem('cart', JSON.stringify(items));
    });
    
    effect(() => {
      const error = this._error();
      if (error) {
        console.error('Cart error:', error);
        // Could trigger notifications
      }
    });
    
    // Load from localStorage on init
    this.loadFromStorage();
  }
  
  // Actions
  addItem(product: Product, quantity: number = 1): void {
    const currentItems = this._items();
    const existingItemIndex = currentItems.findIndex(item => item.id === product.id);
    
    if (existingItemIndex >= 0) {
      // Update existing item
      const updatedItems = currentItems.map((item, index) => 
        index === existingItemIndex 
          ? { ...item, quantity: item.quantity + quantity }
          : item
      );
      this._items.set(updatedItems);
    } else {
      // Add new item
      const newItem: CartItem = {
        id: product.id,
        name: product.name,
        price: product.price,
        category: product.category,
        quantity
      };
      this._items.update(items => [...items, newItem]);
    }
  }
  
  removeItem(itemId: string): void {
    this._items.update(items => items.filter(item => item.id !== itemId));
  }
  
  updateQuantity(itemId: string, quantity: number): void {
    if (quantity <= 0) {
      this.removeItem(itemId);
      return;
    }
    
    this._items.update(items => 
      items.map(item => 
        item.id === itemId ? { ...item, quantity } : item
      )
    );
  }
  
  clearCart(): void {
    this._items.set([]);
  }
  
  checkout(): void {
    const items = this._items();
    if (items.length === 0) {
      this._error.set('Cart is empty');
      return;
    }
    
    this._loading.set(true);
    this._error.set(null);
    
    const orderData = {
      items,
      total: this.totalPrice(),
      timestamp: Date.now()
    };
    
    this.http.post<Order>('/api/orders', orderData).pipe(
      catchError(error => {
        this._error.set(error.message);
        return of(null);
      }),
      finalize(() => this._loading.set(false))
    ).subscribe(order => {
      if (order) {
        this.clearCart();
        // Success handled by effect or could emit event
      }
    });
  }
  
  private loadFromStorage(): void {
    const saved = localStorage.getItem('cart');
    if (saved) {
      try {
        const items = JSON.parse(saved);
        this._items.set(items);
      } catch (e) {
        console.error('Failed to load cart from storage:', e);
        localStorage.removeItem('cart');
      }
    }
  }
  
  clearError(): void {
    this._error.set(null);
  }
}

// Component using Signals Store
@Component({
  selector: 'app-signals-cart',
  template: `
    <div class="cart">
      <div class="cart-header">
        <h2>Shopping Cart ({{totalItems()}} items)</h2>
        <p class="total">Total: ${{totalPrice() | number:'1.2-2'}}</p>
      </div>
      
      <div *ngIf="error()" class="error">
        {{error()}}
        <button (click)="clearError()">Clear</button>
      </div>
      
      <div *ngIf="isEmpty()" class="empty-cart">
        Your cart is empty
      </div>
      
      <div *ngIf="!isEmpty()" class="cart-items">
        <div *ngFor="let item of items()" class="cart-item">
          <h4>{{item.name}}</h4>
          <p>{{item.category}} - ${{item.price}}</p>
          <div class="quantity-controls">
            <button (click)="decreaseQuantity(item.id)">-</button>
            <span>{{item.quantity}}</span>
            <button (click)="increaseQuantity(item.id)">+</button>
            <button (click)="removeItem(item.id)" class="remove">Remove</button>
          </div>
          <p class="subtotal">Subtotal: ${{(item.price * item.quantity) | number:'1.2-2'}}</p>
        </div>
      </div>
      
      <div *ngIf="!isEmpty()" class="cart-actions">
        <button (click)="clearCart()" class="clear">Clear Cart</button>
        <button (click)="checkout()" 
                [disabled]="loading()" 
                class="checkout">
          {{loading() ? 'Processing...' : 'Checkout'}}
        </button>
      </div>
      
      <div class="cart-summary">
        <h3>By Category:</h3>
        <div *ngFor="let category of getCategories()">
          <h4>{{category}}</h4>
          <div *ngFor="let item of getItemsByCategory(category)">
            {{item.name}} x{{item.quantity}}
          </div>
        </div>
      </div>
    </div>
  `
})
export class SignalsCartComponent {
  // Direct access to signals
  items = this.cartService.items;
  loading = this.cartService.loading;
  error = this.cartService.error;
  totalItems = this.cartService.totalItems;
  totalPrice = this.cartService.totalPrice;
  isEmpty = this.cartService.isEmpty;
  itemsByCategory = this.cartService.itemsByCategory;
  
  constructor(private cartService: SignalsCartService) {}
  
  removeItem(itemId: string): void {
    this.cartService.removeItem(itemId);
  }
  
  increaseQuantity(itemId: string): void {
    const item = this.items().find(i => i.id === itemId);
    if (item) {
      this.cartService.updateQuantity(itemId, item.quantity + 1);
    }
  }
  
  decreaseQuantity(itemId: string): void {
    const item = this.items().find(i => i.id === itemId);
    if (item && item.quantity > 1) {
      this.cartService.updateQuantity(itemId, item.quantity - 1);
    } else if (item) {
      this.cartService.removeItem(itemId);
    }
  }
  
  clearCart(): void {
    this.cartService.clearCart();
  }
  
  checkout(): void {
    this.cartService.checkout();
  }
  
  clearError(): void {
    this.cartService.clearError();
  }
  
  getCategories(): string[] {
    return Object.keys(this.itemsByCategory());
  }
  
  getItemsByCategory(category: string): CartItem[] {
    return this.itemsByCategory()[category] || [];
  }
}
```

**Comparison Summary:**

| Feature | NgRx Store | ComponentStore | Service + RxJS | Signals Store |
|---------|------------|----------------|----------------|--------------|
| **Scope** | Global | Feature/Component | Global/Service | Global/Service |
| **Boilerplate** | High | Medium | Low | Very Low |
| **Learning Curve** | Steep | Moderate | Easy | Easy |
| **DevTools** | Excellent | Good | Limited | Basic |
| **Performance** | Excellent | Excellent | Good | Excellent |
| **Testing** | Complex | Moderate | Easy | Easy |
| **Time Travel** | Yes | No | No | No |
| **Type Safety** | Excellent | Excellent | Good | Excellent |
| **Bundle Size** | Large | Medium | Small | Small |

**When to Use Each:**

**NgRx Store:**
- Large, complex applications
- Multiple teams working on the same codebase
- Need for time-travel debugging
- Complex state interactions
- Audit requirements

**ComponentStore:**
- Feature-specific state management
- Component tree state sharing
- Less boilerplate than full NgRx
- Local state that needs reactive patterns

**Service + RxJS:**
- Medium-sized applications
- Team familiar with RxJS
- Need flexibility in state management
- Gradual adoption of state management

**Signals Store:**
- Modern Angular applications (17+)
- Simple to medium complexity
- Want reactive programming with less boilerplate
- Performance-critical applications

[Back to State Management](#state-management)

### 132. What are reducers and how do they work?

**Answer:**
Reducers in NgRx are pure functions that specify how the application state changes in response to actions. They take the current state and an action as arguments and return a new state object. Reducers are the only way to modify state in NgRx, ensuring predictable state updates.

**Core Reducer Concepts:**

**1. Basic Reducer Structure:**

```typescript
// Basic reducer function signature
type ReducerFunction<T> = (state: T, action: Action) => T;

// Simple counter example
interface CounterState {
  count: number;
  lastUpdated: number;
}

const initialState: CounterState = {
  count: 0,
  lastUpdated: Date.now()
};

// Traditional reducer function
function counterReducer(
  state: CounterState = initialState, 
  action: Action
): CounterState {
  switch (action.type) {
    case 'INCREMENT':
      return {
        ...state,
        count: state.count + 1,
        lastUpdated: Date.now()
      };
      
    case 'DECREMENT':
      return {
        ...state,
        count: state.count - 1,
        lastUpdated: Date.now()
      };
      
    case 'RESET':
      return {
        ...state,
        count: 0,
        lastUpdated: Date.now()
      };
      
    default:
      return state;
  }
}
```

**2. Modern NgRx createReducer API:**

```typescript
// user.actions.ts
export const UserActions = createActionGroup({
  source: 'User',
  events: {
    'Load Users': emptyProps(),
    'Load Users Success': props<{ users: User[] }>(),
    'Load Users Failure': props<{ error: string }>(),
    'Add User': props<{ user: User }>(),
    'Update User': props<{ user: User }>(),
    'Delete User': props<{ userId: string }>(),
    'Select User': props<{ userId: string }>(),
    'Clear Selection': emptyProps(),
    'Set Filter': props<{ filter: UserFilter }>(),
    'Clear Error': emptyProps()
  }
});

// user.state.ts
export interface UserState {
  users: User[];
  selectedUserId: string | null;
  loading: boolean;
  error: string | null;
  filter: UserFilter;
  lastUpdated: number;
}

export interface UserFilter {
  searchTerm: string;
  role: 'admin' | 'user' | null;
  status: 'active' | 'inactive' | null;
}

const initialState: UserState = {
  users: [],
  selectedUserId: null,
  loading: false,
  error: null,
  filter: {
    searchTerm: '',
    role: null,
    status: null
  },
  lastUpdated: 0
};

// user.reducer.ts - Modern createReducer approach
export const userReducer = createReducer(
  initialState,
  
  // Loading states
  on(UserActions.loadUsers, (state) => ({
    ...state,
    loading: true,
    error: null
  })),
  
  on(UserActions.loadUsersSuccess, (state, { users }) => ({
    ...state,
    users,
    loading: false,
    error: null,
    lastUpdated: Date.now()
  })),
  
  on(UserActions.loadUsersFailure, (state, { error }) => ({
    ...state,
    loading: false,
    error,
    lastUpdated: Date.now()
  })),
  
  // CRUD operations
  on(UserActions.addUser, (state, { user }) => ({
    ...state,
    users: [...state.users, user],
    lastUpdated: Date.now()
  })),
  
  on(UserActions.updateUser, (state, { user }) => ({
    ...state,
    users: state.users.map(existingUser => 
      existingUser.id === user.id ? user : existingUser
    ),
    lastUpdated: Date.now()
  })),
  
  on(UserActions.deleteUser, (state, { userId }) => {
    const updatedUsers = state.users.filter(user => user.id !== userId);
    return {
      ...state,
      users: updatedUsers,
      selectedUserId: state.selectedUserId === userId ? null : state.selectedUserId,
      lastUpdated: Date.now()
    };
  }),
  
  // Selection
  on(UserActions.selectUser, (state, { userId }) => ({
    ...state,
    selectedUserId: userId
  })),
  
  on(UserActions.clearSelection, (state) => ({
    ...state,
    selectedUserId: null
  })),
  
  // Filtering
  on(UserActions.setFilter, (state, { filter }) => ({
    ...state,
    filter: { ...state.filter, ...filter }
  })),
  
  // Error handling
  on(UserActions.clearError, (state) => ({
    ...state,
    error: null
  }))
);
```

**3. Complex State Updates with Helper Functions:**

```typescript
// Complex state with nested objects and arrays
interface OrderState {
  orders: Order[];
  orderItems: { [orderId: string]: OrderItem[] };
  customers: Customer[];
  selectedOrderId: string | null;
  pagination: PaginationState;
  filters: OrderFilters;
  loading: LoadingState;
  errors: ErrorState;
}

interface LoadingState {
  orders: boolean;
  orderItems: boolean;
  customers: boolean;
}

interface ErrorState {
  orders: string | null;
  orderItems: string | null;
  customers: string | null;
}

// Helper functions for complex state updates
function updateOrderInState(orders: Order[], updatedOrder: Order): Order[] {
  return orders.map(order => 
    order.id === updatedOrder.id ? updatedOrder : order
  );
}

function addOrderItemsToState(
  orderItems: { [orderId: string]: OrderItem[] },
  orderId: string,
  newItems: OrderItem[]
): { [orderId: string]: OrderItem[] } {
  return {
    ...orderItems,
    [orderId]: [...(orderItems[orderId] || []), ...newItems]
  };
}

function updateOrderItemInState(
  orderItems: { [orderId: string]: OrderItem[] },
  orderId: string,
  updatedItem: OrderItem
): { [orderId: string]: OrderItem[] } {
  const currentItems = orderItems[orderId] || [];
  const updatedItems = currentItems.map(item => 
    item.id === updatedItem.id ? updatedItem : item
  );
  
  return {
    ...orderItems,
    [orderId]: updatedItems
  };
}

function removeOrderFromState(state: OrderState, orderId: string): OrderState {
  const { [orderId]: removedItems, ...remainingOrderItems } = state.orderItems;
  
  return {
    ...state,
    orders: state.orders.filter(order => order.id !== orderId),
    orderItems: remainingOrderItems,
    selectedOrderId: state.selectedOrderId === orderId ? null : state.selectedOrderId
  };
}

// Complex reducer with helper functions
export const orderReducer = createReducer(
  initialOrderState,
  
  // Orders
  on(OrderActions.loadOrdersSuccess, (state, { orders, pagination }) => ({
    ...state,
    orders,
    pagination,
    loading: { ...state.loading, orders: false },
    errors: { ...state.errors, orders: null }
  })),
  
  on(OrderActions.addOrderSuccess, (state, { order }) => ({
    ...state,
    orders: [...state.orders, order],
    loading: { ...state.loading, orders: false }
  })),
  
  on(OrderActions.updateOrderSuccess, (state, { order }) => ({
    ...state,
    orders: updateOrderInState(state.orders, order),
    loading: { ...state.loading, orders: false }
  })),
  
  on(OrderActions.deleteOrderSuccess, (state, { orderId }) => 
    removeOrderFromState(state, orderId)
  ),
  
  // Order Items
  on(OrderActions.loadOrderItemsSuccess, (state, { orderId, items }) => ({
    ...state,
    orderItems: {
      ...state.orderItems,
      [orderId]: items
    },
    loading: { ...state.loading, orderItems: false }
  })),
  
  on(OrderActions.addOrderItemSuccess, (state, { orderId, item }) => ({
    ...state,
    orderItems: addOrderItemsToState(state.orderItems, orderId, [item])
  })),
  
  on(OrderActions.updateOrderItemSuccess, (state, { orderId, item }) => ({
    ...state,
    orderItems: updateOrderItemInState(state.orderItems, orderId, item)
  })),
  
  // Complex filter updates
  on(OrderActions.setFilters, (state, { filters }) => {
    const newFilters = { ...state.filters, ...filters };
    
    // Reset pagination when filters change
    const resetPagination = {
      ...state.pagination,
      currentPage: 1
    };
    
    return {
      ...state,
      filters: newFilters,
      pagination: resetPagination
    };
  })
);
```

**4. Reducer Composition and Feature Reducers:**

```typescript
// app.state.ts - Root state
export interface AppState {
  auth: AuthState;
  users: UserState;
  orders: OrderState;
  products: ProductState;
  ui: UiState;
}

// app.reducer.ts - Combining feature reducers
import { ActionReducerMap } from '@ngrx/store';

export const reducers: ActionReducerMap<AppState> = {
  auth: authReducer,
  users: userReducer,
  orders: orderReducer,
  products: productReducer,
  ui: uiReducer
};

// Feature-specific reducer modules
// users/users.module.ts
@NgModule({
  imports: [
    StoreModule.forFeature('users', userReducer)
  ]
})
export class UsersModule {}

// Lazy-loaded feature reducer
const routes: Routes = [
  {
    path: 'orders',
    loadChildren: () => import('./orders/orders.module').then(m => m.OrdersModule)
  }
];

// orders/orders.module.ts
@NgModule({
  imports: [
    StoreModule.forFeature('orders', orderReducer),
    EffectsModule.forFeature([OrderEffects])
  ]
})
export class OrdersModule {}
```

**5. Advanced Reducer Patterns:**

```typescript
// Generic CRUD reducer factory
function createCrudReducer<T extends { id: string }>(
  entityName: string,
  initialState: CrudState<T>
) {
  return createReducer(
    initialState,
    
    // Load
    on(createAction(`[${entityName}] Load`), (state) => ({
      ...state,
      loading: true,
      error: null
    })),
    
    on(createAction(`[${entityName}] Load Success`, props<{ items: T[] }>()), 
      (state, { items }) => ({
        ...state,
        items,
        loading: false
      })
    ),
    
    // Create
    on(createAction(`[${entityName}] Create Success`, props<{ item: T }>()), 
      (state, { item }) => ({
        ...state,
        items: [...state.items, item]
      })
    ),
    
    // Update
    on(createAction(`[${entityName}] Update Success`, props<{ item: T }>()), 
      (state, { item }) => ({
        ...state,
        items: state.items.map(existing => 
          existing.id === item.id ? item : existing
        )
      })
    ),
    
    // Delete
    on(createAction(`[${entityName}] Delete Success`, props<{ id: string }>()), 
      (state, { id }) => ({
        ...state,
        items: state.items.filter(item => item.id !== id)
      })
    )
  );
}

// Usage
interface CrudState<T> {
  items: T[];
  loading: boolean;
  error: string | null;
}

const initialUserState: CrudState<User> = {
  items: [],
  loading: false,
  error: null
};

export const userCrudReducer = createCrudReducer<User>('User', initialUserState);

// Reducer with middleware-like behavior
function withLoadingState<T>(reducer: ActionReducer<T>): ActionReducer<T> {
  return (state, action) => {
    // Add loading logic to any reducer
    const newState = reducer(state, action);
    
    if (action.type.includes('Load') && !action.type.includes('Success') && !action.type.includes('Failure')) {
      return { ...newState, loading: true } as T;
    }
    
    if (action.type.includes('Success') || action.type.includes('Failure')) {
      return { ...newState, loading: false } as T;
    }
    
    return newState;
  };
}

// Reducer with undo/redo capability
interface UndoableState<T> {
  past: T[];
  present: T;
  future: T[];
}

function undoable<T>(reducer: ActionReducer<T>): ActionReducer<UndoableState<T>> {
  const initialState: UndoableState<T> = {
    past: [],
    present: reducer(undefined, { type: '@ngrx/store/init' }),
    future: []
  };
  
  return (state = initialState, action) => {
    const { past, present, future } = state;
    
    switch (action.type) {
      case 'UNDO':
        if (past.length === 0) return state;
        const previous = past[past.length - 1];
        const newPast = past.slice(0, past.length - 1);
        return {
          past: newPast,
          present: previous,
          future: [present, ...future]
        };
        
      case 'REDO':
        if (future.length === 0) return state;
        const next = future[0];
        const newFuture = future.slice(1);
        return {
          past: [...past, present],
          present: next,
          future: newFuture
        };
        
      default:
        const newPresent = reducer(present, action);
        if (present === newPresent) return state;
        
        return {
          past: [...past, present],
          present: newPresent,
          future: []
        };
    }
  };
}
```

**6. Testing Reducers:**

```typescript
// user.reducer.spec.ts
describe('UserReducer', () => {
  const initialState: UserState = {
    users: [],
    selectedUserId: null,
    loading: false,
    error: null,
    filter: { searchTerm: '', role: null, status: null },
    lastUpdated: 0
  };
  
  it('should return initial state', () => {
    const action = { type: 'Unknown' };
    const state = userReducer(undefined, action);
    
    expect(state).toBe(initialState);
  });
  
  it('should handle loadUsers action', () => {
    const action = UserActions.loadUsers();
    const state = userReducer(initialState, action);
    
    expect(state.loading).toBe(true);
    expect(state.error).toBe(null);
  });
  
  it('should handle loadUsersSuccess action', () => {
    const users = [{ id: '1', name: 'John' }, { id: '2', name: 'Jane' }];
    const action = UserActions.loadUsersSuccess({ users });
    const state = userReducer(initialState, action);
    
    expect(state.users).toEqual(users);
    expect(state.loading).toBe(false);
    expect(state.error).toBe(null);
    expect(state.lastUpdated).toBeGreaterThan(0);
  });
  
  it('should handle addUser action', () => {
    const existingUser = { id: '1', name: 'John' };
    const newUser = { id: '2', name: 'Jane' };
    const stateWithUser = { ...initialState, users: [existingUser] };
    
    const action = UserActions.addUser({ user: newUser });
    const state = userReducer(stateWithUser, action);
    
    expect(state.users).toHaveLength(2);
    expect(state.users).toContain(newUser);
    expect(state.users).toContain(existingUser);
  });
  
  it('should handle updateUser action', () => {
    const originalUser = { id: '1', name: 'John', email: 'john@old.com' };
    const updatedUser = { id: '1', name: 'John', email: 'john@new.com' };
    const stateWithUser = { ...initialState, users: [originalUser] };
    
    const action = UserActions.updateUser({ user: updatedUser });
    const state = userReducer(stateWithUser, action);
    
    expect(state.users).toHaveLength(1);
    expect(state.users[0]).toEqual(updatedUser);
    expect(state.users[0]).not.toEqual(originalUser);
  });
  
  it('should handle deleteUser action and clear selection if deleted', () => {
    const user1 = { id: '1', name: 'John' };
    const user2 = { id: '2', name: 'Jane' };
    const stateWithUsers = {
      ...initialState,
      users: [user1, user2],
      selectedUserId: '1'
    };
    
    const action = UserActions.deleteUser({ userId: '1' });
    const state = userReducer(stateWithUsers, action);
    
    expect(state.users).toHaveLength(1);
    expect(state.users[0]).toEqual(user2);
    expect(state.selectedUserId).toBe(null);
  });
});
```

**Reducer Principles:**

**1. Pure Functions:**
- No side effects
- Same input always produces same output
- Don't mutate input parameters

**2. Immutability:**
- Always return new state objects
- Use spread operator or immutability helpers
- Don't modify existing state

**3. Predictability:**
- State changes are explicit and traceable
- Easy to debug and test
- Time-travel debugging possible

**Best Practices:**

1. **Keep Reducers Simple**: Focus on state transformation logic only
2. **Use Helper Functions**: Extract complex logic into pure functions
3. **Normalize State**: Avoid nested objects when possible
4. **Handle All Cases**: Always return state for unknown actions
5. **Use TypeScript**: Leverage type safety for actions and state
6. **Test Thoroughly**: Reducers are easy to test as pure functions
7. **Compose Reducers**: Break down complex state into smaller reducers

[Back to State Management](#state-management)

### 133. What are selectors in NgRx?

**Answer:**
Selectors in NgRx are pure functions that extract and derive data from the store state. They provide a declarative way to query state, enable memoization for performance optimization, and allow composing complex derived state from simpler pieces.

**Basic Selector Examples:**

```typescript
// Feature selector
export const selectUserState = createFeatureSelector<UserState>('users');

// Simple selectors
export const selectUsers = createSelector(
  selectUserState,
  (state: UserState) => state.users
);

export const selectLoading = createSelector(
  selectUserState,
  (state: UserState) => state.loading
);

// Computed selectors
export const selectUserCount = createSelector(
  selectUsers,
  (users) => users.length
);

export const selectActiveUsers = createSelector(
  selectUsers,
  (users) => users.filter(user => user.status === 'active')
);

// Parameterized selectors
export const selectUserById = (userId: string) => createSelector(
  selectUsers,
  (users) => users.find(user => user.id === userId)
);

// Complex composed selectors
export const selectFilteredUsers = createSelector(
  selectUsers,
  createSelector(selectUserState, state => state.filters),
  (users, filters) => {
    let filtered = users;
    if (filters.role) {
      filtered = filtered.filter(u => u.role === filters.role);
    }
    if (filters.searchTerm) {
      const term = filters.searchTerm.toLowerCase();
      filtered = filtered.filter(u => 
        u.name.toLowerCase().includes(term) ||
        u.email.toLowerCase().includes(term)
      );
    }
    return filtered;
  }
);
```

**Advanced Selector Patterns:**

```typescript
// Cross-feature selectors
export const selectUserWithOrders = createSelector(
  selectUserById('123'),
  createFeatureSelector<OrderState>('orders'),
  (user, orderState) => ({
    user,
    orders: orderState.orders.filter(order => order.userId === user?.id),
    orderCount: orderState.orders.filter(order => order.userId === user?.id).length
  })
);

// Selector factories
export const createUserStatsSelector = (role: UserRole) => createSelector(
  selectUsers,
  (users) => {
    const roleUsers = users.filter(u => u.role === role);
    return {
      count: roleUsers.length,
      averageAge: roleUsers.reduce((sum, u) => sum + u.age, 0) / roleUsers.length,
      newest: roleUsers.sort((a, b) => b.createdAt - a.createdAt)[0]
    };
  }
);
```

[Back to State Management](#state-management)

### 134. How do you handle async operations in NgRx?

**Answer:**
Async operations in NgRx are handled primarily through Effects, which listen for actions and perform side effects like HTTP requests. The typical pattern involves dispatching a trigger action, handling the async operation in an effect, and dispatching success/failure actions based on the result.

**Basic Async Pattern:**

```typescript
// Effects for async operations
@Injectable()
export class UserEffects {
  loadUsers$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.loadUsers),
      switchMap(() =>
        this.http.get<User[]>('/api/users').pipe(
          map(users => UserActions.loadUsersSuccess({ users })),
          catchError(error => of(UserActions.loadUsersFailure({ error: error.message })))
        )
      )
    )
  );
  
  createUser$ = createEffect(() =>
    this.actions$.pipe(
      ofType(UserActions.createUser),
      switchMap(({ user }) =>
        this.http.post<User>('/api/users', user).pipe(
          map(createdUser => UserActions.createUserSuccess({ user: createdUser })),
          catchError(error => of(UserActions.createUserFailure({ error })))
        )
      )
    )
  );
}

// Reducer handles the async states
export const userReducer = createReducer(
  initialState,
  on(UserActions.loadUsers, (state) => ({ ...state, loading: true })),
  on(UserActions.loadUsersSuccess, (state, { users }) => ({ 
    ...state, users, loading: false, error: null 
  })),
  on(UserActions.loadUsersFailure, (state, { error }) => ({ 
    ...state, loading: false, error 
  }))
);
```

[Back to State Management](#state-management)

### 135. What is the Entity pattern in NgRx?

**Answer:**
The Entity pattern in NgRx provides a standardized way to manage collections of entities with CRUD operations. It normalizes data storage using IDs as keys and provides built-in utilities for common operations like adding, updating, and removing entities.

**Entity Adapter Usage:**

```typescript
// User entity state
export interface UserState extends EntityState<User> {
  selectedUserId: string | null;
  loading: boolean;
  error: string | null;
}

// Create entity adapter
export const userAdapter = createEntityAdapter<User>({
  selectId: (user: User) => user.id,
  sortComparer: (a: User, b: User) => a.name.localeCompare(b.name)
});

// Initial state with entity adapter
const initialState: UserState = userAdapter.getInitialState({
  selectedUserId: null,
  loading: false,
  error: null
});

// Reducer using entity adapter methods
export const userReducer = createReducer(
  initialState,
  on(UserActions.loadUsersSuccess, (state, { users }) => 
    userAdapter.setAll(users, { ...state, loading: false })
  ),
  on(UserActions.addUserSuccess, (state, { user }) => 
    userAdapter.addOne(user, state)
  ),
  on(UserActions.updateUserSuccess, (state, { user }) => 
    userAdapter.updateOne({ id: user.id, changes: user }, state)
  ),
  on(UserActions.deleteUserSuccess, (state, { id }) => 
    userAdapter.removeOne(id, state)
  )
);

// Entity selectors
const { selectIds, selectEntities, selectAll, selectTotal } = userAdapter.getSelectors();

export const selectUserIds = createSelector(selectUserState, selectIds);
export const selectUserEntities = createSelector(selectUserState, selectEntities);
export const selectAllUsers = createSelector(selectUserState, selectAll);
export const selectUserTotal = createSelector(selectUserState, selectTotal);
```

[Back to State Management](#state-management)

### 136. How do you implement optimistic updates?

**Answer:**
Optimistic updates immediately apply changes to the UI before the server confirms them, providing better user experience. If the server request fails, the changes are reverted.

**Optimistic Update Pattern:**

```typescript
// Actions for optimistic updates
export const UserActions = createActionGroup({
  source: 'User',
  events: {
    'Update User Optimistic': props<{ user: User }>(),
    'Update User Success': props<{ user: User }>(),
    'Update User Failure': props<{ originalUser: User; error: string }>()
  }
});

// Effect with optimistic update
updateUserOptimistic$ = createEffect(() =>
  this.actions$.pipe(
    ofType(UserActions.updateUserOptimistic),
    switchMap(({ user }) =>
      this.http.put<User>(`/api/users/${user.id}`, user).pipe(
        map(updatedUser => UserActions.updateUserSuccess({ user: updatedUser })),
        catchError(error => {
          // Revert optimistic update on failure
          const originalUser = this.getCurrentUser(user.id);
          return of(UserActions.updateUserFailure({ originalUser, error }));
        })
      )
    )
  )
);

// Reducer handles optimistic updates
export const userReducer = createReducer(
  initialState,
  on(UserActions.updateUserOptimistic, (state, { user }) => 
    userAdapter.updateOne({ id: user.id, changes: user }, state)
  ),
  on(UserActions.updateUserFailure, (state, { originalUser }) => 
    userAdapter.updateOne({ id: originalUser.id, changes: originalUser }, state)
  )
);
```

[Back to State Management](#state-management)

### 137. What are NgRx best practices?

**Answer:**
NgRx best practices help maintain scalable, performant, and maintainable state management code.

**Key Best Practices:**

1. **Use Action Groups**: Group related actions together
```typescript
export const UserActions = createActionGroup({
  source: 'User',
  events: {
    'Load Users': emptyProps(),
    'Load Users Success': props<{ users: User[] }>(),
    'Load Users Failure': props<{ error: string }>()
  }
});
```

2. **Keep State Normalized**: Use Entity pattern for collections
3. **Use Selectors**: Create memoized selectors for derived state
4. **Handle Loading States**: Track loading/error states consistently
5. **Use Effects for Side Effects**: Keep reducers pure
6. **Use TypeScript**: Leverage type safety throughout
7. **Test Everything**: Write comprehensive tests for actions, reducers, effects, and selectors

**Folder Structure:**
```
store/
├── actions/
│   ├── user.actions.ts
│   └── index.ts
├── reducers/
│   ├── user.reducer.ts
│   └── index.ts
├── effects/
│   ├── user.effects.ts
│   └── index.ts
├── selectors/
│   ├── user.selectors.ts
│   └── index.ts
└── state/
    ├── user.state.ts
    └── app.state.ts
```

[Back to State Management](#state-management)

### 138. How do you debug NgRx applications?

**Answer:**
Debugging NgRx applications involves using specialized tools and techniques to track state changes, actions, and effects.

**Debugging Tools:**

1. **Redux DevTools Extension**:
```typescript
// Enable in development
provideStoreDevtools({
  maxAge: 25,
  logOnly: environment.production,
  autoPause: true
})
```

2. **Console Logging in Effects**:
```typescript
loadUsers$ = createEffect(() =>
  this.actions$.pipe(
    ofType(UserActions.loadUsers),
    tap(() => console.log('Loading users...')),
    switchMap(() =>
      this.http.get<User[]>('/api/users').pipe(
        tap(users => console.log('Users loaded:', users)),
        map(users => UserActions.loadUsersSuccess({ users }))
      )
    )
  )
);
```

3. **State Snapshots**:
```typescript
// In component for debugging
constructor(private store: Store) {
  this.store.subscribe(state => {
    console.log('Current state:', state);
  });
}
```

4. **Action Logging**: Use meta-reducers to log all actions

[Back to State Management](#state-management)

### 139. What is ComponentStore and when to use it?

**Answer:**
ComponentStore is a standalone library for local state management that provides reactive state management for components without the complexity of global NgRx Store.

**ComponentStore Example:**

```typescript
@Injectable()
export class TodoStore extends ComponentStore<TodoState> {
  constructor() {
    super({ todos: [], filter: 'all' });
  }
  
  // Selectors
  readonly todos$ = this.select(state => state.todos);
  readonly filter$ = this.select(state => state.filter);
  
  // Updaters
  readonly addTodo = this.updater((state, todo: Todo) => ({
    ...state,
    todos: [...state.todos, todo]
  }));
  
  // Effects
  readonly loadTodos = this.effect((trigger$) =>
    trigger$.pipe(
      switchMap(() =>
        this.http.get<Todo[]>('/api/todos').pipe(
          tapResponse(
            (todos) => this.patchState({ todos }),
            (error) => console.error(error)
          )
        )
      )
    )
  );
}

// Component usage
@Component({
  providers: [TodoStore] // Scoped to component
})
export class TodoComponent {
  todos$ = this.todoStore.todos$;
  
  constructor(private todoStore: TodoStore) {}
}
```

**When to Use ComponentStore:**
- Component-specific state
- Feature-level state management
- When you don't need global state
- Simpler alternative to full NgRx Store

[Back to State Management](#state-management)

### 140. How do you handle state persistence?

**Answer:**
State persistence in NgRx involves saving state to storage (localStorage, sessionStorage, or IndexedDB) and restoring it when the application loads.

**Using ngrx-store-localstorage:**

```typescript
// Install: npm install ngrx-store-localstorage

// Meta-reducer for persistence
import { localStorageSync } from 'ngrx-store-localstorage';

export function localStorageSyncReducer(reducer: ActionReducer<any>): ActionReducer<any> {
  return localStorageSync({
    keys: ['auth', 'user', 'settings'], // Which state slices to persist
    rehydrate: true,
    storage: localStorage
  })(reducer);
}

// Configure in app
export const appConfig: ApplicationConfig = {
  providers: [
    provideStore(reducers, {
      metaReducers: [localStorageSyncReducer]
    })
  ]
};
```

**Custom Persistence Effect:**

```typescript
@Injectable()
export class PersistenceEffects {
  saveState$ = createEffect(() =>
    this.actions$.pipe(
      ofType(
        UserActions.loginSuccess,
        UserActions.updateUserSuccess,
        SettingsActions.updateSettings
      ),
      withLatestFrom(this.store.select(selectPersistableState)),
      tap(([action, state]) => {
        localStorage.setItem('appState', JSON.stringify(state));
      })
    ),
    { dispatch: false }
  );
  
  constructor(
    private actions$: Actions,
    private store: Store
  ) {}
}
```

**Selective Persistence:**
- Only persist necessary state
- Handle sensitive data carefully
- Consider storage size limits
- Implement state versioning for migrations

[Back to State Management](#state-management)

### 141. What testing frameworks are commonly used with Angular?

**Answer:**
Angular testing ecosystem includes various frameworks and tools for different types of testing. The Angular CLI comes with a default testing setup, but you can also integrate other popular testing frameworks.

**Default Angular Testing Stack:**

**1. Jasmine (Test Framework):**
```typescript
// jasmine syntax examples
describe('UserService', () => {
  let service: UserService;
  
  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(UserService);
  });
  
  it('should be created', () => {
    expect(service).toBeTruthy();
  });
  
  it('should return users', () => {
    const users = service.getUsers();
    expect(users).toEqual([]);
    expect(users.length).toBe(0);
  });
  
  it('should add user', () => {
    const user = { id: 1, name: 'John' };
    service.addUser(user);
    expect(service.getUsers()).toContain(user);
  });
});
```

**2. Karma (Test Runner):**
```javascript
// karma.conf.js
module.exports = function (config) {
  config.set({
    basePath: '',
    frameworks: ['jasmine', '@angular-devkit/build-angular'],
    plugins: [
      require('karma-jasmine'),
      require('karma-chrome-headless'),
      require('karma-coverage'),
      require('@angular-devkit/build-angular/plugins/karma')
    ],
    browsers: ['Chrome'],
    singleRun: false,
    restartOnFileChange: true,
    coverageReporter: {
      dir: require('path').join(__dirname, './coverage'),
      subdir: '.',
      reporters: [
        { type: 'html' },
        { type: 'text-summary' },
        { type: 'lcovonly' }
      ]
    }
  });
};
```

**3. Angular Testing Utilities:**
```typescript
// Using Angular TestBed
import { TestBed } from '@angular/core/testing';
import { ComponentFixture } from '@angular/core/testing';

describe('UserComponent', () => {
  let component: UserComponent;
  let fixture: ComponentFixture<UserComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [UserComponent],
      imports: [HttpClientTestingModule, ReactiveFormsModule],
      providers: [
        { provide: UserService, useValue: mockUserService }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(UserComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });
});
```

**Alternative Testing Frameworks:**

**4. Jest (Alternative to Jasmine/Karma):**
```bash
# Installation
npm install --save-dev jest @types/jest jest-preset-angular

# jest.config.js
module.exports = {
  preset: 'jest-preset-angular',
  setupFilesAfterEnv: ['<rootDir>/setup-jest.ts'],
  globalSetup: 'jest-preset-angular/global-setup',
  testMatch: ['**/*.spec.ts'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/main.ts',
    '!src/**/*.module.ts',
    '!src/**/*.interface.ts'
  ],
  coverageReporters: ['html', 'text-summary', 'lcov']
};
```

```typescript
// Jest test example
import { TestBed } from '@angular/core/testing';
import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(UserService);
  });

  test('should create service', () => {
    expect(service).toBeDefined();
  });

  test('should return empty users initially', () => {
    expect(service.getUsers()).toEqual([]);
  });
});
```

**5. Cypress (E2E Testing):**
```bash
# Installation
npm install --save-dev cypress

# cypress.config.ts
import { defineConfig } from 'cypress';

export default defineConfig({
  e2e: {
    baseUrl: 'http://localhost:4200',
    supportFile: 'cypress/support/e2e.ts',
    specPattern: 'cypress/e2e/**/*.cy.ts'
  },
  component: {
    devServer: {
      framework: 'angular',
      bundler: 'webpack',
    },
    specPattern: '**/*.cy.ts'
  }
});
```

```typescript
// cypress/e2e/user-management.cy.ts
describe('User Management', () => {
  beforeEach(() => {
    cy.visit('/users');
  });

  it('should display users list', () => {
    cy.get('[data-cy=users-list]').should('be.visible');
    cy.get('[data-cy=user-item]').should('have.length.greaterThan', 0);
  });

  it('should add new user', () => {
    cy.get('[data-cy=add-user-btn]').click();
    cy.get('[data-cy=user-name-input]').type('John Doe');
    cy.get('[data-cy=user-email-input]').type('john@example.com');
    cy.get('[data-cy=save-user-btn]').click();
    
    cy.get('[data-cy=users-list]').should('contain', 'John Doe');
  });
});
```

**6. Playwright (Modern E2E Testing):**
```bash
# Installation
npm install --save-dev @playwright/test

# playwright.config.ts
import { defineConfig } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  use: {
    baseURL: 'http://localhost:4200',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
    { name: 'webkit', use: { ...devices['Desktop Safari'] } }
  ]
});
```

```typescript
// e2e/user-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('User Management', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/users');
  });

  test('should display users list', async ({ page }) => {
    await expect(page.locator('[data-testid=users-list]')).toBeVisible();
    await expect(page.locator('[data-testid=user-item]')).toHaveCount(3);
  });

  test('should create new user', async ({ page }) => {
    await page.click('[data-testid=add-user-btn]');
    await page.fill('[data-testid=user-name]', 'John Doe');
    await page.fill('[data-testid=user-email]', 'john@example.com');
    await page.click('[data-testid=save-btn]');
    
    await expect(page.locator('[data-testid=users-list]')).toContainText('John Doe');
  });
});
```

**7. Web Test Runner (Modern Alternative):**
```bash
# Installation
npm install --save-dev @web/test-runner @web/test-runner-playwright

# web-test-runner.config.js
export default {
  files: 'src/**/*.test.ts',
  nodeResolve: true,
  browsers: [
    playwrightLauncher({ product: 'chromium' }),
    playwrightLauncher({ product: 'firefox' }),
    playwrightLauncher({ product: 'webkit' })
  ],
  coverage: true,
  coverageConfig: {
    threshold: {
      statements: 90,
      branches: 90,
      functions: 90,
      lines: 90
    }
  }
};
```

**Testing Framework Comparison:**

| Framework | Type | Pros | Cons |
|-----------|------|------|------|
| **Jasmine/Karma** | Unit | Default, well-integrated | Slower, more complex setup |
| **Jest** | Unit | Fast, great mocking, snapshots | Requires configuration |
| **Cypress** | E2E | Great DX, real browser | Limited to Chromium family |
| **Playwright** | E2E | Multi-browser, fast | Newer, smaller ecosystem |
| **Web Test Runner** | Unit/Integration | Modern, fast | Less Angular-specific tooling |

**Specialized Testing Libraries:**

**8. Angular Testing Library:**
```bash
npm install --save-dev @testing-library/angular

# Provides utilities for better component testing
import { render, screen, fireEvent } from '@testing-library/angular';

test('should display user name', async () => {
  await render(UserComponent, {
    componentProperties: { user: { name: 'John' } }
  });
  
  expect(screen.getByText('John')).toBeInTheDocument();
});
```

**9. MSW (Mock Service Worker):**
```bash
npm install --save-dev msw

# For mocking HTTP requests
import { rest } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
  rest.get('/api/users', (req, res, ctx) => {
    return res(ctx.json([{ id: 1, name: 'John' }]));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

**Testing Strategy by Framework:**

**Unit Tests:**
- **Jasmine/Karma**: Default choice, well-documented
- **Jest**: Better performance, snapshot testing
- **Angular Testing Library**: Better component testing practices

**Integration Tests:**
- **Angular TestBed**: Component integration testing
- **Jest + TestBed**: Faster integration tests

**E2E Tests:**
- **Cypress**: Great for Angular applications
- **Playwright**: Multi-browser support, faster execution
- **Protractor**: Deprecated, avoid for new projects

**Best Practices:**
1. Use Jest for faster unit tests
2. Keep Karma for complex Angular-specific testing
3. Use Cypress or Playwright for E2E tests
4. Consider Angular Testing Library for better component tests
5. Use MSW for HTTP mocking across all test types
6. Maintain good test coverage with appropriate tools

[Back to Testing](#testing)

### 142. How do you write unit tests for Angular components?

**Answer:**
Unit testing Angular components involves testing component logic, template rendering, user interactions, and integration with dependencies in isolation.

**Basic Component Test Setup:**

```typescript
// user.component.ts
@Component({
  selector: 'app-user',
  template: `
    <div class="user-card">
      <h2>{{user.name}}</h2>
      <p>{{user.email}}</p>
      <button (click)="editUser()" [disabled]="loading">Edit</button>
      <button (click)="deleteUser()" class="delete-btn">Delete</button>
      <div *ngIf="loading" class="spinner">Loading...</div>
      <div *ngIf="error" class="error">{{error}}</div>
    </div>
  `
})
export class UserComponent {
  @Input() user!: User;
  @Output() userEdit = new EventEmitter<User>();
  @Output() userDelete = new EventEmitter<string>();
  
  loading = false;
  error: string | null = null;
  
  editUser(): void {
    this.userEdit.emit(this.user);
  }
  
  deleteUser(): void {
    this.userDelete.emit(this.user.id);
  }
}

// user.component.spec.ts
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { UserComponent } from './user.component';

describe('UserComponent', () => {
  let component: UserComponent;
  let fixture: ComponentFixture<UserComponent>;
  const mockUser: User = {
    id: '1',
    name: 'John Doe',
    email: 'john@example.com'
  };

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [UserComponent]
    }).compileComponents();

    fixture = TestBed.createComponent(UserComponent);
    component = fixture.componentInstance;
    component.user = mockUser;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should display user information', () => {
    const compiled = fixture.nativeElement;
    expect(compiled.querySelector('h2').textContent).toContain('John Doe');
    expect(compiled.querySelector('p').textContent).toContain('john@example.com');
  });

  it('should emit userEdit when edit button is clicked', () => {
    spyOn(component.userEdit, 'emit');
    
    const editButton = fixture.debugElement.query(By.css('button'));
    editButton.nativeElement.click();
    
    expect(component.userEdit.emit).toHaveBeenCalledWith(mockUser);
  });

  it('should emit userDelete when delete button is clicked', () => {
    spyOn(component.userDelete, 'emit');
    
    const deleteButton = fixture.debugElement.query(By.css('.delete-btn'));
    deleteButton.nativeElement.click();
    
    expect(component.userDelete.emit).toHaveBeenCalledWith('1');
  });

  it('should disable edit button when loading', () => {
    component.loading = true;
    fixture.detectChanges();
    
    const editButton = fixture.debugElement.query(By.css('button'));
    expect(editButton.nativeElement.disabled).toBe(true);
  });

  it('should show loading spinner when loading', () => {
    component.loading = true;
    fixture.detectChanges();
    
    const spinner = fixture.debugElement.query(By.css('.spinner'));
    expect(spinner).toBeTruthy();
    expect(spinner.nativeElement.textContent).toContain('Loading...');
  });

  it('should display error message when error exists', () => {
    component.error = 'Something went wrong';
    fixture.detectChanges();
    
    const errorDiv = fixture.debugElement.query(By.css('.error'));
    expect(errorDiv).toBeTruthy();
    expect(errorDiv.nativeElement.textContent).toContain('Something went wrong');
  });
});
```

**Testing Components with Services:**

```typescript
// user-list.component.ts
@Component({
  selector: 'app-user-list',
  template: `
    <div>
      <button (click)="loadUsers()">Load Users</button>
      <div *ngFor="let user of users$ | async">{{user.name}}</div>
      <div *ngIf="loading$ | async">Loading...</div>
    </div>
  `
})
export class UserListComponent implements OnInit {
  users$ = this.userService.users$;
  loading$ = this.userService.loading$;
  
  constructor(private userService: UserService) {}
  
  ngOnInit(): void {
    this.loadUsers();
  }
  
  loadUsers(): void {
    this.userService.loadUsers();
  }
}

// user-list.component.spec.ts
import { of } from 'rxjs';

describe('UserListComponent', () => {
  let component: UserListComponent;
  let fixture: ComponentFixture<UserListComponent>;
  let mockUserService: jasmine.SpyObj<UserService>;

  beforeEach(async () => {
    const spy = jasmine.createSpyObj('UserService', ['loadUsers'], {
      users$: of([{ id: '1', name: 'John' }, { id: '2', name: 'Jane' }]),
      loading$: of(false)
    });

    await TestBed.configureTestingModule({
      declarations: [UserListComponent],
      providers: [
        { provide: UserService, useValue: spy }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(UserListComponent);
    component = fixture.componentInstance;
    mockUserService = TestBed.inject(UserService) as jasmine.SpyObj<UserService>;
  });

  it('should load users on init', () => {
    fixture.detectChanges();
    expect(mockUserService.loadUsers).toHaveBeenCalled();
  });

  it('should display users from service', () => {
    fixture.detectChanges();
    const compiled = fixture.nativeElement;
    expect(compiled.textContent).toContain('John');
    expect(compiled.textContent).toContain('Jane');
  });

  it('should show loading state', () => {
    mockUserService.loading$ = of(true);
    fixture.detectChanges();
    
    expect(fixture.nativeElement.textContent).toContain('Loading...');
  });
});
```

[Back to Testing](#testing)

### 143. What is the difference between shallow and deep component testing?

**Answer:**
Shallow testing tests a component in isolation without rendering child components, while deep testing renders the full component tree including all child components.

**Shallow Testing (NO_ERRORS_SCHEMA):**

```typescript
// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <div class="parent">
      <h1>Parent Component</h1>
      <app-child [data]="childData" (childEvent)="onChildEvent($event)"></app-child>
      <app-another-child></app-another-child>
    </div>
  `
})
export class ParentComponent {
  childData = { message: 'Hello Child' };
  
  onChildEvent(event: any): void {
    console.log('Child event:', event);
  }
}

// Shallow test - ignores child components
describe('ParentComponent - Shallow', () => {
  let component: ParentComponent;
  let fixture: ComponentFixture<ParentComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [ParentComponent],
      schemas: [NO_ERRORS_SCHEMA] // Ignores unknown elements
    }).compileComponents();

    fixture = TestBed.createComponent(ParentComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should render parent content only', () => {
    const compiled = fixture.nativeElement;
    expect(compiled.querySelector('h1').textContent).toContain('Parent Component');
    expect(compiled.querySelector('app-child')).toBeTruthy(); // Element exists
    expect(compiled.querySelector('.child-content')).toBeFalsy(); // Child content not rendered
  });

  it('should have correct child data binding', () => {
    expect(component.childData.message).toBe('Hello Child');
  });
});
```

**Deep Testing (Full Component Tree):**

```typescript
// child.component.ts
@Component({
  selector: 'app-child',
  template: `
    <div class="child-content">
      <p>{{data.message}}</p>
      <button (click)="emitEvent()">Click Me</button>
    </div>
  `
})
export class ChildComponent {
  @Input() data!: { message: string };
  @Output() childEvent = new EventEmitter<string>();
  
  emitEvent(): void {
    this.childEvent.emit('Child clicked');
  }
}

// Deep test - includes all child components
describe('ParentComponent - Deep', () => {
  let component: ParentComponent;
  let fixture: ComponentFixture<ParentComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [
        ParentComponent,
        ChildComponent,
        AnotherChildComponent // All child components included
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(ParentComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should render full component tree', () => {
    const compiled = fixture.nativeElement;
    expect(compiled.querySelector('h1').textContent).toContain('Parent Component');
    expect(compiled.querySelector('.child-content')).toBeTruthy(); // Child content rendered
    expect(compiled.querySelector('.child-content p').textContent).toContain('Hello Child');
  });

  it('should handle child component events', () => {
    spyOn(component, 'onChildEvent');
    
    const childButton = fixture.debugElement.query(By.css('.child-content button'));
    childButton.nativeElement.click();
    
    expect(component.onChildEvent).toHaveBeenCalledWith('Child clicked');
  });

  it('should pass data to child components correctly', () => {
    const childComponent = fixture.debugElement.query(By.directive(ChildComponent));
    expect(childComponent.componentInstance.data).toEqual({ message: 'Hello Child' });
  });
});
```

**Comparison and When to Use:**

| Aspect | Shallow Testing | Deep Testing |
|--------|-----------------|-------------|
| **Speed** | Faster | Slower |
| **Isolation** | High | Low |
| **Setup Complexity** | Simple | Complex |
| **Child Dependencies** | Ignored | Required |
| **Integration Coverage** | None | Full |
| **Debugging** | Easier | Harder |

**Use Shallow Testing when:**
- Testing component logic in isolation
- Child components are complex or have many dependencies
- You want fast, focused unit tests
- Testing component inputs/outputs without child behavior

**Use Deep Testing when:**
- Testing component integration
- Child components are simple
- Testing user workflows that span multiple components
- End-to-end component behavior is important

[Back to Testing](#testing)

### 144. How do you mock dependencies in Angular tests?

**Answer:**
Mocking dependencies in Angular tests involves replacing real dependencies with test doubles to isolate the component under test and control the test environment.

**Service Mocking with Jasmine Spies:**

```typescript
// user.service.ts
@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}
  
  getUsers(): Observable<User[]> {
    return this.http.get<User[]>('/api/users');
  }
  
  deleteUser(id: string): Observable<void> {
    return this.http.delete<void>(`/api/users/${id}`);
  }
}

// Component test with mocked service
describe('UserListComponent', () => {
  let component: UserListComponent;
  let fixture: ComponentFixture<UserListComponent>;
  let mockUserService: jasmine.SpyObj<UserService>;

  beforeEach(async () => {
    // Create spy object with methods
    const spy = jasmine.createSpyObj('UserService', ['getUsers', 'deleteUser']);
    
    await TestBed.configureTestingModule({
      declarations: [UserListComponent],
      providers: [
        { provide: UserService, useValue: spy }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(UserListComponent);
    component = fixture.componentInstance;
    mockUserService = TestBed.inject(UserService) as jasmine.SpyObj<UserService>;
  });

  it('should load users', () => {
    const mockUsers = [{ id: '1', name: 'John' }];
    mockUserService.getUsers.and.returnValue(of(mockUsers));
    
    component.loadUsers();
    
    expect(mockUserService.getUsers).toHaveBeenCalled();
  });

  it('should handle delete user', () => {
    mockUserService.deleteUser.and.returnValue(of(void 0));
    
    component.deleteUser('1');
    
    expect(mockUserService.deleteUser).toHaveBeenCalledWith('1');
  });
});
```

**HTTP Client Mocking:**

```typescript
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';

describe('UserService', () => {
  let service: UserService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [UserService]
    });
    
    service = TestBed.inject(UserService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify(); // Verify no outstanding requests
  });

  it('should fetch users', () => {
    const mockUsers = [{ id: '1', name: 'John' }, { id: '2', name: 'Jane' }];

    service.getUsers().subscribe(users => {
      expect(users).toEqual(mockUsers);
    });

    const req = httpMock.expectOne('/api/users');
    expect(req.request.method).toBe('GET');
    req.flush(mockUsers);
  });

  it('should handle HTTP error', () => {
    service.getUsers().subscribe({
      next: () => fail('Should have failed'),
      error: (error) => {
        expect(error.status).toBe(404);
      }
    });

    const req = httpMock.expectOne('/api/users');
    req.flush('Not found', { status: 404, statusText: 'Not Found' });
  });
});
```

**Complex Service Mocking:**

```typescript
// Mock with properties and methods
class MockAuthService {
  isAuthenticated = true;
  currentUser = { id: '1', name: 'John' };
  
  login = jasmine.createSpy('login').and.returnValue(of({ success: true }));
  logout = jasmine.createSpy('logout').and.returnValue(of(void 0));
  getCurrentUser = jasmine.createSpy('getCurrentUser').and.returnValue(of(this.currentUser));
}

// Or using partial mock
const mockAuthService: Partial<AuthService> = {
  isAuthenticated$: of(true),
  currentUser$: of({ id: '1', name: 'John' }),
  login: jasmine.createSpy('login').and.returnValue(of({ success: true }))
};

beforeEach(async () => {
  await TestBed.configureTestingModule({
    providers: [
      { provide: AuthService, useValue: mockAuthService }
    ]
  }).compileComponents();
});
```

[Back to Testing](#testing)

### 145. How do you test HTTP requests in Angular?

**Answer:**
Testing HTTP requests in Angular uses `HttpClientTestingModule` and `HttpTestingController` to mock HTTP calls and verify request/response behavior.

**Basic HTTP Testing Setup:**

```typescript
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';

@Injectable({ providedIn: 'root' })
export class ApiService {
  constructor(private http: HttpClient) {}
  
  getUsers(): Observable<User[]> {
    return this.http.get<User[]>('/api/users');
  }
  
  createUser(user: CreateUserRequest): Observable<User> {
    return this.http.post<User>('/api/users', user);
  }
  
  updateUser(id: string, user: UpdateUserRequest): Observable<User> {
    return this.http.put<User>(`/api/users/${id}`, user);
  }
  
  deleteUser(id: string): Observable<void> {
    return this.http.delete<void>(`/api/users/${id}`);
  }
}

describe('ApiService', () => {
  let service: ApiService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [ApiService]
    });
    
    service = TestBed.inject(ApiService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify(); // Ensures no outstanding HTTP requests
  });

  it('should fetch users with GET request', () => {
    const mockUsers: User[] = [
      { id: '1', name: 'John', email: 'john@test.com' },
      { id: '2', name: 'Jane', email: 'jane@test.com' }
    ];

    service.getUsers().subscribe(users => {
      expect(users.length).toBe(2);
      expect(users).toEqual(mockUsers);
    });

    const req = httpMock.expectOne('/api/users');
    expect(req.request.method).toBe('GET');
    expect(req.request.headers.get('Content-Type')).toBeNull();
    
    req.flush(mockUsers);
  });

  it('should create user with POST request', () => {
    const newUser: CreateUserRequest = { name: 'Bob', email: 'bob@test.com' };
    const createdUser: User = { id: '3', ...newUser };

    service.createUser(newUser).subscribe(user => {
      expect(user).toEqual(createdUser);
    });

    const req = httpMock.expectOne('/api/users');
    expect(req.request.method).toBe('POST');
    expect(req.request.body).toEqual(newUser);
    expect(req.request.headers.get('Content-Type')).toBe('application/json');
    
    req.flush(createdUser);
  });

  it('should handle HTTP errors', () => {
    const errorMessage = 'User not found';

    service.getUsers().subscribe({
      next: () => fail('Should have failed with 404 error'),
      error: (error) => {
        expect(error.status).toBe(404);
        expect(error.error).toBe(errorMessage);
      }
    });

    const req = httpMock.expectOne('/api/users');
    req.flush(errorMessage, { status: 404, statusText: 'Not Found' });
  });
});
```

**Testing HTTP Interceptors:**

```typescript
@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  constructor(private authService: AuthService) {}
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = this.authService.getToken();
    
    if (token) {
      const authReq = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${token}`)
      });
      return next.handle(authReq);
    }
    
    return next.handle(req);
  }
}

describe('AuthInterceptor', () => {
  let service: ApiService;
  let httpMock: HttpTestingController;
  let mockAuthService: jasmine.SpyObj<AuthService>;

  beforeEach(() => {
    const spy = jasmine.createSpyObj('AuthService', ['getToken']);
    
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [
        ApiService,
        { provide: AuthService, useValue: spy },
        { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
      ]
    });
    
    service = TestBed.inject(ApiService);
    httpMock = TestBed.inject(HttpTestingController);
    mockAuthService = TestBed.inject(AuthService) as jasmine.SpyObj<AuthService>;
  });

  it('should add auth header when token exists', () => {
    mockAuthService.getToken.and.returnValue('test-token');
    
    service.getUsers().subscribe();
    
    const req = httpMock.expectOne('/api/users');
    expect(req.request.headers.get('Authorization')).toBe('Bearer test-token');
    
    req.flush([]);
  });

  it('should not add auth header when no token', () => {
    mockAuthService.getToken.and.returnValue(null);
    
    service.getUsers().subscribe();
    
    const req = httpMock.expectOne('/api/users');
    expect(req.request.headers.get('Authorization')).toBeNull();
    
    req.flush([]);
  });
});
```

[Back to Testing](#testing)

### 146. What are end-to-end tests and how do you implement them?

**Answer:**
End-to-end (E2E) tests verify complete user workflows by testing the entire application from the user's perspective, including UI interactions, API calls, and data flow.

**Cypress E2E Implementation:**

```typescript
// cypress/e2e/user-management.cy.ts
describe('User Management E2E', () => {
  beforeEach(() => {
    cy.visit('/users');
    cy.intercept('GET', '/api/users', { fixture: 'users.json' }).as('getUsers');
  });

  it('should complete full user workflow', () => {
    // Wait for users to load
    cy.wait('@getUsers');
    cy.get('[data-cy=users-list]').should('be.visible');
    
    // Add new user
    cy.get('[data-cy=add-user-btn]').click();
    cy.get('[data-cy=user-form]').should('be.visible');
    cy.get('[data-cy=name-input]').type('John Doe');
    cy.get('[data-cy=email-input]').type('john@example.com');
    cy.get('[data-cy=save-btn]').click();
    
    // Verify user was added
    cy.get('[data-cy=success-message]').should('contain', 'User created successfully');
    cy.get('[data-cy=users-list]').should('contain', 'John Doe');
    
    // Edit user
    cy.get('[data-cy=user-item]').contains('John Doe').parent().find('[data-cy=edit-btn]').click();
    cy.get('[data-cy=name-input]').clear().type('John Smith');
    cy.get('[data-cy=save-btn]').click();
    
    // Verify user was updated
    cy.get('[data-cy=users-list]').should('contain', 'John Smith');
    cy.get('[data-cy=users-list]').should('not.contain', 'John Doe');
  });

  it('should handle form validation', () => {
    cy.get('[data-cy=add-user-btn]').click();
    cy.get('[data-cy=save-btn]').click();
    
    cy.get('[data-cy=name-error]').should('contain', 'Name is required');
    cy.get('[data-cy=email-error]').should('contain', 'Email is required');
  });
});

// cypress/fixtures/users.json
[
  { "id": "1", "name": "Jane Doe", "email": "jane@example.com" },
  { "id": "2", "name": "Bob Smith", "email": "bob@example.com" }
]
```

**Playwright E2E Implementation:**

```typescript
// e2e/user-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('User Management', () => {
  test.beforeEach(async ({ page }) => {
    await page.route('/api/users', async route => {
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify([
          { id: '1', name: 'Jane Doe', email: 'jane@example.com' },
          { id: '2', name: 'Bob Smith', email: 'bob@example.com' }
        ])
      });
    });
    
    await page.goto('/users');
  });

  test('should manage users end-to-end', async ({ page }) => {
    // Verify initial state
    await expect(page.locator('[data-testid=users-list]')).toBeVisible();
    await expect(page.locator('[data-testid=user-item]')).toHaveCount(2);
    
    // Add new user
    await page.click('[data-testid=add-user-btn]');
    await page.fill('[data-testid=name-input]', 'John Doe');
    await page.fill('[data-testid=email-input]', 'john@example.com');
    
    // Mock the POST request
    await page.route('/api/users', async route => {
      if (route.request().method() === 'POST') {
        await route.fulfill({
          status: 201,
          contentType: 'application/json',
          body: JSON.stringify({ id: '3', name: 'John Doe', email: 'john@example.com' })
        });
      }
    });
    
    await page.click('[data-testid=save-btn]');
    
    // Verify success
    await expect(page.locator('[data-testid=success-message]')).toContainText('User created');
  });

  test('should handle network errors gracefully', async ({ page }) => {
    await page.route('/api/users', route => route.abort('failed'));
    await page.reload();
    
    await expect(page.locator('[data-testid=error-message]')).toContainText('Failed to load users');
  });
});
```

[Back to Testing](#testing)

### 147. Testing standalone components with `TestBed`

**Answer:**
Testing standalone components requires importing the component directly in TestBed configuration instead of declaring it in a module.

**Standalone Component Testing:**

```typescript
// user-card.component.ts
@Component({
  selector: 'app-user-card',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  template: `
    <div class="user-card">
      <h3>{{user.name}}</h3>
      <p>{{user.email}}</p>
      <button (click)="editUser()" [disabled]="loading">Edit</button>
    </div>
  `
})
export class UserCardComponent {
  @Input() user!: User;
  @Output() userEdit = new EventEmitter<User>();
  loading = false;
  
  editUser(): void {
    this.userEdit.emit(this.user);
  }
}

// user-card.component.spec.ts
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { UserCardComponent } from './user-card.component';

describe('UserCardComponent (Standalone)', () => {
  let component: UserCardComponent;
  let fixture: ComponentFixture<UserCardComponent>;
  const mockUser: User = { id: '1', name: 'John', email: 'john@test.com' };

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [UserCardComponent] // Import standalone component
    }).compileComponents();

    fixture = TestBed.createComponent(UserCardComponent);
    component = fixture.componentInstance;
    component.user = mockUser;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should display user information', () => {
    const compiled = fixture.nativeElement;
    expect(compiled.querySelector('h3').textContent).toContain('John');
    expect(compiled.querySelector('p').textContent).toContain('john@test.com');
  });

  it('should emit userEdit event when edit button clicked', () => {
    spyOn(component.userEdit, 'emit');
    
    const button = fixture.nativeElement.querySelector('button');
    button.click();
    
    expect(component.userEdit.emit).toHaveBeenCalledWith(mockUser);
  });
});
```

**Testing Standalone Components with Dependencies:**

```typescript
// user-list.component.ts (standalone)
@Component({
  selector: 'app-user-list',
  standalone: true,
  imports: [CommonModule, UserCardComponent],
  providers: [UserService],
  template: `
    <div>
      <app-user-card 
        *ngFor="let user of users$ | async" 
        [user]="user"
        (userEdit)="onEditUser($event)">
      </app-user-card>
    </div>
  `
})
export class UserListComponent {
  users$ = this.userService.users$;
  
  constructor(private userService: UserService) {}
  
  onEditUser(user: User): void {
    console.log('Editing user:', user);
  }
}

// user-list.component.spec.ts
describe('UserListComponent (Standalone)', () => {
  let component: UserListComponent;
  let fixture: ComponentFixture<UserListComponent>;
  let mockUserService: jasmine.SpyObj<UserService>;

  beforeEach(async () => {
    const spy = jasmine.createSpyObj('UserService', ['loadUsers'], {
      users$: of([{ id: '1', name: 'John', email: 'john@test.com' }])
    });

    await TestBed.configureTestingModule({
      imports: [UserListComponent], // Import the standalone component
      providers: [
        { provide: UserService, useValue: spy }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(UserListComponent);
    component = fixture.componentInstance;
    mockUserService = TestBed.inject(UserService) as jasmine.SpyObj<UserService>;
    fixture.detectChanges();
  });

  it('should display user cards', () => {
    const userCards = fixture.debugElement.queryAll(By.directive(UserCardComponent));
    expect(userCards.length).toBe(1);
    expect(userCards[0].componentInstance.user.name).toBe('John');
  });
});
```

[Back to Testing](#testing)

### 148. How to use `fakeAsync` and Http testing?

**Answer:**
`fakeAsync` creates a fake asynchronous zone where you can control time and execute async operations synchronously using `tick()` and `flush()`.

**Basic fakeAsync Usage:**

```typescript
import { fakeAsync, tick, flush } from '@angular/core/testing';

describe('Async Operations', () => {
  it('should handle setTimeout with fakeAsync', fakeAsync(() => {
    let flag = false;
    
    setTimeout(() => {
      flag = true;
    }, 1000);
    
    expect(flag).toBe(false);
    
    tick(1000); // Advance time by 1000ms
    
    expect(flag).toBe(true);
  }));

  it('should handle multiple timers', fakeAsync(() => {
    let counter = 0;
    
    setTimeout(() => counter++, 100);
    setTimeout(() => counter++, 200);
    setTimeout(() => counter++, 300);
    
    tick(150);
    expect(counter).toBe(1);
    
    tick(100);
    expect(counter).toBe(2);
    
    tick(50);
    expect(counter).toBe(3);
  }));

  it('should flush all pending timers', fakeAsync(() => {
    let counter = 0;
    
    setTimeout(() => counter++, 1000);
    setTimeout(() => counter++, 2000);
    
    flush(); // Execute all pending async operations
    
    expect(counter).toBe(2);
  }));
});
```

**Testing HTTP with fakeAsync:**

```typescript
@Injectable({ providedIn: 'root' })
export class DataService {
  constructor(private http: HttpClient) {}
  
  getData(): Observable<any> {
    return this.http.get('/api/data').pipe(
      delay(1000) // Simulate network delay
    );
  }
  
  getDataWithRetry(): Observable<any> {
    return this.http.get('/api/data').pipe(
      retry(3),
      catchError(error => throwError(() => error))
    );
  }
}

describe('DataService with fakeAsync', () => {
  let service: DataService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [DataService]
    });
    
    service = TestBed.inject(DataService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  it('should handle delayed HTTP requests', fakeAsync(() => {
    let result: any;
    const mockData = { id: 1, name: 'Test' };
    
    service.getData().subscribe(data => {
      result = data;
    });
    
    const req = httpMock.expectOne('/api/data');
    req.flush(mockData);
    
    // Without tick(), the delay wouldn't complete
    expect(result).toBeUndefined();
    
    tick(1000); // Complete the delay
    
    expect(result).toEqual(mockData);
  }));

  it('should test retry mechanism', fakeAsync(() => {
    let error: any;
    
    service.getDataWithRetry().subscribe({
      next: () => {},
      error: (err) => error = err
    });
    
    // First request fails
    const req1 = httpMock.expectOne('/api/data');
    req1.flush('Error', { status: 500, statusText: 'Server Error' });
    
    // Second request fails
    const req2 = httpMock.expectOne('/api/data');
    req2.flush('Error', { status: 500, statusText: 'Server Error' });
    
    // Third request fails
    const req3 = httpMock.expectOne('/api/data');
    req3.flush('Error', { status: 500, statusText: 'Server Error' });
    
    // Fourth request fails (final attempt)
    const req4 = httpMock.expectOne('/api/data');
    req4.flush('Error', { status: 500, statusText: 'Server Error' });
    
    expect(error.status).toBe(500);
  }));
});
```

[Back to Testing](#testing)

### 149. What are test doubles (mocks, stubs, spies)?

**Answer:**
Test doubles are objects that replace real dependencies in tests. They include mocks, stubs, spies, fakes, and dummies, each serving different testing purposes.

**Types of Test Doubles:**

```typescript
// 1. STUB - Returns predetermined values
class StubUserService {
  getUsers(): Observable<User[]> {
    return of([
      { id: '1', name: 'John', email: 'john@test.com' },
      { id: '2', name: 'Jane', email: 'jane@test.com' }
    ]);
  }
  
  getUser(id: string): Observable<User> {
    return of({ id, name: 'Test User', email: 'test@test.com' });
  }
}

// 2. SPY - Records how it was called
describe('Component with Spy', () => {
  let userService: jasmine.SpyObj<UserService>;
  
  beforeEach(() => {
    const spy = jasmine.createSpyObj('UserService', ['getUsers', 'deleteUser']);
    spy.getUsers.and.returnValue(of([]));
    spy.deleteUser.and.returnValue(of(void 0));
    
    userService = spy;
  });
  
  it('should call getUsersand track calls', () => {
    component.loadUsers();
    
    expect(userService.getUsers).toHaveBeenCalled();
    expect(userService.getUsers).toHaveBeenCalledTimes(1);
  });
});

// 3. MOCK - Verifies behavior and state
class MockUserService {
  private users: User[] = [];
  private callLog: string[] = [];
  
  getUsers(): Observable<User[]> {
    this.callLog.push('getUsers called');
    return of([...this.users]);
  }
  
  addUser(user: User): Observable<User> {
    this.callLog.push(`addUser called with ${user.name}`);
    this.users.push(user);
    return of(user);
  }
  
  verify(): void {
    expect(this.callLog).toContain('getUsers called');
  }
  
  getCallLog(): string[] {
    return [...this.callLog];
  }
}

// 4. FAKE - Working implementation with shortcuts
class FakeUserService {
  private users: User[] = [
    { id: '1', name: 'John', email: 'john@fake.com' }
  ];
  
  getUsers(): Observable<User[]> {
    return of([...this.users]);
  }
  
  addUser(user: User): Observable<User> {
    const newUser = { ...user, id: Date.now().toString() };
    this.users.push(newUser);
    return of(newUser);
  }
  
  deleteUser(id: string): Observable<void> {
    this.users = this.users.filter(u => u.id !== id);
    return of(void 0);
  }
}

// 5. DUMMY - Passed but never used
class DummyUserService {
  getUsers(): Observable<User[]> {
    throw new Error('Should not be called');
  }
}
```

**Advanced Jasmine Spy Usage:**

```typescript
describe('Advanced Spy Examples', () => {
  let userService: jasmine.SpyObj<UserService>;
  
  beforeEach(() => {
    userService = jasmine.createSpyObj('UserService', {
      getUsers: of([]),
      getUser: of({ id: '1', name: 'Test' }),
      deleteUser: of(void 0)
    });
  });
  
  it('should spy on method calls with different return values', () => {
    // Different return values for different calls
    userService.getUser.and.returnValues(
      of({ id: '1', name: 'First' }),
      of({ id: '2', name: 'Second' })
    );
    
    let result1, result2;
    userService.getUser('1').subscribe(u => result1 = u);
    userService.getUser('2').subscribe(u => result2 = u);
    
    expect(result1.name).toBe('First');
    expect(result2.name).toBe('Second');
  });
  
  it('should spy with conditional return values', () => {
    userService.getUser.and.callFake((id: string) => {
      if (id === '1') {
        return of({ id: '1', name: 'John', email: 'john@test.com' });
      }
      return throwError(() => new Error('User not found'));
    });
    
    let result, error;
    userService.getUser('1').subscribe(u => result = u);
    userService.getUser('999').subscribe({ error: e => error = e });
    
    expect(result.name).toBe('John');
    expect(error.message).toBe('User not found');
  });
  
  it('should verify call arguments', () => {
    component.deleteUser('123');
    
    expect(userService.deleteUser).toHaveBeenCalledWith('123');
    expect(userService.deleteUser).toHaveBeenCalledOnceWith('123');
  });
});
```

[Back to Testing](#testing)

### 150. How do you test reactive forms?

**Answer:**
Testing reactive forms involves testing form validation, user interactions, form state changes, and form submission logic.

**Basic Reactive Form Testing:**

```typescript
// user-form.component.ts
@Component({
  selector: 'app-user-form',
  template: `
    <form [formGroup]="userForm" (ngSubmit)="onSubmit()">
      <input formControlName="name" placeholder="Name" />
      <div *ngIf="userForm.get('name')?.invalid && userForm.get('name')?.touched" class="error">
        Name is required
      </div>
      
      <input formControlName="email" placeholder="Email" />
      <div *ngIf="userForm.get('email')?.invalid && userForm.get('email')?.touched" class="error">
        Valid email is required
      </div>
      
      <button type="submit" [disabled]="userForm.invalid">Submit</button>
    </form>
  `
})
export class UserFormComponent {
  userForm = this.fb.group({
    name: ['', [Validators.required, Validators.minLength(2)]],
    email: ['', [Validators.required, Validators.email]]
  });
  
  constructor(private fb: FormBuilder) {}
  
  onSubmit(): void {
    if (this.userForm.valid) {
      console.log('Form submitted:', this.userForm.value);
    }
  }
}

// user-form.component.spec.ts
describe('UserFormComponent', () => {
  let component: UserFormComponent;
  let fixture: ComponentFixture<UserFormComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [UserFormComponent],
      imports: [ReactiveFormsModule]
    }).compileComponents();

    fixture = TestBed.createComponent(UserFormComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create form with initial values', () => {
    expect(component.userForm.get('name')?.value).toBe('');
    expect(component.userForm.get('email')?.value).toBe('');
    expect(component.userForm.invalid).toBe(true);
  });

  it('should validate required fields', () => {
    const nameControl = component.userForm.get('name');
    const emailControl = component.userForm.get('email');
    
    expect(nameControl?.hasError('required')).toBe(true);
    expect(emailControl?.hasError('required')).toBe(true);
  });

  it('should validate email format', () => {
    const emailControl = component.userForm.get('email');
    
    emailControl?.setValue('invalid-email');
    expect(emailControl?.hasError('email')).toBe(true);
    
    emailControl?.setValue('valid@email.com');
    expect(emailControl?.hasError('email')).toBe(false);
  });

  it('should show error messages when fields are touched and invalid', () => {
    const nameControl = component.userForm.get('name');
    nameControl?.markAsTouched();
    fixture.detectChanges();
    
    const errorElement = fixture.debugElement.query(By.css('.error'));
    expect(errorElement.nativeElement.textContent).toContain('Name is required');
  });

  it('should enable submit button when form is valid', () => {
    component.userForm.patchValue({
      name: 'John Doe',
      email: 'john@example.com'
    });
    fixture.detectChanges();
    
    const submitButton = fixture.debugElement.query(By.css('button[type="submit"]'));
    expect(submitButton.nativeElement.disabled).toBe(false);
  });

  it('should call onSubmit when form is submitted', () => {
    spyOn(component, 'onSubmit');
    
    component.userForm.patchValue({
      name: 'John Doe',
      email: 'john@example.com'
    });
    
    const form = fixture.debugElement.query(By.css('form'));
    form.nativeElement.dispatchEvent(new Event('submit'));
    
    expect(component.onSubmit).toHaveBeenCalled();
  });
});
```

[Back to Testing](#testing)

### 151. How do you test async operations?

**Answer:**
Testing async operations in Angular requires handling Promises, Observables, and timing-dependent code using various Angular testing utilities.

**Testing with async/await:**

```typescript
describe('Async Operations', () => {
  let service: DataService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [DataService]
    });
    service = TestBed.inject(DataService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  it('should handle async operations with async/await', async () => {
    const mockData = { id: 1, name: 'Test' };
    
    const dataPromise = service.getData().toPromise();
    
    const req = httpMock.expectOne('/api/data');
    req.flush(mockData);
    
    const result = await dataPromise;
    expect(result).toEqual(mockData);
  });

  it('should handle async component initialization', async () => {
    const fixture = TestBed.createComponent(AsyncComponent);
    
    // Wait for async ngOnInit to complete
    await fixture.whenStable();
    fixture.detectChanges();
    
    expect(fixture.componentInstance.data).toBeDefined();
  });
});
```

**Testing with fakeAsync:**

```typescript
import { fakeAsync, tick, flush } from '@angular/core/testing';

describe('Async with fakeAsync', () => {
  it('should handle delayed operations', fakeAsync(() => {
    let result = false;
    
    setTimeout(() => {
      result = true;
    }, 1000);
    
    expect(result).toBe(false);
    tick(1000);
    expect(result).toBe(true);
  }));

  it('should handle Observable delays', fakeAsync(() => {
    let result: any;
    
    of('test').pipe(
      delay(500)
    ).subscribe(value => result = value);
    
    expect(result).toBeUndefined();
    tick(500);
    expect(result).toBe('test');
  }));
});
```

[Back to Testing](#testing)

### 152. What is code coverage and how to measure it?

**Answer:**
Code coverage measures how much of your code is executed during testing. Angular provides built-in coverage reporting through Karma and supports various coverage tools.

**Measuring Coverage with Angular CLI:**

```bash
# Run tests with coverage
ng test --code-coverage

# Or with watch disabled
ng test --code-coverage --watch=false

# Generate coverage in specific formats
ng test --code-coverage --reporters=text-summary,html,lcov
```

**Coverage Configuration:**

```javascript
// karma.conf.js
module.exports = function (config) {
  config.set({
    coverageReporter: {
      dir: require('path').join(__dirname, './coverage'),
      subdir: '.',
      reporters: [
        { type: 'html' },
        { type: 'text-summary' },
        { type: 'lcov' },
        { type: 'cobertura' }
      ],
      check: {
        global: {
          statements: 80,
          branches: 80,
          functions: 80,
          lines: 80
        }
      }
    }
  });
};
```

**Coverage Types:**
- **Statement Coverage**: Percentage of statements executed
- **Branch Coverage**: Percentage of branches (if/else) taken
- **Function Coverage**: Percentage of functions called
- **Line Coverage**: Percentage of lines executed

[Back to Testing](#testing)

### 153. How do you test custom pipes?

**Answer:**
Testing custom pipes involves testing the transform method with various inputs and edge cases.

**Simple Pipe Testing:**

```typescript
// capitalize.pipe.ts
@Pipe({ name: 'capitalize' })
export class CapitalizePipe implements PipeTransform {
  transform(value: string): string {
    if (!value) return value;
    return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
  }
}

// capitalize.pipe.spec.ts
describe('CapitalizePipe', () => {
  let pipe: CapitalizePipe;

  beforeEach(() => {
    pipe = new CapitalizePipe();
  });

  it('should create', () => {
    expect(pipe).toBeTruthy();
  });

  it('should capitalize first letter', () => {
    expect(pipe.transform('hello')).toBe('Hello');
    expect(pipe.transform('WORLD')).toBe('World');
    expect(pipe.transform('tEST')).toBe('Test');
  });

  it('should handle edge cases', () => {
    expect(pipe.transform('')).toBe('');
    expect(pipe.transform(null as any)).toBe(null);
    expect(pipe.transform(undefined as any)).toBe(undefined);
  });
});
```

**Complex Pipe with Dependencies:**

```typescript
// currency-format.pipe.ts
@Pipe({ name: 'currencyFormat' })
export class CurrencyFormatPipe implements PipeTransform {
  constructor(private currencyService: CurrencyService) {}
  
  transform(value: number, currencyCode: string = 'USD'): string {
    const rate = this.currencyService.getExchangeRate(currencyCode);
    const convertedValue = value * rate;
    return `${convertedValue.toFixed(2)} ${currencyCode}`;
  }
}

// currency-format.pipe.spec.ts
describe('CurrencyFormatPipe', () => {
  let pipe: CurrencyFormatPipe;
  let mockCurrencyService: jasmine.SpyObj<CurrencyService>;

  beforeEach(() => {
    const spy = jasmine.createSpyObj('CurrencyService', ['getExchangeRate']);
    
    TestBed.configureTestingModule({
      providers: [
        CurrencyFormatPipe,
        { provide: CurrencyService, useValue: spy }
      ]
    });
    
    pipe = TestBed.inject(CurrencyFormatPipe);
    mockCurrencyService = TestBed.inject(CurrencyService) as jasmine.SpyObj<CurrencyService>;
  });

  it('should format currency with exchange rate', () => {
    mockCurrencyService.getExchangeRate.and.returnValue(1.2);
    
    const result = pipe.transform(100, 'EUR');
    
    expect(result).toBe('120.00 EUR');
    expect(mockCurrencyService.getExchangeRate).toHaveBeenCalledWith('EUR');
  });
});
```

[Back to Testing](#testing)

### 154. How do you test services with dependencies?

**Answer:**
Testing services with dependencies requires mocking or providing test doubles for the dependencies to isolate the service under test.

**Service with HTTP Dependency:**

```typescript
// user.service.ts
@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(
    private http: HttpClient,
    private logger: LoggerService,
    private config: ConfigService
  ) {}
  
  getUsers(): Observable<User[]> {
    this.logger.log('Fetching users');
    const url = `${this.config.apiUrl}/users`;
    
    return this.http.get<User[]>(url).pipe(
      tap(users => this.logger.log(`Fetched ${users.length} users`)),
      catchError(error => {
        this.logger.error('Failed to fetch users', error);
        return throwError(() => error);
      })
    );
  }
}

// user.service.spec.ts
describe('UserService', () => {
  let service: UserService;
  let httpMock: HttpTestingController;
  let mockLogger: jasmine.SpyObj<LoggerService>;
  let mockConfig: jasmine.SpyObj<ConfigService>;

  beforeEach(() => {
    const loggerSpy = jasmine.createSpyObj('LoggerService', ['log', 'error']);
    const configSpy = jasmine.createSpyObj('ConfigService', [], {
      apiUrl: 'https://api.test.com'
    });

    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [
        UserService,
        { provide: LoggerService, useValue: loggerSpy },
        { provide: ConfigService, useValue: configSpy }
      ]
    });

    service = TestBed.inject(UserService);
    httpMock = TestBed.inject(HttpTestingController);
    mockLogger = TestBed.inject(LoggerService) as jasmine.SpyObj<LoggerService>;
    mockConfig = TestBed.inject(ConfigService) as jasmine.SpyObj<ConfigService>;
  });

  it('should fetch users and log activity', () => {
    const mockUsers = [{ id: '1', name: 'John' }];

    service.getUsers().subscribe(users => {
      expect(users).toEqual(mockUsers);
    });

    const req = httpMock.expectOne('https://api.test.com/users');
    req.flush(mockUsers);

    expect(mockLogger.log).toHaveBeenCalledWith('Fetching users');
    expect(mockLogger.log).toHaveBeenCalledWith('Fetched 1 users');
  });

  it('should handle errors and log them', () => {
    service.getUsers().subscribe({
      next: () => fail('Should have failed'),
      error: (error) => {
        expect(error.status).toBe(500);
      }
    });

    const req = httpMock.expectOne('https://api.test.com/users');
    req.flush('Server Error', { status: 500, statusText: 'Internal Server Error' });

    expect(mockLogger.error).toHaveBeenCalledWith('Failed to fetch users', jasmine.any(Object));
  });
});
```

[Back to Testing](#testing)

### 155. What are integration tests vs unit tests?

**Answer:**
Unit tests test individual components in isolation, while integration tests verify that multiple components work together correctly.

**Unit Test Example:**

```typescript
// Unit test - tests component in isolation
describe('UserComponent (Unit)', () => {
  let component: UserComponent;
  
  beforeEach(() => {
    component = new UserComponent();
  });
  
  it('should calculate user age correctly', () => {
    component.user = { birthDate: new Date('1990-01-01') };
    expect(component.calculateAge()).toBeGreaterThan(30);
  });
});
```

**Integration Test Example:**

```typescript
// Integration test - tests component with real dependencies
describe('UserListComponent (Integration)', () => {
  let component: UserListComponent;
  let fixture: ComponentFixture<UserListComponent>;
  let userService: UserService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [UserListComponent, UserComponent],
      imports: [HttpClientTestingModule],
      providers: [UserService] // Real service, not mocked
    }).compileComponents();

    fixture = TestBed.createComponent(UserListComponent);
    component = fixture.componentInstance;
    userService = TestBed.inject(UserService);
  });

  it('should display users from service', () => {
    // Test real integration between component and service
    spyOn(userService, 'getUsers').and.returnValue(of([
      { id: '1', name: 'John' },
      { id: '2', name: 'Jane' }
    ]));

    fixture.detectChanges();

    const userElements = fixture.debugElement.queryAll(By.directive(UserComponent));
    expect(userElements.length).toBe(2);
  });
});
```

**Comparison:**

| Aspect | Unit Tests | Integration Tests |
|--------|------------|------------------|
| **Scope** | Single unit | Multiple units |
| **Speed** | Fast | Slower |
| **Isolation** | High | Low |
| **Dependencies** | Mocked | Real or minimal mocks |
| **Purpose** | Verify logic | Verify interactions |
| **Debugging** | Easy | More complex |
| **Maintenance** | Low | Higher |

[Back to Testing](#testing)

### 156. What are Angular Elements and when would you use them?

[Back to Advanced Topics](#advanced-topics)

### 157. How do you implement internationalization (i18n) in Angular?

[Back to Advanced Topics](#advanced-topics)

### 158. What is Angular Universal and server-side rendering?

[Back to Advanced Topics](#advanced-topics)

### 159. How do you implement Progressive Web App features in Angular?

[Back to Advanced Topics](#advanced-topics)

### 160. What are Angular schematics and how do you create them?

[Back to Advanced Topics](#advanced-topics)

### 161. How do you create custom Angular libraries?

[Back to Advanced Topics](#advanced-topics)

### 162. What is Ivy renderer and what are its benefits?

[Back to Advanced Topics](#advanced-topics)

### 163. What is `CUSTOM_ELEMENTS_SCHEMA`?

[Back to Advanced Topics](#advanced-topics)

### 164. How do you use `$localize` and ICU expressions?

[Back to Advanced Topics](#advanced-topics)

### 165. What are runtime vs build-time i18n approaches?

[Back to Advanced Topics](#advanced-topics)

### 166. How do you implement SSR and hydration?

[Back to Advanced Topics](#advanced-topics)

### 167. What is `TransferState` in Angular Universal?

[Back to Advanced Topics](#advanced-topics)

### 168. How do you implement PWA with Angular Service Worker?

**Answer:**
**Progressive Web Apps (PWAs)** in Angular use service workers to provide offline functionality, caching, and app-like experience. Angular provides built-in PWA support through the Angular Service Worker.

**1. Basic PWA Setup:**

**Install PWA Support:**
```bash
ng add @angular/pwa
```

**This command automatically:**
- Installs `@angular/service-worker` package
- Adds service worker configuration
- Updates `angular.json` with PWA settings
- Creates `manifest.webmanifest`
- Updates `index.html` with PWA meta tags

**2. Service Worker Configuration:**

**ngsw-config.json (Generated):**
```json
{
  "$schema": "./node_modules/@angular/service-worker/config/schema.json",
  "index": "/index.html",
  "assetGroups": [
    {
      "name": "app",
      "installMode": "prefetch",
      "resources": {
        "files": [
          "/favicon.ico",
          "/index.html",
          "/manifest.webmanifest",
          "/*.css",
          "/*.js"
        ]
      }
    },
    {
      "name": "assets",
      "installMode": "lazy",
      "updateMode": "prefetch",
      "resources": {
        "files": [
          "/assets/**",
          "/*.(svg|cur|jpg|jpeg|png|apng|webp|avif|gif|otf|ttf|woff|woff2)"
        ]
      }
    }
  ],
  "dataGroups": [
    {
      "name": "api-freshness",
      "urls": [
        "/api/**"
      ],
      "cacheConfig": {
        "strategy": "freshness",
        "maxSize": 100,
        "maxAge": "3d",
        "timeout": "10s"
      }
    }
  ]
}
```

**3. Service Worker Registration:**

**For NgModule-based applications (app.module.ts):**
```typescript
import { ServiceWorkerModule } from '@angular/service-worker';
import { environment } from '../environments/environment';

@NgModule({
  imports: [
    ServiceWorkerModule.register('ngsw-worker.js', {
      enabled: environment.production,
      registrationStrategy: 'registerWhenStable:30000'
    })
  ]
})
export class AppModule { }
```

**For Standalone applications (app.config.ts) - Angular 17+:**
```typescript
import { ApplicationConfig, isDevMode } from '@angular/core';
import { provideServiceWorker } from '@angular/service-worker';

export const appConfig: ApplicationConfig = {
  providers: [
    // other providers
    provideServiceWorker('ngsw-worker.js', {
      enabled: !isDevMode(),
      registrationStrategy: 'registerWhenStable:30000'
    })
  ]
};
```

**4. PWA Manifest Configuration:**

**manifest.webmanifest:**
```json
{
  "name": "My Angular PWA",
  "short_name": "MyApp",
  "theme_color": "#1976d2",
  "background_color": "#fafafa",
  "display": "standalone",
  "scope": "./",
  "start_url": "./",
  "icons": [
    {
      "src": "assets/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "assets/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "assets/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ]
}
```

**5. Service Worker Service:**

**sw.service.ts:**
```typescript
import { Injectable } from '@angular/core';
import { SwUpdate, VersionReadyEvent } from '@angular/service-worker';
import { filter, map } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class SwService {
  constructor(private swUpdate: SwUpdate) {
    this.checkForUpdates();
  }

  // Check for updates
  checkForUpdates() {
    if (this.swUpdate.isEnabled) {
      this.swUpdate.versionUpdates
        .pipe(
          filter((evt): evt is VersionReadyEvent => evt.type === 'VERSION_READY'),
          map(() => {
            if (confirm('New version available. Load it?')) {
              window.location.reload();
            }
          })
        )
        .subscribe();
    }
  }

  // Check if update is available
  async checkForUpdate(): Promise<boolean> {
    if (this.swUpdate.isEnabled) {
      try {
        const updateFound = await this.swUpdate.checkForUpdate();
        return updateFound;
      } catch (err) {
        console.error('Error checking for update', err);
        return false;
      }
    }
    return false;
  }

  // Activate update
  async activateUpdate(): Promise<boolean> {
    if (this.swUpdate.isEnabled) {
      try {
        await this.swUpdate.activateUpdate();
        window.location.reload();
        return true;
      } catch (err) {
        console.error('Error activating update', err);
        return false;
      }
    }
    return false;
  }
}
```

**6. PWA Component Integration:**

**app.component.ts:**
```typescript
import { Component, OnInit } from '@angular/core';
import { SwService } from './sw.service';
import { SwPush } from '@angular/service-worker';

@Component({
  selector: 'app-root',
  template: `
    <div class="pwa-controls">
      <button (click)="checkUpdate()">Check for Updates</button>
      <button (click)="subscribeToNotifications()">Enable Notifications</button>
      <div *ngIf="updateAvailable" class="update-banner">
        New version available! 
        <button (click)="activateUpdate()">Update Now</button>
      </div>
    </div>
    <router-outlet></router-outlet>
  `
})
export class AppComponent implements OnInit {
  updateAvailable = false;

  constructor(
    private swService: SwService,
    private swPush: SwPush
  ) {}

  ngOnInit() {
    this.checkForUpdates();
  }

  async checkUpdate() {
    this.updateAvailable = await this.swService.checkForUpdate();
  }

  async activateUpdate() {
    await this.swService.activateUpdate();
  }

  async subscribeToNotifications() {
    try {
      const subscription = await this.swPush.requestSubscription({
        serverPublicKey: 'YOUR_VAPID_PUBLIC_KEY'
      });
      
      // Send subscription to server
      console.log('Push subscription:', subscription);
    } catch (err) {
      console.error('Failed to subscribe to notifications', err);
    }
  }
}
```

**7. Advanced PWA Features:**

**Custom Service Worker (sw-custom.js):**
```typescript
// Custom service worker for advanced caching
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('my-app-v1').then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/assets/main.js',
        '/assets/main.css'
      ]);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});

// Background sync for offline actions
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(doBackgroundSync());
  }
});

async function doBackgroundSync() {
  // Perform background sync operations
  const db = await openDB();
  const offlineActions = await db.getAll('offlineActions');
  
  for (const action of offlineActions) {
    try {
      await performAction(action);
      await db.delete('offlineActions', action.id);
    } catch (error) {
      console.error('Background sync failed:', error);
    }
  }
}
```

**8. PWA Testing:**

**Testing Service Worker:**
```typescript
describe('PWA Service Worker', () => {
  let service: SwService;
  let swUpdate: jasmine.SpyObj<SwUpdate>;

  beforeEach(() => {
    const swUpdateSpy = jasmine.createSpyObj('SwUpdate', [
      'isEnabled', 'checkForUpdate', 'activateUpdate'
    ]);
    
    TestBed.configureTestingModule({
      providers: [
        SwService,
        { provide: SwUpdate, useValue: swUpdateSpy }
      ]
    });
    
    service = TestBed.inject(SwService);
    swUpdate = TestBed.inject(SwUpdate) as jasmine.SpyObj<SwUpdate>;
  });

  it('should check for updates when enabled', async () => {
    swUpdate.isEnabled = true;
    swUpdate.checkForUpdate.and.returnValue(Promise.resolve(true));
    
    const result = await service.checkForUpdate();
    
    expect(result).toBe(true);
    expect(swUpdate.checkForUpdate).toHaveBeenCalled();
  });
});
```

**9. PWA Best Practices:**

**Performance Optimization:**
```typescript
// Modern Angular PWA optimization strategies

// 1. Resource Loading Strategies
const resourceStrategies = {
  critical: [
    '/index.html',
    '/main.js',
    '/polyfills.js',
    '/styles.css'
  ],
  lazy: [
    '/assets/icons/**',
    '/assets/images/**',
    '/assets/fonts/**'
  ],
  prefetch: [
    '/assets/data/**',
    '/api/config/**'
  ]
};

// 2. Modern Caching with Workbox (Angular 17+)
import { Workbox } from 'workbox-window';

if ('serviceWorker' in navigator) {
  const wb = new Workbox('/ngsw-worker.js');
  
  wb.addEventListener('waiting', (event) => {
    // Show update available notification
    showUpdateNotification();
  });
  
  wb.register();
}

// 3. Advanced Service Worker Features
class ModernPWAService {
  constructor(private swUpdate: SwUpdate) {}
  
  // Background sync for offline actions
  async scheduleBackgroundSync(data: any) {
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      const registration = await navigator.serviceWorker.ready;
      await registration.sync.register('background-sync');
      
      // Store data for sync
      const db = await this.openDB();
      await db.add('sync-queue', data);
    }
  }
  
  // Web Share API integration
  async shareContent(shareData: ShareData) {
    if (navigator.share) {
      try {
        await navigator.share(shareData);
      } catch (error) {
        // Fallback to clipboard or custom share UI
        await this.fallbackShare(shareData);
      }
    }
  }
}
```

**10. PWA Deployment:**

**Build and Deploy:**
```bash
# Build for production
ng build --configuration production

# Service worker will be generated in dist folder
# Deploy with HTTPS (required for service workers)
# Test PWA features in production
```

**Key PWA Features:**
- ✅ **Offline functionality** with service worker caching
- ✅ **App-like experience** with manifest configuration
- ✅ **Push notifications** support
- ✅ **Background sync** for offline actions
- ✅ **Automatic updates** with version management
- ✅ **Install prompt** for home screen addition

**Angular PWA provides a robust foundation for building progressive web applications with minimal configuration!**

### 169. What are caching strategies for PWAs?

**Answer:**
**Caching strategies** in PWAs determine how resources are stored and retrieved, balancing performance, offline functionality, and data freshness. Angular Service Worker provides several built-in strategies and allows custom implementations.

**1. Built-in Angular Service Worker Strategies:**

**Cache-First Strategy (Performance Strategy):**
```typescript
// ngsw-config.json - For static assets
{
  "assetGroups": [
    {
      "name": "app",
      "installMode": "prefetch", // Cache immediately on install
      "updateMode": "prefetch",  // Update cache in background
      "resources": {
        "files": [
          "/index.html",
          "/manifest.webmanifest",
          "/*.css",
          "/*.js"
        ]
      }
    },
    {
      "name": "assets",
      "installMode": "lazy", // Cache on first request
      "updateMode": "prefetch",
      "resources": {
        "files": [
          "/assets/**",
          "/*.(svg|cur|jpg|jpeg|png|apng|webp|avif|gif|otf|ttf|woff|woff2)"
        ]
      }
    }
  ]
}
```

**Network-First Strategy (Freshness Strategy):**
```typescript
// ngsw-config.json - For dynamic content
{
  "dataGroups": [
    {
      "name": "api-freshness",
      "urls": ["/api/news/**", "/api/updates/**"],
      "cacheConfig": {
        "strategy": "freshness", // Network first, fallback to cache
        "maxSize": 100,
        "maxAge": "1h", // Cache expires after 1 hour
        "timeout": "5s" // Network timeout
      }
    },
    {
      "name": "api-performance", 
      "urls": ["/api/static/**", "/api/config/**"],
      "cacheConfig": {
        "strategy": "performance", // Cache first, update in background
        "maxSize": 50,
        "maxAge": "7d"
      }
    }
  ]
}
```

**2. Custom Caching Strategies:**

**Cache-First for Static Assets:**
```typescript
// Custom service worker
self.addEventListener('fetch', (event) => {
  if (event.request.destination === 'image' || 
      event.request.destination === 'style' ||
      event.request.destination === 'script') {
    
    event.respondWith(
      caches.match(event.request)
        .then((response) => {
          // Return cached version if available
          if (response) {
            return response;
          }
          
          // Fetch from network and cache
          return fetch(event.request).then((response) => {
            if (response.status === 200) {
              const responseClone = response.clone();
              caches.open('static-assets-v1').then((cache) => {
                cache.put(event.request, responseClone);
              });
            }
            return response;
          });
        })
    );
  }
});
```

**Network-First for API Calls:**
```typescript
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          // Cache successful responses
          if (response.status === 200) {
            const responseClone = response.clone();
            caches.open('api-cache-v1').then((cache) => {
              cache.put(event.request, responseClone);
            });
          }
          return response;
        })
        .catch(() => {
          // Fallback to cache on network failure
          return caches.match(event.request);
        })
    );
  }
});
```

**3. Advanced Caching Patterns:**

**Stale-While-Revalidate:**
```typescript
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      caches.open('api-cache-v1').then((cache) => {
        return cache.match(event.request).then((cachedResponse) => {
          // Return cached response immediately
          const fetchPromise = fetch(event.request).then((networkResponse) => {
            // Update cache with fresh data
            cache.put(event.request, networkResponse.clone());
            return networkResponse;
          });
          
          return cachedResponse || fetchPromise;
        });
      })
    );
  }
});
```

**Cache-Only Strategy:**
```typescript
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/static/')) {
    event.respondWith(
      caches.match(event.request).then((response) => {
        if (response) {
          return response;
        }
        // Return offline fallback
        return caches.match('/offline.html');
      })
    );
  }
});
```

**4. Cache Versioning and Cleanup:**

**Versioned Caching:**
```typescript
const CACHE_VERSION = 'v1.2.0';
const CACHE_NAMES = [
  `app-cache-${CACHE_VERSION}`,
  `api-cache-${CACHE_VERSION}`,
  `assets-cache-${CACHE_VERSION}`
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    Promise.all(
      CACHE_NAMES.map(cacheName => 
        caches.open(cacheName)
      )
    )
  );
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          // Delete old caches
          if (!CACHE_NAMES.includes(cacheName)) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

**5. Dynamic Caching Strategies:**

**User Preference-Based Caching:**
```typescript
// Cache based on user preferences
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/products')) {
    event.respondWith(
      caches.open('user-preferences').then((cache) => {
        return cache.match('cache-strategy').then((strategy) => {
          const cacheStrategy = strategy ? strategy.text() : 'network-first';
          
          switch (cacheStrategy) {
            case 'cache-first':
              return cacheFirst(event.request);
            case 'network-first':
              return networkFirst(event.request);
            case 'stale-while-revalidate':
              return staleWhileRevalidate(event.request);
            default:
              return networkFirst(event.request);
          }
        });
      })
    );
  }
});

async function cacheFirst(request) {
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  
  try {
    const networkResponse = await fetch(request);
    const cache = await caches.open('api-cache-v1');
    cache.put(request, networkResponse.clone());
    return networkResponse;
  } catch (error) {
    return new Response('Offline content not available');
  }
}
```

**6. Modern Cache Management Strategies:**

**Workbox Integration (Angular 17+):**
```typescript
// Install Workbox for advanced caching
// npm install workbox-webpack-plugin workbox-window

// workbox-config.js
module.exports = {
  globDirectory: 'dist/',
  globPatterns: [
    '**/*.{html,js,css,png,jpg,svg,woff2}'
  ],
  swDest: 'dist/sw.js',
  runtimeCaching: [
    {
      urlPattern: /^https:\/\/api\.example\.com\/.*$/,
      handler: 'NetworkFirst',
      options: {
        cacheName: 'api-cache',
        networkTimeoutSeconds: 3,
        cacheableResponse: {
          statuses: [0, 200],
        },
      },
    },
    {
      urlPattern: /\.(?:png|jpg|jpeg|svg)$/,
      handler: 'CacheFirst',
      options: {
        cacheName: 'images',
        expiration: {
          maxEntries: 60,
          maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
        },
      },
    },
  ],
};
```

**Advanced Cache Strategies with IndexedDB:**
```typescript
// Modern cache management with IndexedDB
class ModernCacheManager {
  private dbName = 'PWA-Cache-DB';
  private dbVersion = 1;
  
  async openDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        // Create object stores
        if (!db.objectStoreNames.contains('cache-entries')) {
          const store = db.createObjectStore('cache-entries', { keyPath: 'url' });
          store.createIndex('timestamp', 'timestamp');
          store.createIndex('priority', 'priority');
        }
      };
    });
  }
  
  async cacheWithPriority(url: string, response: Response, priority: 'high' | 'medium' | 'low') {
    const db = await this.openDB();
    const transaction = db.transaction(['cache-entries'], 'readwrite');
    const store = transaction.objectStore('cache-entries');
    
    const entry = {
      url,
      response: await response.clone().arrayBuffer(),
      headers: Object.fromEntries(response.headers.entries()),
      timestamp: Date.now(),
      priority,
      size: response.headers.get('content-length') || '0'
    };
    
    await store.put(entry);
    await this.cleanupCache();
  }
  
  async cleanupCache() {
    const db = await this.openDB();
    const transaction = db.transaction(['cache-entries'], 'readwrite');
    const store = transaction.objectStore('cache-entries');
    const index = store.index('timestamp');
    
    // Remove old low-priority entries
    const oldEntries = await index.getAll(IDBKeyRange.upperBound(Date.now() - 7 * 24 * 60 * 60 * 1000));
    
    for (const entry of oldEntries) {
      if (entry.priority === 'low') {
        await store.delete(entry.url);
      }
    }
  }
}
```

**LRU (Least Recently Used) Cache with Modern Features:**
```typescript
class ModernLRUCache<T> {
  private cache = new Map<string, { value: T; timestamp: number; accessCount: number }>();
  private maxSize: number;
  private maxAge: number;
  
  constructor(maxSize = 100, maxAgeMs = 24 * 60 * 60 * 1000) {
    this.maxSize = maxSize;
    this.maxAge = maxAgeMs;
  }
  
  get(key: string): T | null {
    const entry = this.cache.get(key);
    
    if (!entry) return null;
    
    // Check if expired
    if (Date.now() - entry.timestamp > this.maxAge) {
      this.cache.delete(key);
      return null;
    }
    
    // Update access info
    entry.timestamp = Date.now();
    entry.accessCount++;
    
    // Move to end (most recent)
    this.cache.delete(key);
    this.cache.set(key, entry);
    
    return entry.value;
  }
  
  set(key: string, value: T): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // Remove least recently used
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
      accessCount: 1
    });
  }
  
  // Get cache statistics
  getStats() {
    const entries = Array.from(this.cache.values());
    return {
      size: this.cache.size,
      totalAccesses: entries.reduce((sum, entry) => sum + entry.accessCount, 0),
      avgAge: entries.reduce((sum, entry) => sum + (Date.now() - entry.timestamp), 0) / entries.length
    };
  }
}

// Usage in service worker
const modernCache = new ModernLRUCache<Response>(50, 24 * 60 * 60 * 1000);
```

**7. Cache Performance Optimization:**

**Preloading Critical Resources:**
```typescript
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('critical-resources').then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/assets/main.js',
        '/assets/main.css',
        '/assets/fonts/roboto.woff2'
      ]);
    })
  );
});
```

**Lazy Loading Non-Critical Resources:**
```typescript
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/assets/icons/')) {
    event.respondWith(
      caches.open('lazy-assets').then((cache) => {
        return cache.match(event.request).then((response) => {
          if (response) {
            return response;
          }
          
          // Lazy load and cache
          return fetch(event.request).then((networkResponse) => {
            cache.put(event.request, networkResponse.clone());
            return networkResponse;
          });
        });
      })
    );
  }
});
```

**8. Cache Testing and Debugging:**

**Cache Inspection:**
```typescript
// Debug cache contents
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'GET_CACHE_INFO') {
    caches.keys().then((cacheNames) => {
      const cacheInfo = {};
      
      Promise.all(
        cacheNames.map(cacheName => 
          caches.open(cacheName).then(cache => 
            cache.keys().then(requests => 
              cacheInfo[cacheName] = requests.length
            )
          )
        )
      ).then(() => {
        event.ports[0].postMessage(cacheInfo);
      });
    });
  }
});
```

**9. Cache Strategy Selection Guide:**

**Choose Strategy Based on Resource Type:**
```typescript
const CACHE_STRATEGIES = {
  // Static assets - rarely change
  'css': 'cache-first',
  'js': 'cache-first', 
  'images': 'cache-first',
  'fonts': 'cache-first',
  
  // API data - needs freshness
  'api': 'network-first',
  'data': 'stale-while-revalidate',
  
  // HTML - balance of speed and freshness
  'html': 'stale-while-revalidate',
  
  // User-generated content - always fresh
  'user-content': 'network-only'
};

function getCacheStrategy(request) {
  const url = request.url;
  
  if (url.includes('/api/')) return 'api';
  if (url.includes('.css')) return 'css';
  if (url.includes('.js')) return 'js';
  if (url.includes('.png') || url.includes('.jpg')) return 'images';
  
  return 'html';
}
```

**10. Cache Best Practices:**

**Performance Optimization:**
- ✅ **Cache critical resources** immediately on install
- ✅ **Use appropriate strategies** for different resource types
- ✅ **Implement cache versioning** for easy updates
- ✅ **Set reasonable cache sizes** to prevent memory issues
- ✅ **Clean up old caches** during activation

**User Experience:**
- ✅ **Provide offline fallbacks** for critical content
- ✅ **Show loading states** during cache operations
- ✅ **Implement progressive enhancement** for offline features
- ✅ **Cache user preferences** for personalized experience

**Modern PWA Caching Best Practices (2024):**

**1. Strategy Selection Matrix:**
```typescript
const modernCachingMatrix = {
  // High-frequency, static content
  staticAssets: {
    strategy: 'CacheFirst',
    maxAge: '30d',
    resources: ['*.css', '*.js', '*.woff2'],
    preload: true
  },
  
  // Dynamic, user-specific content  
  userContent: {
    strategy: 'NetworkFirst',
    timeout: '2s',
    maxAge: '1h',
    fallbackToCache: true
  },
  
  // Semi-static configuration
  appConfig: {
    strategy: 'StaleWhileRevalidate', 
    maxAge: '24h',
    backgroundUpdate: true
  }
};
```

**2. Performance Optimization:**
- **Preload critical resources** during SW installation
- **Use Workbox** for advanced caching with minimal setup
- **Implement cache warming** for frequently accessed content
- **Monitor cache hit ratios** and adjust strategies
- **Use IndexedDB** for complex data caching needs

**3. Modern Browser APIs:**
- **Background Sync** for offline actions
- **Web Share API** for content sharing  
- **Persistent Storage** for guaranteed cache space
- **Web Streams** for efficient large file handling

**Cache strategies are crucial for PWA performance and offline functionality. Modern approaches combine multiple strategies with browser APIs for optimal user experience!**

### 170. How do you handle service worker updates?

[Back to Advanced Topics](#advanced-topics)

### 171. How do you structure a large Angular application?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 172. What are Angular best practices for component communication?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 173. How do you implement error handling in Angular applications?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 174. What is the difference between smart and dumb components?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 175. How do you implement authentication and authorization?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 176. What are Angular style guides and why are they important?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 177. How do you handle environment-specific configurations?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 178. What are micro-frontends and how to implement them?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 179. How do you implement feature modules?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 180. What is the single responsibility principle in Angular?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 181. How do you handle shared modules?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 182. What are barrel exports?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 183. How do you implement lazy loading strategies?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 184. What are the SOLID principles in Angular?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 185. How do you handle code organization and folder structure?

[Back to Architecture and Best Practices](#architecture-and-best-practices)

### 186. How does TypeScript enhance Angular development?

[Back to TypeScript Integration](#typescript-integration)

### 187. What are Angular decorators and how do they work?

[Back to TypeScript Integration](#typescript-integration)

### 188. How do you use TypeScript interfaces in Angular?

[Back to TypeScript Integration](#typescript-integration)

### 189. What are generic types and how do you use them in Angular?

[Back to TypeScript Integration](#typescript-integration)

### 190. How do you implement type-safe HTTP requests?

[Back to TypeScript Integration](#typescript-integration)

### 191. What are utility types in TypeScript?

[Back to TypeScript Integration](#typescript-integration)

### 192. How do you use enums in Angular?

[Back to TypeScript Integration](#typescript-integration)

### 193. What is type assertion and type guards?

[Back to TypeScript Integration](#typescript-integration)

### 194. How do you handle optional properties?

[Back to TypeScript Integration](#typescript-integration)

### 195. What are mapped types and conditional types?

[Back to TypeScript Integration](#typescript-integration)

### 196. How do you configure Angular build process?

[Back to Build and Deployment](#build-and-deployment)

### 197. What are build optimization techniques?

[Back to Build and Deployment](#build-and-deployment)

### 198. How do you set up budgets and source maps?

[Back to Build and Deployment](#build-and-deployment)

### 199. What is strict TypeScript mode?

[Back to Build and Deployment](#build-and-deployment)

### 200. How do you implement environment configurations?

[Back to Build and Deployment](#build-and-deployment)

### 201. What are Angular build targets?

[Back to Build and Deployment](#build-and-deployment)

### 202. How do you optimize for production builds?

[Back to Build and Deployment](#build-and-deployment)

### 203. What is differential loading?

[Back to Build and Deployment](#build-and-deployment)

### 204. How do you implement build-time optimizations?

[Back to Build and Deployment](#build-and-deployment)

### 205. What are build analyzers and how to use them?

[Back to Build and Deployment](#build-and-deployment)

### 206. How do you implement accessibility in Angular?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 207. What are CDK a11y utilities (`FocusMonitor`, `LiveAnnouncer`)?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 208. How do you use CDK Overlay/Portals?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 209. What are positioning and scroll strategies?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 210. How do you implement keyboard navigation?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 211. What are ARIA attributes and how to use them?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 212. How do you handle focus management?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 213. What are screen reader considerations?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 214. How do you test accessibility?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 215. What are CDK layout utilities?

[Back to Accessibility and CDK](#accessibility-and-cdk)

### 216. What are directive input coercion and best practices?

[Back to Modern Angular Features](#modern-angular-features)

### 217. How do you use `takeUntilDestroyed` and `DestroyRef`?

[Back to Modern Angular Features](#modern-angular-features)

### 218. What are pure vs impure pipes and their performance impact?

[Back to Modern Angular Features](#modern-angular-features)

### 219. How does `AsyncPipe` work with OnPush?

[Back to Modern Angular Features](#modern-angular-features)

### 220. What are the new control flow features in Angular 17?

[Back to Modern Angular Features](#modern-angular-features)

### 221. How do you use `@defer` for lazy loading?

[Back to Modern Angular Features](#modern-angular-features)

### 222. What are signal inputs and outputs?

[Back to Modern Angular Features](#modern-angular-features)

### 223. How do you migrate from NgModules to standalone?

[Back to Modern Angular Features](#modern-angular-features)

### 224. What are the benefits of standalone APIs?

[Back to Modern Angular Features](#modern-angular-features)

### 225. How do you handle migration strategies?

[Back to Modern Angular Features](#modern-angular-features)

### 226. How do you implement global error handling?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 227. What is `ErrorHandler` and router errors?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 228. How do you handle async errors?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 229. What are debugging techniques in Angular?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 230. How do you use browser dev tools with Angular?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 231. What are common Angular errors and solutions?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 232. How do you implement logging strategies?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 233. What are error boundaries in Angular?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 234. How do you handle network errors?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 235. What are debugging tools and extensions?

[Back to Error Handling and Debugging](#error-handling-and-debugging)

### 236. What are Angular security best practices?

[Back to Security](#security)

### 237. How do you prevent XSS attacks?

[Back to Security](#security)

### 238. What is Content Security Policy (CSP)?

[Back to Security](#security)

### 239. How do you handle authentication tokens securely?

[Back to Security](#security)

### 240. What are CSRF attacks and prevention?

[Back to Security](#security)

### 241. How do you sanitize user input?

[Back to Security](#security)

### 242. What are trusted types?

[Back to Security](#security)

### 243. How do you implement secure HTTP communication?

[Back to Security](#security)

### 244. What are security headers?

[Back to Security](#security)

### 245. How do you handle sensitive data?

[Back to Security](#security)

### 246. How do you upgrade Angular versions?

[Back to Migration and Upgrades](#migration-and-upgrades)

### 247. What are breaking changes to watch for?

[Back to Migration and Upgrades](#migration-and-upgrades)

### 248. How do you migrate from AngularJS to Angular?

[Back to Migration and Upgrades](#migration-and-upgrades)

### 249. What are migration tools and strategies?

[Back to Migration and Upgrades](#migration-and-upgrades)

### 250. How do you handle deprecated APIs?

[Back to Migration and Upgrades](#migration-and-upgrades)

### 251. What is ng update and how to use it?

[Back to Migration and Upgrades](#migration-and-upgrades)

### 252. How do you handle third-party library updates?

[Back to Migration and Upgrades](#migration-and-upgrades)

### 253. What are migration schematics?

[Back to Migration and Upgrades](#migration-and-upgrades)

### 254. How do you test after migrations?

[Back to Migration and Upgrades](#migration-and-upgrades)

### 255. What are rollback strategies?

[Back to Migration and Upgrades](#migration-and-upgrades)

---

[Back to Top](#table-of-contents)
