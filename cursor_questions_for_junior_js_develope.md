# Questions for Junior JavaScript Developers

## **Basic JavaScript Fundamentals**
1. [What are the different data types in JavaScript?](#1-what-are-the-different-data-types-in-javascript)
2. [What's the difference between `let`, `const`, and `var`?](#2-whats-the-difference-between-let-const-and-var)
3. [Explain hoisting in JavaScript with examples.](#3-explain-hoisting-in-javascript-with-examples)
4. [What is the difference between `==` and `===`?](#4-what-is-the-difference-between--and-)
5. [What are falsy values in JavaScript?](#5-what-are-falsy-values-in-javascript)

## **Functions & Scope**
6. [What's the difference between function declarations and function expressions?](#6-whats-the-difference-between-function-declarations-and-function-expressions)
7. [Explain the concept of scope in JavaScript.](#7-explain-the-concept-of-scope-in-javascript)
8. [What is a closure? Can you provide an example?](#8-what-is-a-closure-can-you-provide-an-example)
9. [What does `this` keyword refer to in different contexts?](#9-what-does-this-keyword-refer-to-in-different-contexts)
10. [What are arrow functions and how do they differ from regular functions?](#10-what-are-arrow-functions-and-how-do-they-differ-from-regular-functions)

## **Objects & Arrays**
11. [How do you add, remove, and access properties in JavaScript objects?](#11-how-do-you-add-remove-and-access-properties-in-javascript-objects)
12. [What's the difference between dot notation and bracket notation?](#12-whats-the-difference-between-dot-notation-and-bracket-notation)
13. [Name 5 array methods and explain what they do.](#13-name-5-array-methods-and-explain-what-they-do)
14. [What's the difference between `map()`, `filter()`, and `forEach()`?](#14-whats-the-difference-between-map-filter-and-foreach)
15. [How do you check if a variable is an array?](#15-how-do-you-check-if-a-variable-is-an-array)

## **Asynchronous JavaScript**
16. [What is the event loop in JavaScript?](#16-what-is-the-event-loop-in-javascript)
17. [Explain the difference between synchronous and asynchronous code.](#17-explain-the-difference-between-synchronous-and-asynchronous-code)
18. [What are Promises? How do they work?](#18-what-are-promises-how-do-they-work)
19. [What is `async/await` and how does it relate to Promises?](#19-what-is-asyncawait-and-how-does-it-relate-to-promises)
20. [What is callback hell and how can you avoid it?](#20-what-is-callback-hell-and-how-can-you-avoid-it)

## **DOM Manipulation**
21. [How do you select elements from the DOM?](#21-how-do-you-select-elements-from-the-dom)
22. [What's the difference between `innerHTML`, `textContent`, and `innerText`?](#22-whats-the-difference-between-innerhtml-textcontent-and-innertext)
23. [How do you add event listeners to elements?](#23-how-do-you-add-event-listeners-to-elements)
24. [What is event bubbling and event capturing?](#24-what-is-event-bubbling-and-event-capturing)
25. [How do you prevent the default behavior of an event?](#25-how-do-you-prevent-the-default-behavior-of-an-event)

## **ES6+ Features**
26. [What is destructuring? Show examples with arrays and objects.](#26-what-is-destructuring-show-examples-with-arrays-and-objects)
27. [Explain template literals and their benefits.](#27-explain-template-literals-and-their-benefits)
28. [What are the spread and rest operators?](#28-what-are-the-spread-and-rest-operators)
29. [What are default parameters in functions?](#29-what-are-default-parameters-in-functions)
30. [Explain `for...of` vs `for...in` loops.](#30-explain-forof-vs-forin-loops)

## **Error Handling & Debugging**
31. [How do you handle errors in JavaScript?](#31-how-do-you-handle-errors-in-javascript)
32. [What is the purpose of `try...catch` blocks?](#32-what-is-the-purpose-of-trycatch-blocks)
33. [How do you debug JavaScript code?](#33-how-do-you-debug-javascript-code)
34. [What are common JavaScript errors you might encounter?](#34-what-are-common-javascript-errors-you-might-encounter)

## **Practical Coding Questions**
35. [Write a function to reverse a string.](#35-write-a-function-to-reverse-a-string)
36. [How would you remove duplicates from an array?](#36-how-would-you-remove-duplicates-from-an-array)
37. [Write a function to check if a string is a palindrome.](#37-write-a-function-to-check-if-a-string-is-a-palindrome)
38. [How do you count the occurrences of each character in a string?](#38-how-do-you-count-the-occurrences-of-each-character-in-a-string)
39. [Write a function that returns the largest number in an array.](#39-write-a-function-that-returns-the-largest-number-in-an-array)

## **Conceptual Questions**
40. [What is the difference between mutable and immutable data?](#40-what-is-the-difference-between-mutable-and-immutable-data)
41. [Explain prototypal inheritance in JavaScript.](#41-explain-prototypal-inheritance-in-javascript)
42. [What is JSON and how do you work with it?](#42-what-is-json-and-how-do-you-work-with-it)
43. [What are some JavaScript best practices you follow?](#43-what-are-some-javascript-best-practices-you-follow)
44. [How do you optimize JavaScript code for performance?](#44-how-do-you-optimize-javascript-code-for-performance)

## **Real-world Scenarios**
45. [How would you make an API call in JavaScript?](#45-how-would-you-make-an-api-call-in-javascript)
46. [Explain how you would validate form data on the client side.](#46-explain-how-you-would-validate-form-data-on-the-client-side)
47. [How do you store data in the browser?](#47-how-do-you-store-data-in-the-browser)
48. [What would you do if a web page loads slowly due to JavaScript?](#48-what-would-you-do-if-a-web-page-loads-slowly-due-to-javascript)
49. [How would you implement a simple search functionality?](#49-how-would-you-implement-a-simple-search-functionality)
50. [Describe how you would debug a "function is not defined" error.](#50-describe-how-you-would-debug-a-function-is-not-defined-error)

## **Bonus Advanced Questions**
51. [What are modules in JavaScript and how do you use them?](#51-what-are-modules-in-javascript-and-how-do-you-use-them)
52. [Explain the concept of event delegation.](#52-explain-the-concept-of-event-delegation)
53. [What is the difference between deep and shallow copying?](#53-what-is-the-difference-between-deep-and-shallow-copying)
54. [How do you handle memory leaks in JavaScript?](#54-how-do-you-handle-memory-leaks-in-javascript)
55. [What are Web APIs and how do they work with JavaScript?](#55-what-are-web-apis-and-how-do-they-work-with-javascript)

## **Additional Advanced Questions**
56. [What is the difference between `call()`, `apply()`, and `bind()`?](#56-what-is-the-difference-between-call-apply-and-bind)
57. [Explain prototypal inheritance vs classical inheritance.](#57-explain-prototypal-inheritance-vs-classical-inheritance)
58. [What are generators and iterators in JavaScript?](#58-what-are-generators-and-iterators-in-javascript)
59. [How does JavaScript handle memory management?](#59-how-does-javascript-handle-memory-management)
60. [What is the difference between synchronous and asynchronous module loading?](#60-what-is-the-difference-between-synchronous-and-asynchronous-module-loading)

---

# **Detailed Answers**

## **Basic JavaScript Fundamentals - Detailed Answers**

### 1. What are the different data types in JavaScript?

JavaScript has **8 data types** divided into two categories:

**Primitive Types (7):**
- **Number**: `42`, `3.14`, `NaN`, `Infinity`
- **String**: `"hello"`, `'world'`, `` `template` ``
- **Boolean**: `true`, `false`
- **Undefined**: `undefined` (declared but not assigned)
- **Null**: `null` (intentionally empty value)
- **Symbol**: `Symbol('id')` (unique identifier, ES6+)
- **BigInt**: `123n` (large integers, ES2020+)

**Non-Primitive Type (1):**
- **Object**: `{}`, `[]`, `function(){}`, `new Date()`

```javascript
// Examples of all data types
let num = 42;              // Number
let str = "Hello";         // String
let bool = true;           // Boolean
let undef;                 // Undefined
let empty = null;          // Null
let sym = Symbol('id');    // Symbol
let big = 123n;           // BigInt
let obj = { name: "John" }; // Object

// Type checking
console.log(typeof num);    // "number"
console.log(typeof str);    // "string"
console.log(typeof bool);   // "boolean"
console.log(typeof undef);  // "undefined"
console.log(typeof empty);  // "object" (known bug!)
console.log(typeof sym);    // "symbol"
console.log(typeof big);    // "bigint"
console.log(typeof obj);    // "object"
```

### 2. What's the difference between `let`, `const`, and `var`?

```
┌─────────────────┬────────────────┬──────────────┬─────────────────┐
│    FEATURE      │      var       │     let      │     const       │
├─────────────────┼────────────────┼──────────────┼─────────────────┤
│ Scope           │ Function/Global│ Block        │ Block           │
│ Hoisting        │ Yes (undefined)│ Yes (TDZ)    │ Yes (TDZ)       │
│ Re-declaration  │ ✅ Allowed     │ ❌ Not allowed│ ❌ Not allowed  │
│ Re-assignment   │ ✅ Allowed     │ ✅ Allowed   │ ❌ Not allowed  │
└─────────────────┴────────────────┴──────────────┴─────────────────┘
```

**Key Differences:**
- **`var`**: Function-scoped, hoisted as `undefined`, can be redeclared and reassigned
- **`let`**: Block-scoped, hoisted with TDZ*, can be reassigned but not redeclared  
- **`const`**: Block-scoped, hoisted with TDZ*, cannot be reassigned or redeclared

*TDZ = Temporal Dead Zone (cannot be accessed before declaration)

```javascript
// Scope differences
function scopeExample() {
  if (true) {
    var a = 1;    // Function scoped
    let b = 2;    // Block scoped
    const c = 3;  // Block scoped
  }
  console.log(a); // 1 (accessible)
  console.log(b); // ReferenceError
  console.log(c); // ReferenceError
}

// Re-assignment differences
let x = 1;
x = 2;        // OK

const y = 1;
// y = 2;     // TypeError

// Object mutation with const
const obj = { name: "John" };
obj.name = "Jane";  // OK - modifying property
// obj = {};        // TypeError - reassigning

// Loop behavior
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log("var:", i), 100); // Prints: 3, 3, 3
}

for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log("let:", j), 100); // Prints: 0, 1, 2
}
```

### 3. Explain hoisting in JavaScript with examples.

**Hoisting** moves variable and function declarations to the top of their scope during compilation.

```javascript
// Variable hoisting with var
console.log(x); // undefined (not error!)
var x = 5;

// How JavaScript interprets it:
// var x;          // Declaration hoisted
// console.log(x); // undefined
// x = 5;          // Assignment stays in place

// let/const hoisting (Temporal Dead Zone)
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;

// Function declaration hoisting
console.log(add(2, 3)); // 5 - works before declaration!

function add(a, b) {
  return a + b;
}

// Function expression - NOT hoisted
console.log(subtract); // undefined
console.log(subtract(5, 2)); // TypeError: subtract is not a function

var subtract = function(a, b) {
  return a - b;
};

// Arrow functions - NOT hoisted
console.log(multiply); // ReferenceError
const multiply = (a, b) => a * b;
```

### 4. What is the difference between `==` and `===`?

- **`==` (Loose Equality)**: Compares values with type conversion
- **`===` (Strict Equality)**: Compares values AND types without conversion

```javascript
// Type conversion examples with ==
console.log(5 == "5");     // true (string converted to number)
console.log(true == 1);    // true (boolean converted to number)
console.log(false == 0);   // true (boolean converted to number)
console.log(null == undefined); // true (special case)
console.log("" == 0);      // true (empty string converted to 0)

// Strict comparison with ===
console.log(5 === "5");    // false (different types)
console.log(true === 1);   // false (different types)
console.log(false === 0);  // false (different types)
console.log(null === undefined); // false (different types)
console.log("" === 0);     // false (different types)

// Tricky cases with ==
console.log([] == "");     // true (array converts to empty string)
console.log([1] == 1);     // true ([1] -> "1" -> 1)
console.log({} == "[object Object]"); // true

// Objects compared by reference
let obj1 = { a: 1 };
let obj2 = { a: 1 };
let obj3 = obj1;

console.log(obj1 == obj2);  // false (different objects)
console.log(obj1 === obj2); // false (different objects)
console.log(obj1 === obj3); // true (same reference)

// Best practice: Always use === unless you specifically need type coercion
```

### 5. What are falsy values in JavaScript?

JavaScript has exactly **8 falsy values** that evaluate to `false` in boolean contexts:

```javascript
// The 8 falsy values:
false        // Boolean false
0            // Number zero
-0           // Negative zero
0n           // BigInt zero
""           // Empty string (double quotes)
''           // Empty string (single quotes)
``           // Empty template literal
null         // Null value
undefined    // Undefined value
NaN          // Not a Number

// Testing falsy values
const falsyValues = [false, 0, -0, 0n, "", '', ``, null, undefined, NaN];

falsyValues.forEach((value, index) => {
  console.log(`${index}: ${value} -> ${Boolean(value)}`); // All print false
});

// Everything else is truthy (including empty arrays and objects!)
console.log(Boolean([]));    // true (empty array)
console.log(Boolean({}));    // true (empty object)
console.log(Boolean("0"));   // true (string "0")
console.log(Boolean("false")); // true (string "false")

// Practical usage - default values
function greet(name) {
  name = name || "Guest";    // If name is falsy, use "Guest"
  return `Hello, ${name}!`;
}

console.log(greet("John"));  // "Hello, John!"
console.log(greet(""));      // "Hello, Guest!" (empty string is falsy)
console.log(greet(null));    // "Hello, Guest!" (null is falsy)

// Better approach with nullish coalescing (ES2020)
function greetBetter(name) {
  name = name ?? "Guest";    // Only null/undefined use default
  return `Hello, ${name}!`;
}

console.log(greetBetter(""));   // "Hello, !" (empty string kept)
console.log(greetBetter(null)); // "Hello, Guest!" (null uses default)

// Form validation example
function validateInput(input) {
  if (!input) {
    return "Input is required";
  }
  return "Valid input";
}

console.log(validateInput(""));        // "Input is required"
console.log(validateInput(0));         // "Input is required"
console.log(validateInput(null));      // "Input is required"
console.log(validateInput("hello"));   // "Valid input"
```

## **Functions & Scope - Detailed Answers**

### 6. What's the difference between function declarations and function expressions?

```
┌─────────────────────┬─────────────────────┬─────────────────────┐
│      FEATURE        │ Function Declaration│ Function Expression │
├─────────────────────┼─────────────────────┼─────────────────────┤
│ Hoisting            │ ✅ Fully hoisted    │ ❌ Not hoisted      │
│ Can call before def │ ✅ Yes              │ ❌ No               │
│ Named               │ ✅ Always           │ ⚡ Optional         │
│ Block scope         │ ⚠️ Varies by engine │ ✅ Follows var/let  │
│ Conditional creation│ ❌ Avoid            │ ✅ Safe             │
└─────────────────────┴─────────────────────┴─────────────────────┘
```

```javascript
// FUNCTION DECLARATION
console.log(add(2, 3)); // ✅ Works! Returns 5 (hoisted)

function add(a, b) {
  return a + b;
}

// FUNCTION EXPRESSION
console.log(subtract); // undefined (variable hoisted, not function)
console.log(subtract(5, 2)); // ❌ TypeError: subtract is not a function

var subtract = function(a, b) {
  return a - b;
};

// NAMED FUNCTION EXPRESSION
const factorial = function fact(n) {
  return n <= 1 ? 1 : n * fact(n - 1); // Can use 'fact' inside
};
console.log(factorial(5)); // 120
// console.log(fact(5)); // ❌ ReferenceError: fact not defined outside

// CONDITIONAL CREATION - Function Expression is safer
let operation;
if (useAddition) {
  operation = function(a, b) { return a + b; };
} else {
  operation = function(a, b) { return a * b; };
}

// ARROW FUNCTION EXPRESSION (ES6)
const multiply = (a, b) => a * b;
const square = x => x * x;
const greet = () => "Hello!";
```

### 7. Explain the concept of scope in JavaScript.

**Scope** determines where variables can be accessed in your code. JavaScript has several types of scope:

```javascript
// GLOBAL SCOPE - accessible everywhere
var globalVar = "I'm global";
let globalLet = "I'm also global";
const globalConst = "Me too!";

function demonstrateScope() {
  // FUNCTION SCOPE - accessible within this function
  var functionScoped = "Only in this function";
  
  console.log(globalVar); // ✅ Can access global variables
  
  if (true) {
    // BLOCK SCOPE - only accessible within this block
    let blockScoped = "Only in this block";
    const alsoBlockScoped = "Me too!";
    var stillFunctionScoped = "I escape the block!";
    
    console.log(functionScoped); // ✅ Can access function scope
    console.log(blockScoped);    // ✅ Can access block scope
  }
  
  console.log(stillFunctionScoped); // ✅ var ignores block scope
  console.log(blockScoped);         // ❌ ReferenceError
}

// LEXICAL SCOPE - inner functions can access outer variables
function outerFunction(x) {
  const outerVar = "I'm in outer function";
  
  function innerFunction(y) {
    const innerVar = "I'm in inner function";
    console.log(outerVar); // ✅ Can access outer scope
    console.log(x);        // ✅ Can access outer parameters
    return x + y;
  }
  
  // console.log(innerVar); // ❌ Cannot access inner scope
  return innerFunction;
}

// SCOPE CHAIN - JavaScript looks up the scope chain
const globalValue = "global";

function level1() {
  const level1Value = "level1";
  
  function level2() {
    const level2Value = "level2";
    
    function level3() {
      console.log(level2Value); // Found in level2
      console.log(level1Value); // Found in level1
      console.log(globalValue); // Found in global
      // JavaScript searches: level3 → level2 → level1 → global
    }
    
    return level3;
  }
  
  return level2;
}

// MODULE SCOPE (with ES6 modules)
// Each module has its own scope
// Variables are not automatically global
```

### 8. What is a closure? Can you provide an example?

A **closure** is a function that has access to variables from its outer (enclosing) scope even after the outer function has finished executing.

```javascript
// BASIC CLOSURE EXAMPLE
function createCounter() {
  let count = 0; // Private variable
  
  return function() {
    count++; // Accesses outer variable
    return count;
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1 (separate closure)
console.log(counter1()); // 3

// CLOSURE WITH PARAMETERS
function createMultiplier(multiplier) {
  return function(number) {
    return number * multiplier; // 'multiplier' is remembered
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// PRACTICAL EXAMPLE - Module Pattern
function createBankAccount(initialBalance) {
  let balance = initialBalance; // Private variable
  
  return {
    deposit: function(amount) {
      balance += amount;
      return balance;
    },
    withdraw: function(amount) {
      if (amount <= balance) {
        balance -= amount;
        return balance;
      }
      return "Insufficient funds";
    },
    getBalance: function() {
      return balance;
    }
  };
}

const account = createBankAccount(100);
console.log(account.deposit(50));  // 150
console.log(account.withdraw(30)); // 120
console.log(account.balance);      // undefined (private!)

// CLOSURE IN LOOPS - Common pitfall and solution
// ❌ Problem with var
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // Prints: 3, 3, 3
  }, 100);
}

// ✅ Solution 1: Use let (block scope)
for (let j = 0; j < 3; j++) {
  setTimeout(function() {
    console.log(j); // Prints: 0, 1, 2
  }, 100);
}

// ✅ Solution 2: Create closure with IIFE
for (var k = 0; k < 3; k++) {
  (function(index) {
    setTimeout(function() {
      console.log(index); // Prints: 0, 1, 2
    }, 100);
  })(k);
}
```

### 9. What does `this` keyword refer to in different contexts?

The `this` keyword refers to different objects depending on how and where it's used:

```javascript
// GLOBAL CONTEXT
console.log(this); // Window object (browser) or global object (Node.js)

function globalFunction() {
  console.log(this); // Window object (non-strict) or undefined (strict mode)
}

// OBJECT METHOD
const person = {
  name: "John",
  greet: function() {
    console.log(`Hello, I'm ${this.name}`); // 'this' refers to person object
  },
  nested: {
    name: "Nested",
    greet: function() {
      console.log(`Hello, I'm ${this.name}`); // 'this' refers to nested object
    }
  }
};

person.greet(); // "Hello, I'm John"
person.nested.greet(); // "Hello, I'm Nested"

// LOST CONTEXT PROBLEM
const greetFunction = person.greet;
greetFunction(); // "Hello, I'm undefined" - lost context!

// CONSTRUCTOR FUNCTION
function Person(name) {
  this.name = name; // 'this' refers to new instance
  this.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
  };
}

const john = new Person("John");
john.greet(); // "Hello, I'm John"

// ARROW FUNCTIONS - Lexical 'this'
const obj = {
  name: "Object",
  regularMethod: function() {
    console.log(`Regular: ${this.name}`); // 'this' is obj
    
    const arrowFunction = () => {
      console.log(`Arrow: ${this.name}`); // 'this' inherited from regularMethod
    };
    
    function regularInner() {
      console.log(`Inner: ${this.name}`); // 'this' is undefined/Window
    }
    
    arrowFunction();
    regularInner();
  }
};

obj.regularMethod();
// Regular: Object
// Arrow: Object
// Inner: undefined

// EXPLICIT BINDING with call, apply, bind
const person1 = { name: "Alice" };
const person2 = { name: "Bob" };

function introduce() {
  console.log(`Hi, I'm ${this.name}`);
}

introduce.call(person1);  // "Hi, I'm Alice"
introduce.apply(person2); // "Hi, I'm Bob"

const boundIntroduce = introduce.bind(person1);
boundIntroduce(); // "Hi, I'm Alice"

// EVENT HANDLERS
document.getElementById('myButton')?.addEventListener('click', function() {
  console.log(this); // Refers to the button element
});

// Arrow function in event handler
document.getElementById('myButton')?.addEventListener('click', () => {
  console.log(this); // Refers to global object (not the button!)
});
```

### 10. What are arrow functions and how do they differ from regular functions?

```
┌─────────────────────┬─────────────────────┬─────────────────────┐
│      FEATURE        │  Regular Function   │   Arrow Function    │
├─────────────────────┼─────────────────────┼─────────────────────┤
│ Syntax              │ function() {}       │ () => {}            │
│ 'this' binding      │ ⚡ Dynamic          │ ✅ Lexical          │
│ 'arguments' object  │ ✅ Available        │ ❌ Not available    │
│ Hoisting            │ ✅ Yes (if declared)│ ❌ No               │
│ Constructor         │ ✅ Can use 'new'    │ ❌ Cannot           │
│ Method definition   │ ✅ Good choice      │ ⚠️ Usually avoid   │
└─────────────────────┴─────────────────────┴─────────────────────┘
```

```javascript
// SYNTAX VARIATIONS
// Regular function
function add(a, b) {
  return a + b;
}

// Arrow function - multiple parameters
const addArrow = (a, b) => {
  return a + b;
};

// Arrow function - single parameter (parentheses optional)
const double = x => x * 2;
const doubleExplicit = (x) => x * 2;

// Arrow function - no parameters
const sayHello = () => "Hello!";

// Arrow function - implicit return
const multiply = (a, b) => a * b;

// Arrow function - object return (needs parentheses)
const createUser = (name, age) => ({ name, age });

// Arrow function - multiline with explicit return
const complexCalculation = (x, y) => {
  const temp = x * 2;
  const result = temp + y;
  return result;
};

// 'THIS' BINDING DIFFERENCES
const obj = {
  name: "MyObject",
  
  // Regular method - 'this' refers to obj
  regularMethod: function() {
    console.log(`Regular: ${this.name}`); // "Regular: MyObject"
    
    // Regular function inside method - loses context
    setTimeout(function() {
      console.log(`Timeout Regular: ${this.name}`); // "Timeout Regular: undefined"
    }, 100);
    
    // Arrow function inside method - keeps context
    setTimeout(() => {
      console.log(`Timeout Arrow: ${this.name}`); // "Timeout Arrow: MyObject"
    }, 100);
  },
  
  // Arrow method - 'this' refers to global object
  arrowMethod: () => {
    console.log(`Arrow Method: ${this.name}`); // "Arrow Method: undefined"
  }
};

// ARGUMENTS OBJECT
function regularFunc() {
  console.log(arguments); // [Arguments] { '0': 1, '1': 2, '2': 3 }
  console.log(arguments.length); // 3
}

const arrowFunc = (...args) => {
  console.log(args); // [1, 2, 3] - use rest parameters instead
  console.log(args.length); // 3
};

regularFunc(1, 2, 3);
arrowFunc(1, 2, 3);

// CONSTRUCTOR USAGE
// Regular function as constructor
function Person(name) {
  this.name = name;
}

const person = new Person("John"); // ✅ Works

// Arrow function as constructor
const PersonArrow = (name) => {
  this.name = name;
};

// const person2 = new PersonArrow("Jane"); // ❌ TypeError: not a constructor

// PRACTICAL USE CASES

// ✅ Good for arrow functions: Array methods
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => x * 2);
const evens = numbers.filter(x => x % 2 === 0);
const sum = numbers.reduce((acc, x) => acc + x, 0);

// ✅ Good for arrow functions: Event handlers when you need lexical 'this'
class EventHandler {
  constructor() {
    this.count = 0;
  }
  
  handleClick = () => {
    this.count++; // 'this' correctly refers to class instance
    console.log(`Clicked ${this.count} times`);
  }
}

// ❌ Avoid arrow functions: Object methods
const badExample = {
  name: "Bad",
  greet: () => {
    console.log(`Hello ${this.name}`); // 'this' doesn't refer to object
  }
};

// ✅ Use regular functions: Object methods
const goodExample = {
  name: "Good",
  greet: function() {
    console.log(`Hello ${this.name}`); // 'this' correctly refers to object
  }
};
```

## **Objects & Arrays - Detailed Answers**

### 11. How do you add, remove, and access properties in JavaScript objects?

```
┌─────────────────────┬─────────────────────┬─────────────────────┐
│     OPERATION       │    DOT NOTATION     │  BRACKET NOTATION   │
├─────────────────────┼─────────────────────┼─────────────────────┤
│ Access Property     │ obj.property        │ obj["property"]     │
│ Add Property        │ obj.newProp = value │ obj["newProp"] = val│
│ Remove Property     │ delete obj.property │ delete obj["prop"]  │
│ Dynamic Keys        │ ❌ Not possible     │ ✅ obj[variable]    │
│ Special Characters  │ ❌ Limited          │ ✅ obj["key-name"]  │
└─────────────────────┴─────────────────────┴─────────────────────┘
```

```javascript
// CREATING OBJECTS
const person = {
  name: "John",
  age: 30,
  "favorite-color": "blue", // Special characters need quotes
  123: "numeric key"        // Numeric keys are converted to strings
};

// ACCESSING PROPERTIES
console.log(person.name);           // "John" - dot notation
console.log(person["age"]);         // 30 - bracket notation
console.log(person["favorite-color"]); // "blue" - special chars require brackets
console.log(person[123]);           // "numeric key" - numeric keys
console.log(person["123"]);         // "numeric key" - same as above

// DYNAMIC PROPERTY ACCESS
const propertyName = "age";
console.log(person[propertyName]);  // 30 - using variable
console.log(person.propertyName);   // undefined - looks for literal "propertyName"

// ADDING PROPERTIES
person.email = "john@example.com";  // Dot notation
person["phone"] = "123-456-7890";   // Bracket notation
person["last-login"] = new Date();  // Special characters

// Dynamic property addition
const newProp = "country";
person[newProp] = "USA";

// COMPUTED PROPERTY NAMES (ES6)
const key = "dynamicKey";
const obj = {
  [key]: "dynamic value",
  [`computed_${key}`]: "computed name"
};

// REMOVING PROPERTIES
delete person.phone;                // Returns true if successful
delete person["last-login"];

// Alternative removal methods
person.email = undefined;           // Property exists but value is undefined
person.country = null;              // Property exists but value is null

// CHECKING PROPERTY EXISTENCE
console.log("name" in person);          // true
console.log(person.hasOwnProperty("name")); // true
console.log(person.name !== undefined); // true

// Object.hasOwnProperty vs 'in' operator
const child = Object.create(person);
child.childProp = "child value";

console.log("name" in child);               // true (inherited)
console.log(child.hasOwnProperty("name"));  // false (not own property)

// PROPERTY DESCRIPTORS
Object.defineProperty(person, "secretAge", {
  value: 25,
  writable: false,    // Cannot be changed
  enumerable: false,  // Won't show in for...in or Object.keys()
  configurable: false // Cannot be deleted or redefined
});

// OBJECT METHODS FOR PROPERTY MANIPULATION
const user = { name: "Alice", age: 28, city: "NYC" };

// Getting property names and values
console.log(Object.keys(user));     // ["name", "age", "city"]
console.log(Object.values(user));   // ["Alice", 28, "NYC"]
console.log(Object.entries(user));  // [["name", "Alice"], ["age", 28], ...]

// Copying properties
const newUser = Object.assign({}, user, { role: "admin" });
const spreadUser = { ...user, role: "user" }; // ES6+ spread operator
```

### 12. What's the difference between dot notation and bracket notation?

```javascript
const obj = {
  name: "John",
  age: 30,
  "favorite-food": "pizza",
  "123": "numeric key",
  "": "empty key"
};

// ✅ DOT NOTATION - When to use:
console.log(obj.name);        // Simple property names
console.log(obj.age);         // Valid JavaScript identifiers

// ❌ DOT NOTATION - Limitations:
// console.log(obj.favorite-food);  // SyntaxError: Invalid
// console.log(obj.123);            // SyntaxError: Invalid
// console.log(obj."");             // SyntaxError: Invalid

// ✅ BRACKET NOTATION - More flexible:
console.log(obj["favorite-food"]); // Special characters
console.log(obj["123"]);           // Numeric keys
console.log(obj[""]);              // Empty string key

// DYNAMIC ACCESS
const properties = ["name", "age", "favorite-food"];
properties.forEach(prop => {
  console.log(`${prop}: ${obj[prop]}`); // ✅ Works with bracket notation
  // console.log(`${prop}: ${obj.prop}`); // ❌ Would look for literal "prop"
});

// COMPUTED PROPERTIES
function getValue(object, key) {
  return object[key]; // Must use bracket notation for parameter
}

// WHEN TO USE EACH:

// ✅ Use DOT notation for:
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
};

console.log(config.apiUrl);
config.timeout = 10000;

// ✅ Use BRACKET notation for:
const data = {
  "user-name": "john_doe",
  "api-key": "secret123",
  "2023-data": {...}
};

// Variables as keys
const keyName = "user-name";
console.log(data[keyName]);

// Special characters
console.log(data["api-key"]);

// Dynamic property names
const year = 2023;
console.log(data[`${year}-data`]);

// Loop through properties
for (const key in data) {
  console.log(`${key}: ${data[key]}`); // Must use bracket notation
}

// PERFORMANCE CONSIDERATION
// Dot notation is slightly faster (compiled time resolution)
// Bracket notation is resolved at runtime

// NESTED OBJECTS
const user = {
  profile: {
    personal: {
      name: "John",
      "birth-year": 1990
    }
  }
};

// Accessing nested properties
console.log(user.profile.personal.name);
console.log(user["profile"]["personal"]["birth-year"]);
console.log(user.profile.personal["birth-year"]); // Mixed notation
```

### 13. Name 5 array methods and explain what they do.

```javascript
const numbers = [1, 2, 3, 4, 5];
const fruits = ["apple", "banana", "orange"];
const users = [
  { name: "John", age: 30 },
  { name: "Jane", age: 25 },
  { name: "Bob", age: 35 }
];

// ✅ 1. PUSH() - Adds elements to the end
console.log(fruits.push("grape"));      // Returns new length: 4
console.log(fruits);                    // ["apple", "banana", "orange", "grape"]

// Add multiple elements
fruits.push("kiwi", "mango");
console.log(fruits);                    // [..., "grape", "kiwi", "mango"]

// ✅ 2. POP() - Removes and returns the last element
const lastFruit = fruits.pop();
console.log(lastFruit);                 // "mango"
console.log(fruits);                    // [..., "kiwi"] (mango removed)

// ✅ 3. SLICE() - Returns a shallow copy of a portion (doesn't modify original)
const someNumbers = numbers.slice(1, 4); // From index 1 to 3 (4 excluded)
console.log(someNumbers);               // [2, 3, 4]
console.log(numbers);                   // [1, 2, 3, 4, 5] (unchanged)

// Slice without end parameter
console.log(numbers.slice(2));          // [3, 4, 5] (from index 2 to end)

// Negative indices
console.log(numbers.slice(-2));         // [4, 5] (last 2 elements)
console.log(numbers.slice(-3, -1));     // [3, 4] (from 3rd last to 2nd last)

// ✅ 4. SPLICE() - Changes array by removing/adding elements (modifies original)
const colors = ["red", "green", "blue", "yellow"];

// Remove elements: splice(start, deleteCount)
const removed = colors.splice(1, 2);    // Remove 2 elements starting at index 1
console.log(removed);                   // ["green", "blue"] (removed elements)
console.log(colors);                    // ["red", "yellow"] (original modified)

// Add elements: splice(start, deleteCount, ...itemsToAdd)
colors.splice(1, 0, "purple", "orange"); // Add at index 1, remove 0
console.log(colors);                    // ["red", "purple", "orange", "yellow"]

// Replace elements
colors.splice(1, 2, "pink");            // Remove 2, add 1 at index 1
console.log(colors);                    // ["red", "pink", "yellow"]

// ✅ 5. INDEXOF() - Returns first index of element, or -1 if not found
console.log(fruits.indexOf("banana"));  // 1
console.log(fruits.indexOf("grape"));   // -1 (not found)
console.log(fruits.indexOf("apple"));   // 0

// Case sensitive
console.log(fruits.indexOf("Apple"));   // -1 (capital A not found)

// Find from specific starting position
const duplicates = ["a", "b", "c", "b", "d"];
console.log(duplicates.indexOf("b"));      // 1 (first occurrence)
console.log(duplicates.indexOf("b", 2));   // 3 (search starting from index 2)

// BONUS METHODS:

// ✅ UNSHIFT() - Adds elements to the beginning
fruits.unshift("strawberry");
console.log(fruits);                    // ["strawberry", "apple", "banana", ...]

// ✅ SHIFT() - Removes and returns first element
const firstFruit = fruits.shift();
console.log(firstFruit);               // "strawberry"

// ✅ INCLUDES() - Checks if array contains element (ES2016+)
console.log(numbers.includes(3));      // true
console.log(numbers.includes(10));     // false

// ✅ REVERSE() - Reverses array in place
const reversed = numbers.reverse();
console.log(numbers);                  // [5, 4, 3, 2, 1] (original modified)
console.log(reversed === numbers);     // true (same reference)

// ✅ SORT() - Sorts array in place
const names = ["Charlie", "Alice", "Bob"];
names.sort();
console.log(names);                    // ["Alice", "Bob", "Charlie"]

// Custom sort function
users.sort((a, b) => a.age - b.age);  // Sort by age ascending
console.log(users);                    // Sorted by age

// MUTATING vs NON-MUTATING METHODS:

// 🔄 MUTATING (modify original array):
// push(), pop(), shift(), unshift(), splice(), reverse(), sort()

// 🔒 NON-MUTATING (return new array/value):
// slice(), indexOf(), includes(), concat(), join()
```

### 14. What's the difference between `map()`, `filter()`, and `forEach()`?

```
┌─────────────────────┬─────────────────────┬─────────────────────┬─────────────────────┐
│      METHOD         │      forEach()      │       map()         │      filter()       │
├─────────────────────┼─────────────────────┼─────────────────────┼─────────────────────┤
│ Returns             │ undefined           │ ✅ New array        │ ✅ New array        │
│ Original Array      │ ✅ Unchanged        │ ✅ Unchanged        │ ✅ Unchanged        │
│ Purpose             │ Side effects        │ Transform elements  │ Select elements     │
│ Break Early         │ ❌ No              │ ❌ No              │ ❌ No              │
│ Chainable           │ ❌ No              │ ✅ Yes             │ ✅ Yes             │
└─────────────────────┴─────────────────────┴─────────────────────┴─────────────────────┘
```

```javascript
const numbers = [1, 2, 3, 4, 5];
const users = [
  { name: "John", age: 30, active: true },
  { name: "Jane", age: 25, active: false },
  { name: "Bob", age: 35, active: true },
  { name: "Alice", age: 28, active: true }
];

// ✅ FOREACH() - Execute function for each element (no return value)
console.log("=== forEach() ===");
numbers.forEach((num, index, array) => {
  console.log(`Index ${index}: ${num}`);
  // Can't break or return early
});

// Side effects example
let sum = 0;
numbers.forEach(num => {
  sum += num; // Modifying external variable
});
console.log(`Sum: ${sum}`); // 15

// ❌ forEach doesn't return anything useful
const forEachResult = numbers.forEach(num => num * 2);
console.log(forEachResult); // undefined

// ✅ MAP() - Transform each element and return new array
console.log("=== map() ===");
const doubled = numbers.map(num => num * 2);
console.log(doubled);       // [2, 4, 6, 8, 10]
console.log(numbers);       // [1, 2, 3, 4, 5] (unchanged)

// Transform objects
const userNames = users.map(user => user.name);
console.log(userNames);     // ["John", "Jane", "Bob", "Alice"]

// More complex transformations
const userSummaries = users.map(user => ({
  displayName: user.name.toUpperCase(),
  isAdult: user.age >= 18,
  status: user.active ? "Active" : "Inactive"
}));
console.log(userSummaries);

// Map with index
const numbersWithIndex = numbers.map((num, index) => `${index}: ${num}`);
console.log(numbersWithIndex); // ["0: 1", "1: 2", "2: 3", "3: 4", "4: 5"]

// ✅ FILTER() - Select elements that pass a test
console.log("=== filter() ===");
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers);   // [2, 4]

const activeUsers = users.filter(user => user.active);
console.log(activeUsers);   // Only users with active: true

// Filter with multiple conditions
const youngActiveUsers = users.filter(user => user.age < 30 && user.active);
console.log(youngActiveUsers);

// Filter with index
const firstThree = numbers.filter((num, index) => index < 3);
console.log(firstThree);    // [1, 2, 3]

// CHAINING METHODS (map and filter return arrays)
console.log("=== Chaining ===");
const result = users
  .filter(user => user.active)           // Get active users
  .map(user => user.name.toUpperCase())  // Transform to uppercase names
  .filter(name => name.length > 3);      // Only names longer than 3 chars

console.log(result); // ["JOHN", "ALICE"]

// Complex chaining example
const processedData = numbers
  .filter(num => num > 2)     // [3, 4, 5]
  .map(num => num * 3)        // [9, 12, 15]
  .filter(num => num < 14);   // [9, 12]

console.log(processedData);

// ❌ CAN'T chain forEach (returns undefined)
// numbers.forEach(num => num * 2).filter(num => num > 5); // TypeError!

// PERFORMANCE COMPARISON
console.log("=== Performance ===");
const largeArray = Array.from({ length: 1000000 }, (_, i) => i);

// forEach - for side effects only
console.time("forEach");
let total = 0;
largeArray.forEach(num => {
  total += num;
});
console.timeEnd("forEach");

// map - when you need to transform
console.time("map");
const transformed = largeArray.map(num => num * 2);
console.timeEnd("map");

// filter - when you need to select
console.time("filter");
const filtered = largeArray.filter(num => num % 2 === 0);
console.timeEnd("filter");

// WHEN TO USE EACH:

// ✅ Use forEach when:
// - You need to perform side effects (logging, DOM manipulation, etc.)
// - You don't need a return value
// - You're not transforming data

// ✅ Use map when:
// - You need to transform every element
// - You want a new array of the same length
// - You're creating React components from data

// ✅ Use filter when:
// - You need to select elements based on criteria
// - You want a new array with fewer elements
// - You're implementing search functionality

// PRACTICAL EXAMPLES
const products = [
  { name: "Laptop", price: 1000, inStock: true },
  { name: "Phone", price: 500, inStock: false },
  { name: "Tablet", price: 300, inStock: true }
];

// Get available product names
const availableProducts = products
  .filter(product => product.inStock)
  .map(product => product.name);

// Apply discount to all prices
const discountedProducts = products.map(product => ({
  ...product,
  price: product.price * 0.9
}));

// Log each product (side effect)
products.forEach(product => {
  console.log(`${product.name}: $${product.price}`);
});
```

### 15. How do you check if a variable is an array?

```javascript
// ✅ RECOMMENDED METHOD: Array.isArray() (ES5+)
console.log(Array.isArray([]));           // true
console.log(Array.isArray([1, 2, 3]));    // true
console.log(Array.isArray("string"));     // false
console.log(Array.isArray({}));           // false
console.log(Array.isArray(null));         // false
console.log(Array.isArray(undefined));    // false

// ✅ ALTERNATIVE: instanceof operator
const arr = [1, 2, 3];
console.log(arr instanceof Array);        // true

// ⚠️ instanceof issues with iframes
// If array comes from different window/iframe:
// frameArray instanceof Array  // might be false!
// Array.isArray(frameArray)     // always works correctly

// ❌ UNRELIABLE: typeof operator
console.log(typeof []);                   // "object" (not helpful!)
console.log(typeof {});                   // "object" (same as array)

// ❌ UNRELIABLE: constructor property
const myArray = [1, 2, 3];
console.log(myArray.constructor === Array); // true, but can be modified

// Someone could change it:
// myArray.constructor = String;
// myArray.constructor === Array; // now false!

// ✅ ROBUST: Object.prototype.toString.call()
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}

console.log(getType([]));           // "Array"
console.log(getType({}));           // "Object"
console.log(getType("string"));     // "String"
console.log(getType(42));           // "Number"
console.log(getType(null));         // "Null"
console.log(getType(undefined));    // "Undefined"

// COMPARISON OF ALL METHODS:

const testCases = [
  [],
  [1, 2, 3],
  {},
  "string",
  42,
  null,
  undefined,
  new Array(),
  Array.from([1, 2, 3])
];

console.log("Value".padEnd(15) + "Array.isArray".padEnd(15) + "instanceof".padEnd(12) + "typeof".padEnd(10) + "toString");
console.log("-".repeat(70));

testCases.forEach(value => {
  const str = JSON.stringify(value) || String(value);
  const isArray = Array.isArray(value);
  const instanceof_result = value instanceof Array;
  const typeof_result = typeof value;
  const toString_result = Object.prototype.toString.call(value).slice(8, -1);
  
  console.log(
    str.padEnd(15) + 
    String(isArray).padEnd(15) + 
    String(instanceof_result).padEnd(12) + 
    typeof_result.padEnd(10) + 
    toString_result
  );
});

// PRACTICAL USAGE EXAMPLES:

// ✅ Function that accepts array or single value
function processItems(items) {
  // Normalize to array
  const itemArray = Array.isArray(items) ? items : [items];
  
  return itemArray.map(item => `Processed: ${item}`);
}

console.log(processItems("single"));      // ["Processed: single"]
console.log(processItems(["a", "b"]));    // ["Processed: a", "Processed: b"]

// ✅ Type guard function
function isArrayOfStrings(value) {
  return Array.isArray(value) && value.every(item => typeof item === "string");
}

console.log(isArrayOfStrings(["a", "b"]));     // true
console.log(isArrayOfStrings(["a", 1]));       // false
console.log(isArrayOfStrings("string"));       // false

// ✅ Safe array operations
function safeMap(array, callback) {
  if (!Array.isArray(array)) {
    throw new Error("First argument must be an array");
  }
  return array.map(callback);
}

// ✅ Array-like objects vs real arrays
const arrayLike = {
  0: "first",
  1: "second",
  length: 2
};

console.log(Array.isArray(arrayLike));          // false
console.log(Array.isArray(Array.from(arrayLike))); // true

// Arguments object (in regular functions)
function testArguments() {
  console.log(Array.isArray(arguments));        // false
  console.log(Array.isArray([...arguments]));   // true
}

testArguments(1, 2, 3);

// NodeList vs Array
// const nodeList = document.querySelectorAll('div');
// console.log(Array.isArray(nodeList));        // false
// console.log(Array.isArray([...nodeList]));   // true

// POLYFILL for older browsers (if needed)
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}

// BEST PRACTICES:
// 1. Always use Array.isArray() for modern JavaScript
// 2. Use instanceof only if you're sure about the context
// 3. Never rely on typeof for array detection
// 4. Consider array-like objects in your logic
// 5. Use type guards for more specific checking
```
