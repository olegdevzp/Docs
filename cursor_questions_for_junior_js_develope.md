# Questions for Junior JavaScript Developers

## **Basic JavaScript Fundamentals**
1. [What are the different data types in JavaScript?](#1-what-are-the-different-data-types-in-javascript)
2. [What's the difference between `let`, `const`, and `var`?](#2-whats-the-difference-between-let-const-and-var)
3. [Explain hoisting in JavaScript with examples.](#3-explain-hoisting-in-javascript-with-examples)
4. [What is the difference between `==` and `===`?](#4-what-is-the-difference-between--and-)
5. [What are falsy values in JavaScript?](#5-what-are-falsy-values-in-javascript)

## **Functions & Scope**
6. [What's the difference between function declarations and function expressions?](#6-whats-the-difference-between-function-declarations-and-function-expressions)
7. [Explain the concept of scope in JavaScript.](#7-explain-the-concept-of-scope-in-javascript)
8. [What is a closure? Can you provide an example?](#8-what-is-a-closure-can-you-provide-an-example)
9. [What does `this` keyword refer to in different contexts?](#9-what-does-this-keyword-refer-to-in-different-contexts)
10. [What are arrow functions and how do they differ from regular functions?](#10-what-are-arrow-functions-and-how-do-they-differ-from-regular-functions)

## **Objects & Arrays**
11. [How do you add, remove, and access properties in JavaScript objects?](#11-how-do-you-add-remove-and-access-properties-in-javascript-objects)
12. [What's the difference between dot notation and bracket notation?](#12-whats-the-difference-between-dot-notation-and-bracket-notation)
13. [Name 5 array methods and explain what they do.](#13-name-5-array-methods-and-explain-what-they-do)
14. [What's the difference between `map()`, `filter()`, and `forEach()`?](#14-whats-the-difference-between-map-filter-and-foreach)
15. [How do you check if a variable is an array?](#15-how-do-you-check-if-a-variable-is-an-array)

## **Asynchronous JavaScript**
16. [What is the event loop in JavaScript?](#16-what-is-the-event-loop-in-javascript)
17. [Explain the difference between synchronous and asynchronous code.](#17-explain-the-difference-between-synchronous-and-asynchronous-code)
18. [What are Promises? How do they work?](#18-what-are-promises-how-do-they-work)
19. [What is `async/await` and how does it relate to Promises?](#19-what-is-asyncawait-and-how-does-it-relate-to-promises)
20. [What is callback hell and how can you avoid it?](#20-what-is-callback-hell-and-how-can-you-avoid-it)

## **DOM Manipulation**
21. [How do you select elements from the DOM?](#21-how-do-you-select-elements-from-the-dom)
22. [What's the difference between `innerHTML`, `textContent`, and `innerText`?](#22-whats-the-difference-between-innerhtml-textcontent-and-innertext)
23. [How do you add event listeners to elements?](#23-how-do-you-add-event-listeners-to-elements)
24. [What is event bubbling and event capturing?](#24-what-is-event-bubbling-and-event-capturing)
25. [How do you prevent the default behavior of an event?](#25-how-do-you-prevent-the-default-behavior-of-an-event)

## **ES6+ Features**
26. [What is destructuring? Show examples with arrays and objects.](#26-what-is-destructuring-show-examples-with-arrays-and-objects)
27. [Explain template literals and their benefits.](#27-explain-template-literals-and-their-benefits)
28. [What are the spread and rest operators?](#28-what-are-the-spread-and-rest-operators)
29. [What are default parameters in functions?](#29-what-are-default-parameters-in-functions)
30. [Explain `for...of` vs `for...in` loops.](#30-explain-forof-vs-forin-loops)

## **Error Handling & Debugging**
31. [How do you handle errors in JavaScript?](#31-how-do-you-handle-errors-in-javascript)
32. [What is the purpose of `try...catch` blocks?](#32-what-is-the-purpose-of-trycatch-blocks)
33. [How do you debug JavaScript code?](#33-how-do-you-debug-javascript-code)
34. [What are common JavaScript errors you might encounter?](#34-what-are-common-javascript-errors-you-might-encounter)

## **Practical Coding Questions**
35. [Write a function to reverse a string.](#35-write-a-function-to-reverse-a-string)
36. [How would you remove duplicates from an array?](#36-how-would-you-remove-duplicates-from-an-array)
37. [Write a function to check if a string is a palindrome.](#37-write-a-function-to-check-if-a-string-is-a-palindrome)
38. [How do you count the occurrences of each character in a string?](#38-how-do-you-count-the-occurrences-of-each-character-in-a-string)
39. [Write a function that returns the largest number in an array.](#39-write-a-function-that-returns-the-largest-number-in-an-array)

## **Conceptual Questions**
40. [What is the difference between mutable and immutable data?](#40-what-is-the-difference-between-mutable-and-immutable-data)
41. [Explain prototypal inheritance in JavaScript.](#41-explain-prototypal-inheritance-in-javascript)
42. [What is JSON and how do you work with it?](#42-what-is-json-and-how-do-you-work-with-it)
43. [What are some JavaScript best practices you follow?](#43-what-are-some-javascript-best-practices-you-follow)
44. [How do you optimize JavaScript code for performance?](#44-how-do-you-optimize-javascript-code-for-performance)

## **Real-world Scenarios**
45. [How would you make an API call in JavaScript?](#45-how-would-you-make-an-api-call-in-javascript)
46. [Explain how you would validate form data on the client side.](#46-explain-how-you-would-validate-form-data-on-the-client-side)
47. [How do you store data in the browser?](#47-how-do-you-store-data-in-the-browser)
48. [What would you do if a web page loads slowly due to JavaScript?](#48-what-would-you-do-if-a-web-page-loads-slowly-due-to-javascript)
49. [How would you implement a simple search functionality?](#49-how-would-you-implement-a-simple-search-functionality)
50. [Describe how you would debug a "function is not defined" error.](#50-describe-how-you-would-debug-a-function-is-not-defined-error)

## **Bonus Advanced Questions**
51. [What are modules in JavaScript and how do you use them?](#51-what-are-modules-in-javascript-and-how-do-you-use-them)
52. [Explain the concept of event delegation.](#52-explain-the-concept-of-event-delegation)
53. [What is the difference between deep and shallow copying?](#53-what-is-the-difference-between-deep-and-shallow-copying)
54. [How do you handle memory leaks in JavaScript?](#54-how-do-you-handle-memory-leaks-in-javascript)
55. [What are Web APIs and how do they work with JavaScript?](#55-what-are-web-apis-and-how-do-they-work-with-javascript)

## **Additional Advanced Questions**
56. [What is the difference between `call()`, `apply()`, and `bind()`?](#56-what-is-the-difference-between-call-apply-and-bind)
57. [Explain prototypal inheritance vs classical inheritance.](#57-explain-prototypal-inheritance-vs-classical-inheritance)
58. [What are generators and iterators in JavaScript?](#58-what-are-generators-and-iterators-in-javascript)
59. [How does JavaScript handle memory management?](#59-how-does-javascript-handle-memory-management)
60. [What is the difference between synchronous and asynchronous module loading?](#60-what-is-the-difference-between-synchronous-and-asynchronous-module-loading)

---

# **Detailed Answers**

## **Basic JavaScript Fundamentals - Detailed Answers**

### 1. What are the different data types in JavaScript?

JavaScript has **8 data types** divided into two categories:

**Primitive Types (7):**
- **Number**: `42`, `3.14`, `NaN`, `Infinity`
- **String**: `"hello"`, `'world'`, `` `template` ``
- **Boolean**: `true`, `false`
- **Undefined**: `undefined` (declared but not assigned)
- **Null**: `null` (intentionally empty value)
- **Symbol**: `Symbol('id')` (unique identifier, ES6+)
- **BigInt**: `123n` (large integers, ES2020+)

**Non-Primitive Type (1):**
- **Object**: `{}`, `[]`, `function(){}`, `new Date()`

```javascript
// Examples of all data types
let num = 42;              // Number
let str = "Hello";         // String
let bool = true;           // Boolean
let undef;                 // Undefined
let empty = null;          // Null
let sym = Symbol('id');    // Symbol
let big = 123n;           // BigInt
let obj = { name: "John" }; // Object

// Type checking
console.log(typeof num);    // "number"
console.log(typeof str);    // "string"
console.log(typeof bool);   // "boolean"
console.log(typeof undef);  // "undefined"
console.log(typeof empty);  // "object" (known bug!)
console.log(typeof sym);    // "symbol"
console.log(typeof big);    // "bigint"
console.log(typeof obj);    // "object"
```

### 2. What's the difference between `let`, `const`, and `var`?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    FEATURE      â”‚      var       â”‚     let      â”‚     const       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Scope           â”‚ Function/Globalâ”‚ Block        â”‚ Block           â”‚
â”‚ Hoisting        â”‚ Yes (undefined)â”‚ Yes (TDZ)    â”‚ Yes (TDZ)       â”‚
â”‚ Re-declaration  â”‚ âœ… Allowed     â”‚ âŒ Not allowedâ”‚ âŒ Not allowed  â”‚
â”‚ Re-assignment   â”‚ âœ… Allowed     â”‚ âœ… Allowed   â”‚ âŒ Not allowed  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Differences:**
- **`var`**: Function-scoped, hoisted as `undefined`, can be redeclared and reassigned
- **`let`**: Block-scoped, hoisted with TDZ*, can be reassigned but not redeclared  
- **`const`**: Block-scoped, hoisted with TDZ*, cannot be reassigned or redeclared

*TDZ = Temporal Dead Zone (cannot be accessed before declaration)

```javascript
// Scope differences
function scopeExample() {
  if (true) {
    var a = 1;    // Function scoped
    let b = 2;    // Block scoped
    const c = 3;  // Block scoped
  }
  console.log(a); // 1 (accessible)
  console.log(b); // ReferenceError
  console.log(c); // ReferenceError
}

// Re-assignment differences
let x = 1;
x = 2;        // OK

const y = 1;
// y = 2;     // TypeError

// Object mutation with const
const obj = { name: "John" };
obj.name = "Jane";  // OK - modifying property
// obj = {};        // TypeError - reassigning

// Loop behavior
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log("var:", i), 100); // Prints: 3, 3, 3
}

for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log("let:", j), 100); // Prints: 0, 1, 2
}
```

### 3. Explain hoisting in JavaScript with examples.

**Hoisting** moves variable and function declarations to the top of their scope during compilation.

```javascript
// Variable hoisting with var
console.log(x); // undefined (not error!)
var x = 5;

// How JavaScript interprets it:
// var x;          // Declaration hoisted
// console.log(x); // undefined
// x = 5;          // Assignment stays in place

// let/const hoisting (Temporal Dead Zone)
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;

// Function declaration hoisting
console.log(add(2, 3)); // 5 - works before declaration!

function add(a, b) {
  return a + b;
}

// Function expression - NOT hoisted
console.log(subtract); // undefined
console.log(subtract(5, 2)); // TypeError: subtract is not a function

var subtract = function(a, b) {
  return a - b;
};

// Arrow functions - NOT hoisted
console.log(multiply); // ReferenceError
const multiply = (a, b) => a * b;
```

### 4. What is the difference between `==` and `===`?

- **`==` (Loose Equality)**: Compares values with type conversion
- **`===` (Strict Equality)**: Compares values AND types without conversion

```javascript
// Type conversion examples with ==
console.log(5 == "5");     // true (string converted to number)
console.log(true == 1);    // true (boolean converted to number)
console.log(false == 0);   // true (boolean converted to number)
console.log(null == undefined); // true (special case)
console.log("" == 0);      // true (empty string converted to 0)

// Strict comparison with ===
console.log(5 === "5");    // false (different types)
console.log(true === 1);   // false (different types)
console.log(false === 0);  // false (different types)
console.log(null === undefined); // false (different types)
console.log("" === 0);     // false (different types)

// Tricky cases with ==
console.log([] == "");     // true (array converts to empty string)
console.log([1] == 1);     // true ([1] -> "1" -> 1)
console.log({} == "[object Object]"); // true

// Objects compared by reference
let obj1 = { a: 1 };
let obj2 = { a: 1 };
let obj3 = obj1;

console.log(obj1 == obj2);  // false (different objects)
console.log(obj1 === obj2); // false (different objects)
console.log(obj1 === obj3); // true (same reference)

// Best practice: Always use === unless you specifically need type coercion
```

### 5. What are falsy values in JavaScript?

JavaScript has exactly **8 falsy values** that evaluate to `false` in boolean contexts:

```javascript
// The 8 falsy values:
false        // Boolean false
0            // Number zero
-0           // Negative zero
0n           // BigInt zero
""           // Empty string (double quotes)
''           // Empty string (single quotes)
``           // Empty template literal
null         // Null value
undefined    // Undefined value
NaN          // Not a Number

// Testing falsy values
const falsyValues = [false, 0, -0, 0n, "", '', ``, null, undefined, NaN];

falsyValues.forEach((value, index) => {
  console.log(`${index}: ${value} -> ${Boolean(value)}`); // All print false
});

// Everything else is truthy (including empty arrays and objects!)
console.log(Boolean([]));    // true (empty array)
console.log(Boolean({}));    // true (empty object)
console.log(Boolean("0"));   // true (string "0")
console.log(Boolean("false")); // true (string "false")

// Practical usage - default values
function greet(name) {
  name = name || "Guest";    // If name is falsy, use "Guest"
  return `Hello, ${name}!`;
}

console.log(greet("John"));  // "Hello, John!"
console.log(greet(""));      // "Hello, Guest!" (empty string is falsy)
console.log(greet(null));    // "Hello, Guest!" (null is falsy)

// Better approach with nullish coalescing (ES2020)
function greetBetter(name) {
  name = name ?? "Guest";    // Only null/undefined use default
  return `Hello, ${name}!`;
}

console.log(greetBetter(""));   // "Hello, !" (empty string kept)
console.log(greetBetter(null)); // "Hello, Guest!" (null uses default)

// Form validation example
function validateInput(input) {
  if (!input) {
    return "Input is required";
  }
  return "Valid input";
}

console.log(validateInput(""));        // "Input is required"
console.log(validateInput(0));         // "Input is required"
console.log(validateInput(null));      // "Input is required"
console.log(validateInput("hello"));   // "Valid input"
```

## **Functions & Scope - Detailed Answers**

### 6. What's the difference between function declarations and function expressions?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      FEATURE        â”‚ Function Declarationâ”‚ Function Expression â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Hoisting            â”‚ âœ… Fully hoisted    â”‚ âŒ Not hoisted      â”‚
â”‚ Can call before def â”‚ âœ… Yes              â”‚ âŒ No               â”‚
â”‚ Named               â”‚ âœ… Always           â”‚ âš¡ Optional         â”‚
â”‚ Block scope         â”‚ âš ï¸ Varies by engine â”‚ âœ… Follows var/let  â”‚
â”‚ Conditional creationâ”‚ âŒ Avoid            â”‚ âœ… Safe             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```javascript
// FUNCTION DECLARATION
console.log(add(2, 3)); // âœ… Works! Returns 5 (hoisted)

function add(a, b) {
  return a + b;
}

// FUNCTION EXPRESSION
console.log(subtract); // undefined (variable hoisted, not function)
console.log(subtract(5, 2)); // âŒ TypeError: subtract is not a function

var subtract = function(a, b) {
  return a - b;
};

// NAMED FUNCTION EXPRESSION
const factorial = function fact(n) {
  return n <= 1 ? 1 : n * fact(n - 1); // Can use 'fact' inside
};
console.log(factorial(5)); // 120
// console.log(fact(5)); // âŒ ReferenceError: fact not defined outside

// CONDITIONAL CREATION - Function Expression is safer
let operation;
if (useAddition) {
  operation = function(a, b) { return a + b; };
} else {
  operation = function(a, b) { return a * b; };
}

// ARROW FUNCTION EXPRESSION (ES6)
const multiply = (a, b) => a * b;
const square = x => x * x;
const greet = () => "Hello!";
```

### 7. Explain the concept of scope in JavaScript.

**Scope** determines where variables can be accessed in your code. JavaScript has several types of scope:

```javascript
// GLOBAL SCOPE - accessible everywhere
var globalVar = "I'm global";
let globalLet = "I'm also global";
const globalConst = "Me too!";

function demonstrateScope() {
  // FUNCTION SCOPE - accessible within this function
  var functionScoped = "Only in this function";
  
  console.log(globalVar); // âœ… Can access global variables
  
  if (true) {
    // BLOCK SCOPE - only accessible within this block
    let blockScoped = "Only in this block";
    const alsoBlockScoped = "Me too!";
    var stillFunctionScoped = "I escape the block!";
    
    console.log(functionScoped); // âœ… Can access function scope
    console.log(blockScoped);    // âœ… Can access block scope
  }
  
  console.log(stillFunctionScoped); // âœ… var ignores block scope
  console.log(blockScoped);         // âŒ ReferenceError
}

// LEXICAL SCOPE - inner functions can access outer variables
function outerFunction(x) {
  const outerVar = "I'm in outer function";
  
  function innerFunction(y) {
    const innerVar = "I'm in inner function";
    console.log(outerVar); // âœ… Can access outer scope
    console.log(x);        // âœ… Can access outer parameters
    return x + y;
  }
  
  // console.log(innerVar); // âŒ Cannot access inner scope
  return innerFunction;
}

// SCOPE CHAIN - JavaScript looks up the scope chain
const globalValue = "global";

function level1() {
  const level1Value = "level1";
  
  function level2() {
    const level2Value = "level2";
    
    function level3() {
      console.log(level2Value); // Found in level2
      console.log(level1Value); // Found in level1
      console.log(globalValue); // Found in global
      // JavaScript searches: level3 â†’ level2 â†’ level1 â†’ global
    }
    
    return level3;
  }
  
  return level2;
}

// MODULE SCOPE (with ES6 modules)
// Each module has its own scope
// Variables are not automatically global
```

### 8. What is a closure? Can you provide an example?

A **closure** is a function that has access to variables from its outer (enclosing) scope even after the outer function has finished executing.

```javascript
// BASIC CLOSURE EXAMPLE
function createCounter() {
  let count = 0; // Private variable
  
  return function() {
    count++; // Accesses outer variable
    return count;
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1 (separate closure)
console.log(counter1()); // 3

// CLOSURE WITH PARAMETERS
function createMultiplier(multiplier) {
  return function(number) {
    return number * multiplier; // 'multiplier' is remembered
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// PRACTICAL EXAMPLE - Module Pattern
function createBankAccount(initialBalance) {
  let balance = initialBalance; // Private variable
  
  return {
    deposit: function(amount) {
      balance += amount;
      return balance;
    },
    withdraw: function(amount) {
      if (amount <= balance) {
        balance -= amount;
        return balance;
      }
      return "Insufficient funds";
    },
    getBalance: function() {
      return balance;
    }
  };
}

const account = createBankAccount(100);
console.log(account.deposit(50));  // 150
console.log(account.withdraw(30)); // 120
console.log(account.balance);      // undefined (private!)

// CLOSURE IN LOOPS - Common pitfall and solution
// âŒ Problem with var
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // Prints: 3, 3, 3
  }, 100);
}

// âœ… Solution 1: Use let (block scope)
for (let j = 0; j < 3; j++) {
  setTimeout(function() {
    console.log(j); // Prints: 0, 1, 2
  }, 100);
}

// âœ… Solution 2: Create closure with IIFE
for (var k = 0; k < 3; k++) {
  (function(index) {
    setTimeout(function() {
      console.log(index); // Prints: 0, 1, 2
    }, 100);
  })(k);
}
```

### 9. What does `this` keyword refer to in different contexts?

The `this` keyword refers to different objects depending on how and where it's used:

```javascript
// GLOBAL CONTEXT
console.log(this); // Window object (browser) or global object (Node.js)

function globalFunction() {
  console.log(this); // Window object (non-strict) or undefined (strict mode)
}

// OBJECT METHOD
const person = {
  name: "John",
  greet: function() {
    console.log(`Hello, I'm ${this.name}`); // 'this' refers to person object
  },
  nested: {
    name: "Nested",
    greet: function() {
      console.log(`Hello, I'm ${this.name}`); // 'this' refers to nested object
    }
  }
};

person.greet(); // "Hello, I'm John"
person.nested.greet(); // "Hello, I'm Nested"

// LOST CONTEXT PROBLEM
const greetFunction = person.greet;
greetFunction(); // "Hello, I'm undefined" - lost context!

// CONSTRUCTOR FUNCTION
function Person(name) {
  this.name = name; // 'this' refers to new instance
  this.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
  };
}

const john = new Person("John");
john.greet(); // "Hello, I'm John"

// ARROW FUNCTIONS - Lexical 'this'
const obj = {
  name: "Object",
  regularMethod: function() {
    console.log(`Regular: ${this.name}`); // 'this' is obj
    
    const arrowFunction = () => {
      console.log(`Arrow: ${this.name}`); // 'this' inherited from regularMethod
    };
    
    function regularInner() {
      console.log(`Inner: ${this.name}`); // 'this' is undefined/Window
    }
    
    arrowFunction();
    regularInner();
  }
};

obj.regularMethod();
// Regular: Object
// Arrow: Object
// Inner: undefined

// EXPLICIT BINDING with call, apply, bind
const person1 = { name: "Alice" };
const person2 = { name: "Bob" };

function introduce() {
  console.log(`Hi, I'm ${this.name}`);
}

introduce.call(person1);  // "Hi, I'm Alice"
introduce.apply(person2); // "Hi, I'm Bob"

const boundIntroduce = introduce.bind(person1);
boundIntroduce(); // "Hi, I'm Alice"

// EVENT HANDLERS
document.getElementById('myButton')?.addEventListener('click', function() {
  console.log(this); // Refers to the button element
});

// Arrow function in event handler
document.getElementById('myButton')?.addEventListener('click', () => {
  console.log(this); // Refers to global object (not the button!)
});
```

### 10. What are arrow functions and how do they differ from regular functions?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      FEATURE        â”‚  Regular Function   â”‚   Arrow Function    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Syntax              â”‚ function() {}       â”‚ () => {}            â”‚
â”‚ 'this' binding      â”‚ âš¡ Dynamic          â”‚ âœ… Lexical          â”‚
â”‚ 'arguments' object  â”‚ âœ… Available        â”‚ âŒ Not available    â”‚
â”‚ Hoisting            â”‚ âœ… Yes (if declared)â”‚ âŒ No               â”‚
â”‚ Constructor         â”‚ âœ… Can use 'new'    â”‚ âŒ Cannot           â”‚
â”‚ Method definition   â”‚ âœ… Good choice      â”‚ âš ï¸ Usually avoid   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```javascript
// SYNTAX VARIATIONS
// Regular function
function add(a, b) {
  return a + b;
}

// Arrow function - multiple parameters
const addArrow = (a, b) => {
  return a + b;
};

// Arrow function - single parameter (parentheses optional)
const double = x => x * 2;
const doubleExplicit = (x) => x * 2;

// Arrow function - no parameters
const sayHello = () => "Hello!";

// Arrow function - implicit return
const multiply = (a, b) => a * b;

// Arrow function - object return (needs parentheses)
const createUser = (name, age) => ({ name, age });

// Arrow function - multiline with explicit return
const complexCalculation = (x, y) => {
  const temp = x * 2;
  const result = temp + y;
  return result;
};

// 'THIS' BINDING DIFFERENCES
const obj = {
  name: "MyObject",
  
  // Regular method - 'this' refers to obj
  regularMethod: function() {
    console.log(`Regular: ${this.name}`); // "Regular: MyObject"
    
    // Regular function inside method - loses context
    setTimeout(function() {
      console.log(`Timeout Regular: ${this.name}`); // "Timeout Regular: undefined"
    }, 100);
    
    // Arrow function inside method - keeps context
    setTimeout(() => {
      console.log(`Timeout Arrow: ${this.name}`); // "Timeout Arrow: MyObject"
    }, 100);
  },
  
  // Arrow method - 'this' refers to global object
  arrowMethod: () => {
    console.log(`Arrow Method: ${this.name}`); // "Arrow Method: undefined"
  }
};

// ARGUMENTS OBJECT
function regularFunc() {
  console.log(arguments); // [Arguments] { '0': 1, '1': 2, '2': 3 }
  console.log(arguments.length); // 3
}

const arrowFunc = (...args) => {
  console.log(args); // [1, 2, 3] - use rest parameters instead
  console.log(args.length); // 3
};

regularFunc(1, 2, 3);
arrowFunc(1, 2, 3);

// CONSTRUCTOR USAGE
// Regular function as constructor
function Person(name) {
  this.name = name;
}

const person = new Person("John"); // âœ… Works

// Arrow function as constructor
const PersonArrow = (name) => {
  this.name = name;
};

// const person2 = new PersonArrow("Jane"); // âŒ TypeError: not a constructor

// PRACTICAL USE CASES

// âœ… Good for arrow functions: Array methods
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => x * 2);
const evens = numbers.filter(x => x % 2 === 0);
const sum = numbers.reduce((acc, x) => acc + x, 0);

// âœ… Good for arrow functions: Event handlers when you need lexical 'this'
class EventHandler {
  constructor() {
    this.count = 0;
  }
  
  handleClick = () => {
    this.count++; // 'this' correctly refers to class instance
    console.log(`Clicked ${this.count} times`);
  }
}

// âŒ Avoid arrow functions: Object methods
const badExample = {
  name: "Bad",
  greet: () => {
    console.log(`Hello ${this.name}`); // 'this' doesn't refer to object
  }
};

// âœ… Use regular functions: Object methods
const goodExample = {
  name: "Good",
  greet: function() {
    console.log(`Hello ${this.name}`); // 'this' correctly refers to object
  }
};
```

## **Objects & Arrays - Detailed Answers**

### 11. How do you add, remove, and access properties in JavaScript objects?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     OPERATION       â”‚    DOT NOTATION     â”‚  BRACKET NOTATION   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Access Property     â”‚ obj.property        â”‚ obj["property"]     â”‚
â”‚ Add Property        â”‚ obj.newProp = value â”‚ obj["newProp"] = valâ”‚
â”‚ Remove Property     â”‚ delete obj.property â”‚ delete obj["prop"]  â”‚
â”‚ Dynamic Keys        â”‚ âŒ Not possible     â”‚ âœ… obj[variable]    â”‚
â”‚ Special Characters  â”‚ âŒ Limited          â”‚ âœ… obj["key-name"]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```javascript
// CREATING OBJECTS
const person = {
  name: "John",
  age: 30,
  "favorite-color": "blue", // Special characters need quotes
  123: "numeric key"        // Numeric keys are converted to strings
};

// ACCESSING PROPERTIES
console.log(person.name);           // "John" - dot notation
console.log(person["age"]);         // 30 - bracket notation
console.log(person["favorite-color"]); // "blue" - special chars require brackets
console.log(person[123]);           // "numeric key" - numeric keys
console.log(person["123"]);         // "numeric key" - same as above

// DYNAMIC PROPERTY ACCESS
const propertyName = "age";
console.log(person[propertyName]);  // 30 - using variable
console.log(person.propertyName);   // undefined - looks for literal "propertyName"

// ADDING PROPERTIES
person.email = "john@example.com";  // Dot notation
person["phone"] = "123-456-7890";   // Bracket notation
person["last-login"] = new Date();  // Special characters

// Dynamic property addition
const newProp = "country";
person[newProp] = "USA";

// COMPUTED PROPERTY NAMES (ES6)
const key = "dynamicKey";
const obj = {
  [key]: "dynamic value",
  [`computed_${key}`]: "computed name"
};

// REMOVING PROPERTIES
delete person.phone;                // Returns true if successful
delete person["last-login"];

// Alternative removal methods
person.email = undefined;           // Property exists but value is undefined
person.country = null;              // Property exists but value is null

// CHECKING PROPERTY EXISTENCE
console.log("name" in person);          // true
console.log(person.hasOwnProperty("name")); // true
console.log(person.name !== undefined); // true

// Object.hasOwnProperty vs 'in' operator
const child = Object.create(person);
child.childProp = "child value";

console.log("name" in child);               // true (inherited)
console.log(child.hasOwnProperty("name"));  // false (not own property)

// PROPERTY DESCRIPTORS
Object.defineProperty(person, "secretAge", {
  value: 25,
  writable: false,    // Cannot be changed
  enumerable: false,  // Won't show in for...in or Object.keys()
  configurable: false // Cannot be deleted or redefined
});

// OBJECT METHODS FOR PROPERTY MANIPULATION
const user = { name: "Alice", age: 28, city: "NYC" };

// Getting property names and values
console.log(Object.keys(user));     // ["name", "age", "city"]
console.log(Object.values(user));   // ["Alice", 28, "NYC"]
console.log(Object.entries(user));  // [["name", "Alice"], ["age", 28], ...]

// Copying properties
const newUser = Object.assign({}, user, { role: "admin" });
const spreadUser = { ...user, role: "user" }; // ES6+ spread operator
```

### 12. What's the difference between dot notation and bracket notation?

```javascript
const obj = {
  name: "John",
  age: 30,
  "favorite-food": "pizza",
  "123": "numeric key",
  "": "empty key"
};

// âœ… DOT NOTATION - When to use:
console.log(obj.name);        // Simple property names
console.log(obj.age);         // Valid JavaScript identifiers

// âŒ DOT NOTATION - Limitations:
// console.log(obj.favorite-food);  // SyntaxError: Invalid
// console.log(obj.123);            // SyntaxError: Invalid
// console.log(obj."");             // SyntaxError: Invalid

// âœ… BRACKET NOTATION - More flexible:
console.log(obj["favorite-food"]); // Special characters
console.log(obj["123"]);           // Numeric keys
console.log(obj[""]);              // Empty string key

// DYNAMIC ACCESS
const properties = ["name", "age", "favorite-food"];
properties.forEach(prop => {
  console.log(`${prop}: ${obj[prop]}`); // âœ… Works with bracket notation
  // console.log(`${prop}: ${obj.prop}`); // âŒ Would look for literal "prop"
});

// COMPUTED PROPERTIES
function getValue(object, key) {
  return object[key]; // Must use bracket notation for parameter
}

// WHEN TO USE EACH:

// âœ… Use DOT notation for:
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
};

console.log(config.apiUrl);
config.timeout = 10000;

// âœ… Use BRACKET notation for:
const data = {
  "user-name": "john_doe",
  "api-key": "secret123",
  "2023-data": {...}
};

// Variables as keys
const keyName = "user-name";
console.log(data[keyName]);

// Special characters
console.log(data["api-key"]);

// Dynamic property names
const year = 2023;
console.log(data[`${year}-data`]);

// Loop through properties
for (const key in data) {
  console.log(`${key}: ${data[key]}`); // Must use bracket notation
}

// PERFORMANCE CONSIDERATION
// Dot notation is slightly faster (compiled time resolution)
// Bracket notation is resolved at runtime

// NESTED OBJECTS
const user = {
  profile: {
    personal: {
      name: "John",
      "birth-year": 1990
    }
  }
};

// Accessing nested properties
console.log(user.profile.personal.name);
console.log(user["profile"]["personal"]["birth-year"]);
console.log(user.profile.personal["birth-year"]); // Mixed notation
```

### 13. Name 5 array methods and explain what they do.

```javascript
const numbers = [1, 2, 3, 4, 5];
const fruits = ["apple", "banana", "orange"];
const users = [
  { name: "John", age: 30 },
  { name: "Jane", age: 25 },
  { name: "Bob", age: 35 }
];

// âœ… 1. PUSH() - Adds elements to the end
console.log(fruits.push("grape"));      // Returns new length: 4
console.log(fruits);                    // ["apple", "banana", "orange", "grape"]

// Add multiple elements
fruits.push("kiwi", "mango");
console.log(fruits);                    // [..., "grape", "kiwi", "mango"]

// âœ… 2. POP() - Removes and returns the last element
const lastFruit = fruits.pop();
console.log(lastFruit);                 // "mango"
console.log(fruits);                    // [..., "kiwi"] (mango removed)

// âœ… 3. SLICE() - Returns a shallow copy of a portion (doesn't modify original)
const someNumbers = numbers.slice(1, 4); // From index 1 to 3 (4 excluded)
console.log(someNumbers);               // [2, 3, 4]
console.log(numbers);                   // [1, 2, 3, 4, 5] (unchanged)

// Slice without end parameter
console.log(numbers.slice(2));          // [3, 4, 5] (from index 2 to end)

// Negative indices
console.log(numbers.slice(-2));         // [4, 5] (last 2 elements)
console.log(numbers.slice(-3, -1));     // [3, 4] (from 3rd last to 2nd last)

// âœ… 4. SPLICE() - Changes array by removing/adding elements (modifies original)
const colors = ["red", "green", "blue", "yellow"];

// Remove elements: splice(start, deleteCount)
const removed = colors.splice(1, 2);    // Remove 2 elements starting at index 1
console.log(removed);                   // ["green", "blue"] (removed elements)
console.log(colors);                    // ["red", "yellow"] (original modified)

// Add elements: splice(start, deleteCount, ...itemsToAdd)
colors.splice(1, 0, "purple", "orange"); // Add at index 1, remove 0
console.log(colors);                    // ["red", "purple", "orange", "yellow"]

// Replace elements
colors.splice(1, 2, "pink");            // Remove 2, add 1 at index 1
console.log(colors);                    // ["red", "pink", "yellow"]

// âœ… 5. INDEXOF() - Returns first index of element, or -1 if not found
console.log(fruits.indexOf("banana"));  // 1
console.log(fruits.indexOf("grape"));   // -1 (not found)
console.log(fruits.indexOf("apple"));   // 0

// Case sensitive
console.log(fruits.indexOf("Apple"));   // -1 (capital A not found)

// Find from specific starting position
const duplicates = ["a", "b", "c", "b", "d"];
console.log(duplicates.indexOf("b"));      // 1 (first occurrence)
console.log(duplicates.indexOf("b", 2));   // 3 (search starting from index 2)

// BONUS METHODS:

// âœ… UNSHIFT() - Adds elements to the beginning
fruits.unshift("strawberry");
console.log(fruits);                    // ["strawberry", "apple", "banana", ...]

// âœ… SHIFT() - Removes and returns first element
const firstFruit = fruits.shift();
console.log(firstFruit);               // "strawberry"

// âœ… INCLUDES() - Checks if array contains element (ES2016+)
console.log(numbers.includes(3));      // true
console.log(numbers.includes(10));     // false

// âœ… REVERSE() - Reverses array in place
const reversed = numbers.reverse();
console.log(numbers);                  // [5, 4, 3, 2, 1] (original modified)
console.log(reversed === numbers);     // true (same reference)

// âœ… SORT() - Sorts array in place
const names = ["Charlie", "Alice", "Bob"];
names.sort();
console.log(names);                    // ["Alice", "Bob", "Charlie"]

// Custom sort function
users.sort((a, b) => a.age - b.age);  // Sort by age ascending
console.log(users);                    // Sorted by age

// MUTATING vs NON-MUTATING METHODS:

// ğŸ”„ MUTATING (modify original array):
// push(), pop(), shift(), unshift(), splice(), reverse(), sort()

// ğŸ”’ NON-MUTATING (return new array/value):
// slice(), indexOf(), includes(), concat(), join()
```

### 14. What's the difference between `map()`, `filter()`, and `forEach()`?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      METHOD         â”‚      forEach()      â”‚       map()         â”‚      filter()       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Returns             â”‚ undefined           â”‚ âœ… New array        â”‚ âœ… New array        â”‚
â”‚ Original Array      â”‚ âœ… Unchanged        â”‚ âœ… Unchanged        â”‚ âœ… Unchanged        â”‚
â”‚ Purpose             â”‚ Side effects        â”‚ Transform elements  â”‚ Select elements     â”‚
â”‚ Break Early         â”‚ âŒ No              â”‚ âŒ No              â”‚ âŒ No              â”‚
â”‚ Chainable           â”‚ âŒ No              â”‚ âœ… Yes             â”‚ âœ… Yes             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```javascript
const numbers = [1, 2, 3, 4, 5];
const users = [
  { name: "John", age: 30, active: true },
  { name: "Jane", age: 25, active: false },
  { name: "Bob", age: 35, active: true },
  { name: "Alice", age: 28, active: true }
];

// âœ… FOREACH() - Execute function for each element (no return value)
console.log("=== forEach() ===");
numbers.forEach((num, index, array) => {
  console.log(`Index ${index}: ${num}`);
  // Can't break or return early
});

// Side effects example
let sum = 0;
numbers.forEach(num => {
  sum += num; // Modifying external variable
});
console.log(`Sum: ${sum}`); // 15

// âŒ forEach doesn't return anything useful
const forEachResult = numbers.forEach(num => num * 2);
console.log(forEachResult); // undefined

// âœ… MAP() - Transform each element and return new array
console.log("=== map() ===");
const doubled = numbers.map(num => num * 2);
console.log(doubled);       // [2, 4, 6, 8, 10]
console.log(numbers);       // [1, 2, 3, 4, 5] (unchanged)

// Transform objects
const userNames = users.map(user => user.name);
console.log(userNames);     // ["John", "Jane", "Bob", "Alice"]

// More complex transformations
const userSummaries = users.map(user => ({
  displayName: user.name.toUpperCase(),
  isAdult: user.age >= 18,
  status: user.active ? "Active" : "Inactive"
}));
console.log(userSummaries);

// Map with index
const numbersWithIndex = numbers.map((num, index) => `${index}: ${num}`);
console.log(numbersWithIndex); // ["0: 1", "1: 2", "2: 3", "3: 4", "4: 5"]

// âœ… FILTER() - Select elements that pass a test
console.log("=== filter() ===");
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers);   // [2, 4]

const activeUsers = users.filter(user => user.active);
console.log(activeUsers);   // Only users with active: true

// Filter with multiple conditions
const youngActiveUsers = users.filter(user => user.age < 30 && user.active);
console.log(youngActiveUsers);

// Filter with index
const firstThree = numbers.filter((num, index) => index < 3);
console.log(firstThree);    // [1, 2, 3]

// CHAINING METHODS (map and filter return arrays)
console.log("=== Chaining ===");
const result = users
  .filter(user => user.active)           // Get active users
  .map(user => user.name.toUpperCase())  // Transform to uppercase names
  .filter(name => name.length > 3);      // Only names longer than 3 chars

console.log(result); // ["JOHN", "ALICE"]

// Complex chaining example
const processedData = numbers
  .filter(num => num > 2)     // [3, 4, 5]
  .map(num => num * 3)        // [9, 12, 15]
  .filter(num => num < 14);   // [9, 12]

console.log(processedData);

// âŒ CAN'T chain forEach (returns undefined)
// numbers.forEach(num => num * 2).filter(num => num > 5); // TypeError!

// PERFORMANCE COMPARISON
console.log("=== Performance ===");
const largeArray = Array.from({ length: 1000000 }, (_, i) => i);

// forEach - for side effects only
console.time("forEach");
let total = 0;
largeArray.forEach(num => {
  total += num;
});
console.timeEnd("forEach");

// map - when you need to transform
console.time("map");
const transformed = largeArray.map(num => num * 2);
console.timeEnd("map");

// filter - when you need to select
console.time("filter");
const filtered = largeArray.filter(num => num % 2 === 0);
console.timeEnd("filter");

// WHEN TO USE EACH:

// âœ… Use forEach when:
// - You need to perform side effects (logging, DOM manipulation, etc.)
// - You don't need a return value
// - You're not transforming data

// âœ… Use map when:
// - You need to transform every element
// - You want a new array of the same length
// - You're creating React components from data

// âœ… Use filter when:
// - You need to select elements based on criteria
// - You want a new array with fewer elements
// - You're implementing search functionality

// PRACTICAL EXAMPLES
const products = [
  { name: "Laptop", price: 1000, inStock: true },
  { name: "Phone", price: 500, inStock: false },
  { name: "Tablet", price: 300, inStock: true }
];

// Get available product names
const availableProducts = products
  .filter(product => product.inStock)
  .map(product => product.name);

// Apply discount to all prices
const discountedProducts = products.map(product => ({
  ...product,
  price: product.price * 0.9
}));

// Log each product (side effect)
products.forEach(product => {
  console.log(`${product.name}: $${product.price}`);
});
```

### 15. How do you check if a variable is an array?

```javascript
// âœ… RECOMMENDED METHOD: Array.isArray() (ES5+)
console.log(Array.isArray([]));           // true
console.log(Array.isArray([1, 2, 3]));    // true
console.log(Array.isArray("string"));     // false
console.log(Array.isArray({}));           // false
console.log(Array.isArray(null));         // false
console.log(Array.isArray(undefined));    // false

// âœ… ALTERNATIVE: instanceof operator
const arr = [1, 2, 3];
console.log(arr instanceof Array);        // true

// âš ï¸ instanceof issues with iframes
// If array comes from different window/iframe:
// frameArray instanceof Array  // might be false!
// Array.isArray(frameArray)     // always works correctly

// âŒ UNRELIABLE: typeof operator
console.log(typeof []);                   // "object" (not helpful!)
console.log(typeof {});                   // "object" (same as array)

// âŒ UNRELIABLE: constructor property
const myArray = [1, 2, 3];
console.log(myArray.constructor === Array); // true, but can be modified

// Someone could change it:
// myArray.constructor = String;
// myArray.constructor === Array; // now false!

// âœ… ROBUST: Object.prototype.toString.call()
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}

console.log(getType([]));           // "Array"
console.log(getType({}));           // "Object"
console.log(getType("string"));     // "String"
console.log(getType(42));           // "Number"
console.log(getType(null));         // "Null"
console.log(getType(undefined));    // "Undefined"

// COMPARISON OF ALL METHODS:

const testCases = [
  [],
  [1, 2, 3],
  {},
  "string",
  42,
  null,
  undefined,
  new Array(),
  Array.from([1, 2, 3])
];

console.log("Value".padEnd(15) + "Array.isArray".padEnd(15) + "instanceof".padEnd(12) + "typeof".padEnd(10) + "toString");
console.log("-".repeat(70));

testCases.forEach(value => {
  const str = JSON.stringify(value) || String(value);
  const isArray = Array.isArray(value);
  const instanceof_result = value instanceof Array;
  const typeof_result = typeof value;
  const toString_result = Object.prototype.toString.call(value).slice(8, -1);
  
  console.log(
    str.padEnd(15) + 
    String(isArray).padEnd(15) + 
    String(instanceof_result).padEnd(12) + 
    typeof_result.padEnd(10) + 
    toString_result
  );
});

// PRACTICAL USAGE EXAMPLES:

// âœ… Function that accepts array or single value
function processItems(items) {
  // Normalize to array
  const itemArray = Array.isArray(items) ? items : [items];
  
  return itemArray.map(item => `Processed: ${item}`);
}

console.log(processItems("single"));      // ["Processed: single"]
console.log(processItems(["a", "b"]));    // ["Processed: a", "Processed: b"]

// âœ… Type guard function
function isArrayOfStrings(value) {
  return Array.isArray(value) && value.every(item => typeof item === "string");
}

console.log(isArrayOfStrings(["a", "b"]));     // true
console.log(isArrayOfStrings(["a", 1]));       // false
console.log(isArrayOfStrings("string"));       // false

// âœ… Safe array operations
function safeMap(array, callback) {
  if (!Array.isArray(array)) {
    throw new Error("First argument must be an array");
  }
  return array.map(callback);
}

// âœ… Array-like objects vs real arrays
const arrayLike = {
  0: "first",
  1: "second",
  length: 2
};

console.log(Array.isArray(arrayLike));          // false
console.log(Array.isArray(Array.from(arrayLike))); // true

// Arguments object (in regular functions)
function testArguments() {
  console.log(Array.isArray(arguments));        // false
  console.log(Array.isArray([...arguments]));   // true
}

testArguments(1, 2, 3);

// NodeList vs Array
// const nodeList = document.querySelectorAll('div');
// console.log(Array.isArray(nodeList));        // false
// console.log(Array.isArray([...nodeList]));   // true

// POLYFILL for older browsers (if needed)
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}

// BEST PRACTICES:
// 1. Always use Array.isArray() for modern JavaScript
// 2. Use instanceof only if you're sure about the context
// 3. Never rely on typeof for array detection
// 4. Consider array-like objects in your logic
// 5. Use type guards for more specific checking
```
